{"version":3,"sources":["assets\\scripts\\ai\\strategies\\Wanderer.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["import { ButtonState } from \"../../input/IInputControls\";\r\nimport Agent from \"../Agent\";\r\nimport { AI } from \"./AgentStrategy\";\r\n\r\n/**\r\n * An AI strategy that describes a \"wandering\" behaviour.\r\n */\r\nexport class Wanderer extends AI.Strategy {\r\n    /** The agent will move for this long before stopping to wait. */\r\n    private _moveDuration = 1.0;\r\n    /** The agent will wait for this long before starting to move again. */\r\n    private _waitDuration = 0.5;\r\n    /** The actual wait duration will be randomized by this factor, \r\n     *  such that the actual wait duration is a random number between\r\n     *  waitDuration x (1 - waitRandomFactor) and \r\n     *  waitDuration x (1 + waitRandomFactor).\r\n    */\r\n    private _waitRandomFactor = 0.1;\r\n\r\n    constructor(moveDuration: number, waitDuration: number, waitRandomFactor: number) {\r\n        super();\r\n        //*||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*\\\\\r\n        // TODO (2.1): Complete the constructor.\r\n        // [SPECIFICATIONS]\r\n        // - Initialize the four private variables above properly.\r\n        //*||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*\\\\\r\n        //#region [YOUR IMPLEMENTATION HERE]\r\n        this._moveDuration = moveDuration;\r\n        this._waitDuration = waitDuration;\r\n        this._waitRandomFactor = waitRandomFactor;\r\n        //#endregion\r\n    }\r\n\r\n    /** The time point after which the agent should wait. */\r\n    private _nextWaitTime = 0;\r\n    /** The time point after which the agent should move again. */\r\n    private _nextMoveTime = 0;\r\n    /** The velocity (vector with magnitude) at which the agent should move. */\r\n    private _wanderVelocity = cc.Vec2.ZERO;\r\n    /** The agent's output to IInput. */\r\n    private _moveAxis2D = cc.Vec2.ZERO;\r\n\r\n    //*||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*\\\\\r\n    // TODO (2.2): Map moveAxis2D to horizontal and vertical axes.\r\n    // [SPECIFICATIONS]\r\n    // - moveAxis2D.x should be mapped to the horizontal axis.\r\n    // - moveAxis2D.y should be mapped to the vertical axis.\r\n    // - You can leave the remaining unimplemented.\r\n    //*||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*\\\\\r\n    public get horizontalAxis(): number {\r\n        //#region [YOUR IMPLEMENTATION HERE]\r\n        return this._moveAxis2D.x;\r\n        //#endregion\r\n    }\r\n    public get verticalAxis(): number {\r\n        //#region [YOUR IMPLEMENTATION HERE]\r\n        return this._moveAxis2D.y;\r\n        //#endregion\r\n    }\r\n    public get attack(): ButtonState {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    public get interact(): ButtonState {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    public start() {\r\n        this._nextMoveTime = cc.director.getTotalTime() / 1000.0;\r\n        this._nextWaitTime = this._nextMoveTime - this._waitDuration;\r\n    }\r\n    public update(dt: number) {\r\n        /** The current time in the game in seconds. */\r\n        let currentTime = cc.director.getTotalTime() / 1000.0;\r\n\r\n        //*||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*\\\\\r\n        // TODO (2.3): Implement the behaviour of a wandering agent.\r\n        // [SPECIFICATIONS]\r\n        // 1. The agent should recompute its wandering direction when the\r\n        //    current time (curTime) reaches the next move time (this.nextMoveTime)\r\n        //     - When this happens, recompute the next move time and the next wait \r\n        //       time.\r\n        //     - Compute the wandering direction as a random 2D vector using the\r\n        //       provided function \"randomPointOnCircle\".\r\n        // 2. The agent's movement axes (this.moveAxis2D)\r\n        //    should be equal to the wander velocity (this.wanderVelocity) before\r\n        //    the next wait time (this.nextWaitTime). \r\n        //    OTHERWISE it should be equal to cc.Vec2.ZERO.\r\n        //*||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||*\\\\\r\n\r\n        //#region [YOUR IMPLEMENTATION HERE]\r\n        if (currentTime >= this._nextMoveTime) {\r\n            this._nextWaitTime = currentTime + this._moveDuration;\r\n            this._nextMoveTime = this._nextWaitTime + this._waitDuration * (1.0 * this._waitRandomFactor * (Math.random() - 2.0 * 1.0));\r\n\r\n            this._wanderVelocity = randomPointOnUnitCircle()\r\n        }\r\n\r\n        this ._moveAxis2D = (currentTime < this._nextWaitTime) ? this._wanderVelocity : cc.Vec2.ZERO;\r\n        //#endregion\r\n    }\r\n\r\n}\r\n\r\nfunction randomPointOnUnitCircle() {\r\n    let angle = Math.random() * Math.PI * 2;\r\n    return new cc.Vec2(Math.cos(angle), Math.sin(angle));\r\n}"]}
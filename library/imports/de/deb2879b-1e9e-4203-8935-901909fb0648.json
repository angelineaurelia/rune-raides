{
  "__type__": "cc.TextAsset",
  "_name": "firebase-compat.d",
  "_objFlags": 0,
  "_native": "",
  "text": "/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * <code>firebase</code> is a global namespace from which all Firebase\r\n * services are accessed.\r\n */\r\ndeclare namespace firebase {\r\n  /**\r\n   * @hidden\r\n   */\r\n  type NextFn<T> = (value: T) => void;\r\n  /**\r\n   * @hidden\r\n   */\r\n  type ErrorFn<E = Error> = (error: E) => void;\r\n  /**\r\n   * @hidden\r\n   */\r\n  type CompleteFn = () => void;\r\n\r\n  /**\r\n   * `FirebaseError` is a subclass of the standard JavaScript `Error` object. In\r\n   * addition to a message string and stack trace, it contains a string code.\r\n   */\r\n  interface FirebaseError {\r\n    /**\r\n     * Error codes are strings using the following format: `\"service/string-code\"`.\r\n     * Some examples include `\"app/no-app\"` and `\"auth/user-not-found\"`.\r\n     *\r\n     * While the message for a given error can change, the code will remain the same\r\n     * between backward-compatible versions of the Firebase SDK.\r\n     */\r\n    code: string;\r\n    /**\r\n     * An explanatory message for the error that just occurred.\r\n     *\r\n     * This message is designed to be helpful to you, the developer. Because\r\n     * it generally does not convey meaningful information to end users,\r\n     * this message should not be displayed in your application.\r\n     */\r\n    message: string;\r\n    /**\r\n     * The name of the class of errors, which is `\"FirebaseError\"`.\r\n     */\r\n    name: \"FirebaseError\";\r\n    /**\r\n     * A string value containing the execution backtrace when the error originally\r\n     * occurred. This may not always be available.\r\n     *\r\n     * When it is available, this information can be sent to\r\n     * {@link https://firebase.google.com/support/ Firebase Support} to help\r\n     * explain the cause of an error.\r\n     */\r\n    stack?: string;\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  interface Observer<T, E = Error> {\r\n    next: NextFn<T>;\r\n    error: ErrorFn<E>;\r\n    complete: CompleteFn;\r\n  }\r\n\r\n  /**\r\n   * The JS SDK supports 5 log levels and also allows a user the ability to\r\n   * silence the logs altogether.\r\n   *\r\n   * The order is as follows:\r\n   * silent < debug < verbose < info < warn < error\r\n   */\r\n  type LogLevel = \"debug\" | \"verbose\" | \"info\" | \"warn\" | \"error\" | \"silent\";\r\n\r\n  /**\r\n   * The current SDK version.\r\n   */\r\n  var SDK_VERSION: string;\r\n\r\n  /**\r\n   * Registers a library's name and version for platform logging purposes.\r\n   * @param library Name of 1p or 3p library (e.g. firestore, angularfire)\r\n   * @param version Current version of that library.\r\n   * @param variant Bundle variant, e.g., node, rn, etc.\r\n   */\r\n  function registerVersion(\r\n    library: string,\r\n    version: string,\r\n    variant?: string,\r\n  ): void;\r\n\r\n  /**\r\n   * Sets log level for all Firebase packages.\r\n   *\r\n   * All of the log types above the current log level are captured (i.e. if\r\n   * you set the log level to `info`, errors are logged, but `debug` and\r\n   * `verbose` logs are not).\r\n   */\r\n  function setLogLevel(logLevel: LogLevel): void;\r\n\r\n  /**\r\n   * Sets log handler for all Firebase packages.\r\n   * @param logCallback An optional custom log handler that executes user code whenever\r\n   * the Firebase SDK makes a logging call.\r\n   */\r\n  function onLog(\r\n    logCallback: (callbackParams: {\r\n      /**\r\n       * Level of event logged.\r\n       */\r\n      level: LogLevel;\r\n      /**\r\n       * Any text from logged arguments joined into one string.\r\n       */\r\n      message: string;\r\n      /**\r\n       * The raw arguments passed to the log call.\r\n       */\r\n      args: any[];\r\n      /**\r\n       * A string indicating the name of the package that made the log call,\r\n       * such as `@firebase/firestore`.\r\n       */\r\n      type: string;\r\n    }) => void,\r\n    options?: {\r\n      /**\r\n       * Threshhold log level. Only logs at or above this level trigger the `logCallback`\r\n       * passed to `onLog`.\r\n       */\r\n      level: LogLevel;\r\n    },\r\n  ): void;\r\n\r\n  /**\r\n   * @hidden\r\n   */\r\n  type Unsubscribe = () => void;\r\n\r\n  /**\r\n   * A user account.\r\n   */\r\n  interface User extends firebase.UserInfo {\r\n    /**\r\n     * Deletes and signs out the user.\r\n     *\r\n     * <b>Important:</b> this is a security-sensitive operation that requires the\r\n     * user to have recently signed in. If this requirement isn't met, ask the user\r\n     * to authenticate again and then call\r\n     * {@link firebase.User.reauthenticateWithCredential}.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/requires-recent-login</dt>\r\n     * <dd>Thrown if the user's last sign-in time does not meet the security\r\n     *     threshold. Use {@link firebase.User.reauthenticateWithCredential} to\r\n     *     resolve. This does not apply if the user is anonymous.</dd>\r\n     * </dl>\r\n     */\r\n    delete(): Promise<void>;\r\n    emailVerified: boolean;\r\n    getIdTokenResult(\r\n      forceRefresh?: boolean,\r\n    ): Promise<firebase.auth.IdTokenResult>;\r\n    /**\r\n     * Returns a JSON Web Token (JWT) used to identify the user to a Firebase\r\n     * service.\r\n     *\r\n     * Returns the current token if it has not expired. Otherwise, this will\r\n     * refresh the token and return a new one.\r\n     *\r\n     * @param forceRefresh Force refresh regardless of token\r\n     *     expiration.\r\n     */\r\n    getIdToken(forceRefresh?: boolean): Promise<string>;\r\n    isAnonymous: boolean;\r\n    /**\r\n     * Links the user account with the given credentials and returns any available\r\n     * additional user information, such as user name.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/provider-already-linked</dt>\r\n     * <dd>Thrown if the provider has already been linked to the user. This error is\r\n     *     thrown even if this is not the same provider's account that is currently\r\n     *     linked to the user.</dd>\r\n     * <dt>auth/invalid-credential</dt>\r\n     * <dd>Thrown if the provider's credential is not valid. This can happen if it\r\n     *     has already expired when calling link, or if it used invalid token(s).\r\n     *     See the Firebase documentation for your provider, and make sure you pass\r\n     *     in the correct parameters to the credential method.</dd>\r\n     * <dt>auth/credential-already-in-use</dt>\r\n     * <dd>Thrown if the account corresponding to the credential already exists\r\n     *     among your users, or is already linked to a Firebase User.\r\n     *     For example, this error could be thrown if you are upgrading an anonymous\r\n     *     user to a Google user by linking a Google credential to it and the Google\r\n     *     credential used is already associated with an existing Firebase Google\r\n     *     user.\r\n     *     The fields <code>error.email</code>, <code>error.phoneNumber</code>, and\r\n     *     <code>error.credential</code> ({@link firebase.auth.AuthCredential})\r\n     *     may be provided, depending on the type of credential. You can recover\r\n     *     from this error by signing in with <code>error.credential</code> directly\r\n     *     via {@link firebase.auth.Auth.signInWithCredential}.</dd>\r\n     * <dt>auth/email-already-in-use</dt>\r\n     * <dd>Thrown if the email corresponding to the credential already exists\r\n     *     among your users. When thrown while linking a credential to an existing\r\n     *     user, an <code>error.email</code> and <code>error.credential</code>\r\n     *     ({@link firebase.auth.AuthCredential}) fields are also provided.\r\n     *     You have to link the credential to the existing user with that email if\r\n     *     you wish to continue signing in with that credential. To do so, call\r\n     *     {@link firebase.auth.Auth.fetchSignInMethodsForEmail}, sign in to\r\n     *     <code>error.email</code> via one of the providers returned and then\r\n     *     {@link firebase.User.linkWithCredential} the original credential to that\r\n     *     newly signed in user.</dd>\r\n     * <dt>auth/operation-not-allowed</dt>\r\n     * <dd>Thrown if you have not enabled the provider in the Firebase Console. Go\r\n     *     to the Firebase Console for your project, in the Auth section and the\r\n     *     <strong>Sign in Method</strong> tab and configure the provider.</dd>\r\n     * <dt>auth/invalid-email</dt>\r\n     * <dd>Thrown if the email used in a\r\n     *     {@link firebase.auth.EmailAuthProvider.credential} is invalid.</dd>\r\n     * <dt>auth/wrong-password</dt>\r\n     * <dd>Thrown if the password used in a\r\n     *     {@link firebase.auth.EmailAuthProvider.credential} is not correct or\r\n     *     when the user associated with the email does not have a password.</dd>\r\n     * <dt>auth/invalid-verification-code</dt>\r\n     * <dd>Thrown if the credential is a\r\n     *     {@link firebase.auth.PhoneAuthProvider.credential} and the verification\r\n     *     code of the credential is not valid.</dd>\r\n     * <dt>auth/invalid-verification-id</dt>\r\n     * <dd>Thrown if the credential is a\r\n     *     {@link firebase.auth.PhoneAuthProvider.credential}  and the verification\r\n     *     ID of the credential is not valid.</dd>\r\n     * </dl>\r\n     *\r\n     * @deprecated  This method is deprecated. Use\r\n     * {@link firebase.User.linkWithCredential} instead.\r\n     *\r\n     * @param credential The auth credential.\r\n     */\r\n    linkAndRetrieveDataWithCredential(\r\n      credential: firebase.auth.AuthCredential,\r\n    ): Promise<firebase.auth.UserCredential>;\r\n    /**\r\n     * Links the user account with the given credentials.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/provider-already-linked</dt>\r\n     * <dd>Thrown if the provider has already been linked to the user. This error is\r\n     *     thrown even if this is not the same provider's account that is currently\r\n     *     linked to the user.</dd>\r\n     * <dt>auth/invalid-credential</dt>\r\n     * <dd>Thrown if the provider's credential is not valid. This can happen if it\r\n     *     has already expired when calling link, or if it used invalid token(s).\r\n     *     See the Firebase documentation for your provider, and make sure you pass\r\n     *     in the correct parameters to the credential method.</dd>\r\n     * <dt>auth/credential-already-in-use</dt>\r\n     * <dd>Thrown if the account corresponding to the credential already exists\r\n     *     among your users, or is already linked to a Firebase User.\r\n     *     For example, this error could be thrown if you are upgrading an anonymous\r\n     *     user to a Google user by linking a Google credential to it and the Google\r\n     *     credential used is already associated with an existing Firebase Google\r\n     *     user.\r\n     *     The fields <code>error.email</code>, <code>error.phoneNumber</code>, and\r\n     *     <code>error.credential</code> ({@link firebase.auth.AuthCredential})\r\n     *     may be provided, depending on the type of credential. You can recover\r\n     *     from this error by signing in with <code>error.credential</code> directly\r\n     *     via {@link firebase.auth.Auth.signInWithCredential}.</dd>\r\n     * <dt>auth/email-already-in-use</dt>\r\n     * <dd>Thrown if the email corresponding to the credential already exists\r\n     *     among your users. When thrown while linking a credential to an existing\r\n     *     user, an <code>error.email</code> and <code>error.credential</code>\r\n     *     ({@link firebase.auth.AuthCredential}) fields are also provided.\r\n     *     You have to link the credential to the existing user with that email if\r\n     *     you wish to continue signing in with that credential. To do so, call\r\n     *     {@link firebase.auth.Auth.fetchSignInMethodsForEmail}, sign in to\r\n     *     <code>error.email</code> via one of the providers returned and then\r\n     *     {@link firebase.User.linkWithCredential} the original credential to that\r\n     *     newly signed in user.</dd>\r\n     * <dt>auth/operation-not-allowed</dt>\r\n     * <dd>Thrown if you have not enabled the provider in the Firebase Console. Go\r\n     *     to the Firebase Console for your project, in the Auth section and the\r\n     *     <strong>Sign in Method</strong> tab and configure the provider.</dd>\r\n     * <dt>auth/invalid-email</dt>\r\n     * <dd>Thrown if the email used in a\r\n     *     {@link firebase.auth.EmailAuthProvider.credential} is invalid.</dd>\r\n     * <dt>auth/wrong-password</dt>\r\n     * <dd>Thrown if the password used in a\r\n     *     {@link firebase.auth.EmailAuthProvider.credential} is not correct or\r\n     *     when the user associated with the email does not have a password.</dd>\r\n     * <dt>auth/invalid-verification-code</dt>\r\n     * <dd>Thrown if the credential is a\r\n     *     {@link firebase.auth.PhoneAuthProvider.credential} and the verification\r\n     *     code of the credential is not valid.</dd>\r\n     * <dt>auth/invalid-verification-id</dt>\r\n     * <dd>Thrown if the credential is a\r\n     *     {@link firebase.auth.PhoneAuthProvider.credential}  and the verification\r\n     *     ID of the credential is not valid.</dd>\r\n     * </dl>\r\n     *\r\n     * @param credential The auth credential.\r\n     */\r\n    linkWithCredential(\r\n      credential: firebase.auth.AuthCredential,\r\n    ): Promise<firebase.auth.UserCredential>;\r\n    /**\r\n     * Links the user account with the given phone number.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/provider-already-linked</dt>\r\n     * <dd>Thrown if the provider has already been linked to the user. This error is\r\n     *     thrown even if this is not the same provider's account that is currently\r\n     *     linked to the user.</dd>\r\n     * <dt>auth/captcha-check-failed</dt>\r\n     * <dd>Thrown if the reCAPTCHA response token was invalid, expired, or if\r\n     *     this method was called from a non-whitelisted domain.</dd>\r\n     * <dt>auth/invalid-phone-number</dt>\r\n     * <dd>Thrown if the phone number has an invalid format.</dd>\r\n     * <dt>auth/missing-phone-number</dt>\r\n     * <dd>Thrown if the phone number is missing.</dd>\r\n     * <dt>auth/quota-exceeded</dt>\r\n     * <dd>Thrown if the SMS quota for the Firebase project has been exceeded.</dd>\r\n     * <dt>auth/user-disabled</dt>\r\n     * <dd>Thrown if the user corresponding to the given phone number has been\r\n     *     disabled.</dd>\r\n     * <dt>auth/credential-already-in-use</dt>\r\n     * <dd>Thrown if the account corresponding to the phone number already exists\r\n     *     among your users, or is already linked to a Firebase User.\r\n     *     The fields <code>error.phoneNumber</code> and\r\n     *     <code>error.credential</code> ({@link firebase.auth.AuthCredential})\r\n     *     are provided in this case. You can recover from this error by signing in\r\n     *     with that credential directly via\r\n     *     {@link firebase.auth.Auth.signInWithCredential}.</dd>\r\n     * <dt>auth/operation-not-allowed</dt>\r\n     * <dd>Thrown if you have not enabled the phone authentication provider in the\r\n     *     Firebase Console. Go to the Firebase Console for your project, in the\r\n     *     Auth section and the <strong>Sign in Method</strong> tab and configure\r\n     *     the provider.</dd>\r\n     * </dl>\r\n     *\r\n     * @param phoneNumber The user's phone number in E.164 format (e.g.\r\n     *     +16505550101).\r\n     * @param applicationVerifier\r\n     */\r\n    linkWithPhoneNumber(\r\n      phoneNumber: string,\r\n      applicationVerifier: firebase.auth.ApplicationVerifier,\r\n    ): Promise<firebase.auth.ConfirmationResult>;\r\n    /**\r\n     * Links the authenticated provider to the user account using a pop-up based\r\n     * OAuth flow.\r\n     *\r\n     * If the linking is successful, the returned result will contain the user\r\n     * and the provider's credential.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/auth-domain-config-required</dt>\r\n     * <dd>Thrown if authDomain configuration is not provided when calling\r\n     *     firebase.initializeApp(). Check Firebase Console for instructions on\r\n     *     determining and passing that field.</dd>\r\n     * <dt>auth/cancelled-popup-request</dt>\r\n     * <dd>Thrown if successive popup operations are triggered. Only one popup\r\n     *     request is allowed at one time on a user or an auth instance. All the\r\n     *     popups would fail with this error except for the last one.</dd>\r\n     * <dt>auth/credential-already-in-use</dt>\r\n     * <dd>Thrown if the account corresponding to the credential already exists\r\n     *     among your users, or is already linked to a Firebase User.\r\n     *     For example, this error could be thrown if you are upgrading an anonymous\r\n     *     user to a Google user by linking a Google credential to it and the Google\r\n     *     credential used is already associated with an existing Firebase Google\r\n     *     user.\r\n     *     An <code>error.email</code> and <code>error.credential</code>\r\n     *     ({@link firebase.auth.AuthCredential}) fields are also provided. You can\r\n     *     recover from this error by signing in with that credential directly via\r\n     *     {@link firebase.auth.Auth.signInWithCredential}.</dd>\r\n     * <dt>auth/email-already-in-use</dt>\r\n     * <dd>Thrown if the email corresponding to the credential already exists\r\n     *     among your users. When thrown while linking a credential to an existing\r\n     *     user, an <code>error.email</code> and <code>error.credential</code>\r\n     *     ({@link firebase.auth.AuthCredential}) fields are also provided.\r\n     *     You have to link the credential to the existing user with that email if\r\n     *     you wish to continue signing in with that credential. To do so, call\r\n     *     {@link firebase.auth.Auth.fetchSignInMethodsForEmail}, sign in to\r\n     *     <code>error.email</code> via one of the providers returned and then\r\n     *     {@link firebase.User.linkWithCredential} the original credential to that\r\n     *     newly signed in user.</dd>\r\n     * <dt>auth/operation-not-allowed</dt>\r\n     * <dd>Thrown if you have not enabled the provider in the Firebase Console. Go\r\n     *     to the Firebase Console for your project, in the Auth section and the\r\n     *     <strong>Sign in Method</strong> tab and configure the provider.</dd>\r\n     * <dt>auth/popup-blocked</dt>\r\n     * <dt>auth/operation-not-supported-in-this-environment</dt>\r\n     * <dd>Thrown if this operation is not supported in the environment your\r\n     *     application is running on. \"location.protocol\" must be http or https.\r\n     *     </dd>\r\n     * <dd>Thrown if the popup was blocked by the browser, typically when this\r\n     *     operation is triggered outside of a click handler.</dd>\r\n     * <dt>auth/popup-closed-by-user</dt>\r\n     * <dd>Thrown if the popup window is closed by the user without completing the\r\n     *     sign in to the provider.</dd>\r\n     * <dt>auth/provider-already-linked</dt>\r\n     * <dd>Thrown if the provider has already been linked to the user. This error is\r\n     *     thrown even if this is not the same provider's account that is currently\r\n     *     linked to the user.</dd>\r\n     * <dt>auth/unauthorized-domain</dt>\r\n     * <dd>Thrown if the app domain is not authorized for OAuth operations for your\r\n     *     Firebase project. Edit the list of authorized domains from the Firebase\r\n     *     console.</dd>\r\n     * </dl>\r\n     *\r\n     * This method does not work in a Node.js environment.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Creates the provider object.\r\n     * var provider = new firebase.auth.FacebookAuthProvider();\r\n     * // You can add additional scopes to the provider:\r\n     * provider.addScope('email');\r\n     * provider.addScope('user_friends');\r\n     * // Link with popup:\r\n     * user.linkWithPopup(provider).then(function(result) {\r\n     *   // The firebase.User instance:\r\n     *   var user = result.user;\r\n     *   // The Facebook firebase.auth.AuthCredential containing the Facebook\r\n     *   // access token:\r\n     *   var credential = result.credential;\r\n     * }, function(error) {\r\n     *   // An error happened.\r\n     * });\r\n     * ```\r\n     *\r\n     * @param provider The provider to authenticate.\r\n     *     The provider has to be an OAuth provider. Non-OAuth providers like {@link\r\n     *     firebase.auth.EmailAuthProvider} will throw an error.\r\n     */\r\n    linkWithPopup(\r\n      provider: firebase.auth.AuthProvider,\r\n    ): Promise<firebase.auth.UserCredential>;\r\n    /**\r\n     * Links the authenticated provider to the user account using a full-page\r\n     * redirect flow.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/auth-domain-config-required</dt>\r\n     * <dd>Thrown if authDomain configuration is not provided when calling\r\n     *     firebase.initializeApp(). Check Firebase Console for instructions on\r\n     *     determining and passing that field.</dd>\r\n     * <dt>auth/operation-not-supported-in-this-environment</dt>\r\n     * <dd>Thrown if this operation is not supported in the environment your\r\n     *     application is running on. \"location.protocol\" must be http or https.\r\n     *     </dd>\r\n     * <dt>auth/provider-already-linked</dt>\r\n     * <dd>Thrown if the provider has already been linked to the user. This error is\r\n     *     thrown even if this is not the same provider's account that is currently\r\n     *     linked to the user.</dd>\r\n     * <dt>auth/unauthorized-domain</dt>\r\n     * <dd>Thrown if the app domain is not authorized for OAuth operations for your\r\n     *     Firebase project. Edit the list of authorized domains from the Firebase\r\n     *     console.</dd>\r\n     * </dl>\r\n     *\r\n     * @param provider The provider to authenticate.\r\n     *     The provider has to be an OAuth provider. Non-OAuth providers like {@link\r\n     *     firebase.auth.EmailAuthProvider} will throw an error.\r\n     */\r\n    linkWithRedirect(provider: firebase.auth.AuthProvider): Promise<void>;\r\n    metadata: firebase.auth.UserMetadata;\r\n    /**\r\n     * The {@link firebase.User.MultiFactorUser} object corresponding to the current user.\r\n     * This is used to access all multi-factor properties and operations related to the\r\n     * current user.\r\n     */\r\n\r\n    multiFactor: firebase.User.MultiFactorUser;\r\n    /**\r\n     * The phone number normalized based on the E.164 standard (e.g. +16505550101)\r\n     * for the current user. This is null if the user has no phone credential linked\r\n     * to the account.\r\n     */\r\n    phoneNumber: string | null;\r\n    providerData: (firebase.UserInfo | null)[];\r\n    /**\r\n     * Re-authenticates a user using a fresh credential, and returns any available\r\n     * additional user information, such as user name. Use before operations\r\n     * such as {@link firebase.User.updatePassword} that require tokens from recent\r\n     * sign-in attempts.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/user-mismatch</dt>\r\n     * <dd>Thrown if the credential given does not correspond to the user.</dd>\r\n     * <dt>auth/user-not-found</dt>\r\n     * <dd>Thrown if the credential given does not correspond to any existing user.\r\n     *     </dd>\r\n     * <dt>auth/invalid-credential</dt>\r\n     * <dd>Thrown if the provider's credential is not valid. This can happen if it\r\n     *     has already expired when calling link, or if it used invalid token(s).\r\n     *     See the Firebase documentation for your provider, and make sure you pass\r\n     *     in the correct parameters to the credential method.</dd>\r\n     * <dt>auth/invalid-email</dt>\r\n     * <dd>Thrown if the email used in a\r\n     *     {@link firebase.auth.EmailAuthProvider.credential} is invalid.</dd>\r\n     * <dt>auth/wrong-password</dt>\r\n     * <dd>Thrown if the password used in a\r\n     *     {@link firebase.auth.EmailAuthProvider.credential} is not correct or when\r\n     *     the user associated with the email does not have a password.</dd>\r\n     * <dt>auth/invalid-verification-code</dt>\r\n     * <dd>Thrown if the credential is a\r\n     *     {@link firebase.auth.PhoneAuthProvider.credential} and the verification\r\n     *     code of the credential is not valid.</dd>\r\n     * <dt>auth/invalid-verification-id</dt>\r\n     * <dd>Thrown if the credential is a\r\n     *     {@link firebase.auth.PhoneAuthProvider.credential}  and the verification\r\n     *     ID of the credential is not valid.</dd>\r\n     * </dl>\r\n     *\r\n     * @deprecated\r\n     * This method is deprecated. Use\r\n     * {@link firebase.User.reauthenticateWithCredential} instead.\r\n     *\r\n     * @param credential\r\n     */\r\n    reauthenticateAndRetrieveDataWithCredential(\r\n      credential: firebase.auth.AuthCredential,\r\n    ): Promise<firebase.auth.UserCredential>;\r\n    /**\r\n     * Re-authenticates a user using a fresh credential. Use before operations\r\n     * such as {@link firebase.User.updatePassword} that require tokens from recent\r\n     * sign-in attempts.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/user-mismatch</dt>\r\n     * <dd>Thrown if the credential given does not correspond to the user.</dd>\r\n     * <dt>auth/user-not-found</dt>\r\n     * <dd>Thrown if the credential given does not correspond to any existing user.\r\n     *     </dd>\r\n     * <dt>auth/invalid-credential</dt>\r\n     * <dd>Thrown if the provider's credential is not valid. This can happen if it\r\n     *     has already expired when calling link, or if it used invalid token(s).\r\n     *     See the Firebase documentation for your provider, and make sure you pass\r\n     *     in the correct parameters to the credential method.</dd>\r\n     * <dt>auth/invalid-email</dt>\r\n     * <dd>Thrown if the email used in a\r\n     *     {@link firebase.auth.EmailAuthProvider.credential} is invalid.</dd>\r\n     * <dt>auth/wrong-password</dt>\r\n     * <dd>Thrown if the password used in a\r\n     *     {@link firebase.auth.EmailAuthProvider.credential} is not correct or when\r\n     *     the user associated with the email does not have a password.</dd>\r\n     * <dt>auth/invalid-verification-code</dt>\r\n     * <dd>Thrown if the credential is a\r\n     *     {@link firebase.auth.PhoneAuthProvider.credential} and the verification\r\n     *     code of the credential is not valid.</dd>\r\n     * <dt>auth/invalid-verification-id</dt>\r\n     * <dd>Thrown if the credential is a\r\n     *     {@link firebase.auth.PhoneAuthProvider.credential}  and the verification\r\n     *     ID of the credential is not valid.</dd>\r\n     * </dl>\r\n     *\r\n     * @param credential\r\n     */\r\n    reauthenticateWithCredential(\r\n      credential: firebase.auth.AuthCredential,\r\n    ): Promise<firebase.auth.UserCredential>;\r\n    /**\r\n     * Re-authenticates a user using a fresh credential. Use before operations\r\n     * such as {@link firebase.User.updatePassword} that require tokens from recent\r\n     * sign-in attempts.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/user-mismatch</dt>\r\n     * <dd>Thrown if the credential given does not correspond to the user.</dd>\r\n     * <dt>auth/user-not-found</dt>\r\n     * <dd>Thrown if the credential given does not correspond to any existing user.\r\n     *     </dd>\r\n     * <dt>auth/captcha-check-failed</dt>\r\n     * <dd>Thrown if the reCAPTCHA response token was invalid, expired, or if\r\n     *     this method was called from a non-whitelisted domain.</dd>\r\n     * <dt>auth/invalid-phone-number</dt>\r\n     * <dd>Thrown if the phone number has an invalid format.</dd>\r\n     * <dt>auth/missing-phone-number</dt>\r\n     * <dd>Thrown if the phone number is missing.</dd>\r\n     * <dt>auth/quota-exceeded</dt>\r\n     * <dd>Thrown if the SMS quota for the Firebase project has been exceeded.</dd>\r\n     * </dl>\r\n     *\r\n     * @param phoneNumber The user's phone number in E.164 format (e.g.\r\n     *     +16505550101).\r\n     * @param applicationVerifier\r\n     */\r\n    reauthenticateWithPhoneNumber(\r\n      phoneNumber: string,\r\n      applicationVerifier: firebase.auth.ApplicationVerifier,\r\n    ): Promise<firebase.auth.ConfirmationResult>;\r\n    /**\r\n     * Reauthenticates the current user with the specified provider using a pop-up\r\n     * based OAuth flow.\r\n     *\r\n     * If the reauthentication is successful, the returned result will contain the\r\n     * user and the provider's credential.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/auth-domain-config-required</dt>\r\n     * <dd>Thrown if authDomain configuration is not provided when calling\r\n     *     firebase.initializeApp(). Check Firebase Console for instructions on\r\n     *     determining and passing that field.</dd>\r\n     * <dt>auth/cancelled-popup-request</dt>\r\n     * <dd>Thrown if successive popup operations are triggered. Only one popup\r\n     *     request is allowed at one time on a user or an auth instance. All the\r\n     *     popups would fail with this error except for the last one.</dd>\r\n     * <dt>auth/user-mismatch</dt>\r\n     * <dd>Thrown if the credential given does not correspond to the user.</dd>\r\n     * <dt>auth/operation-not-allowed</dt>\r\n     * <dd>Thrown if you have not enabled the provider in the Firebase Console. Go\r\n     *     to the Firebase Console for your project, in the Auth section and the\r\n     *     <strong>Sign in Method</strong> tab and configure the provider.</dd>\r\n     * <dt>auth/popup-blocked</dt>\r\n     * <dd>Thrown if the popup was blocked by the browser, typically when this\r\n     *     operation is triggered outside of a click handler.</dd>\r\n     * <dt>auth/operation-not-supported-in-this-environment</dt>\r\n     * <dd>Thrown if this operation is not supported in the environment your\r\n     *     application is running on. \"location.protocol\" must be http or https.\r\n     *     </dd>\r\n     * <dt>auth/popup-closed-by-user</dt>\r\n     * <dd>Thrown if the popup window is closed by the user without completing the\r\n     *     sign in to the provider.</dd>\r\n     * <dt>auth/unauthorized-domain</dt>\r\n     * <dd>Thrown if the app domain is not authorized for OAuth operations for your\r\n     *     Firebase project. Edit the list of authorized domains from the Firebase\r\n     *     console.</dd>\r\n     * </dl>\r\n     *\r\n     * This method does not work in a Node.js environment.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Creates the provider object.\r\n     * var provider = new firebase.auth.FacebookAuthProvider();\r\n     * // You can add additional scopes to the provider:\r\n     * provider.addScope('email');\r\n     * provider.addScope('user_friends');\r\n     * // Reauthenticate with popup:\r\n     * user.reauthenticateWithPopup(provider).then(function(result) {\r\n     *   // The firebase.User instance:\r\n     *   var user = result.user;\r\n     *   // The Facebook firebase.auth.AuthCredential containing the Facebook\r\n     *   // access token:\r\n     *   var credential = result.credential;\r\n     * }, function(error) {\r\n     *   // An error happened.\r\n     * });\r\n     * ```\r\n     *\r\n     * @param provider The provider to authenticate.\r\n     *     The provider has to be an OAuth provider. Non-OAuth providers like {@link\r\n     *     firebase.auth.EmailAuthProvider} will throw an error.\r\n     */\r\n    reauthenticateWithPopup(\r\n      provider: firebase.auth.AuthProvider,\r\n    ): Promise<firebase.auth.UserCredential>;\r\n    /**\r\n     * Reauthenticates the current user with the specified OAuth provider using a\r\n     * full-page redirect flow.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/auth-domain-config-required</dt>\r\n     * <dd>Thrown if authDomain configuration is not provided when calling\r\n     *     firebase.initializeApp(). Check Firebase Console for instructions on\r\n     *     determining and passing that field.</dd>\r\n     * <dt>auth/operation-not-supported-in-this-environment</dt>\r\n     * <dd>Thrown if this operation is not supported in the environment your\r\n     *     application is running on. \"location.protocol\" must be http or https.\r\n     *     </dd>\r\n     * <dt>auth/user-mismatch</dt>\r\n     * <dd>Thrown if the credential given does not correspond to the user.</dd>\r\n     * <dt>auth/unauthorized-domain</dt>\r\n     * <dd>Thrown if the app domain is not authorized for OAuth operations for your\r\n     *     Firebase project. Edit the list of authorized domains from the Firebase\r\n     *     console.</dd>\r\n     * </dl>\r\n     *\r\n     * This method does not work in a Node.js environment.\r\n     *\r\n     * @param provider The provider to authenticate.\r\n     *     The provider has to be an OAuth provider. Non-OAuth providers like {@link\r\n     *     firebase.auth.EmailAuthProvider} will throw an error.\r\n     */\r\n    reauthenticateWithRedirect(\r\n      provider: firebase.auth.AuthProvider,\r\n    ): Promise<void>;\r\n    refreshToken: string;\r\n    /**\r\n     * Refreshes the current user, if signed in.\r\n     *\r\n     */\r\n    reload(): Promise<void>;\r\n    /**\r\n     * Sends a verification email to a user.\r\n     *\r\n     * The verification process is completed by calling\r\n     * {@link firebase.auth.Auth.applyActionCode}\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/missing-android-pkg-name</dt>\r\n     * <dd>An Android package name must be provided if the Android app is required\r\n     *     to be installed.</dd>\r\n     * <dt>auth/missing-continue-uri</dt>\r\n     * <dd>A continue URL must be provided in the request.</dd>\r\n     * <dt>auth/missing-ios-bundle-id</dt>\r\n     * <dd>An iOS bundle ID must be provided if an App Store ID is provided.</dd>\r\n     * <dt>auth/invalid-continue-uri</dt>\r\n     * <dd>The continue URL provided in the request is invalid.</dd>\r\n     * <dt>auth/unauthorized-continue-uri</dt>\r\n     * <dd>The domain of the continue URL is not whitelisted. Whitelist\r\n     *     the domain in the Firebase console.</dd>\r\n     * </dl>\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var actionCodeSettings = {\r\n     *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',\r\n     *   iOS: {\r\n     *     bundleId: 'com.example.ios'\r\n     *   },\r\n     *   android: {\r\n     *     packageName: 'com.example.android',\r\n     *     installApp: true,\r\n     *     minimumVersion: '12'\r\n     *   },\r\n     *   handleCodeInApp: true\r\n     * };\r\n     * firebase.auth().currentUser.sendEmailVerification(actionCodeSettings)\r\n     *     .then(function() {\r\n     *       // Verification email sent.\r\n     *     })\r\n     *     .catch(function(error) {\r\n     *       // Error occurred. Inspect error.code.\r\n     *     });\r\n     * ```\r\n     *\r\n     * @param actionCodeSettings The action\r\n     *     code settings. If specified, the state/continue URL will be set as the\r\n     *     \"continueUrl\" parameter in the email verification link. The default email\r\n     *     verification landing page will use this to display a link to go back to\r\n     *     the app if it is installed.\r\n     *     If the actionCodeSettings is not specified, no URL is appended to the\r\n     *     action URL.\r\n     *     The state URL provided must belong to a domain that is whitelisted by the\r\n     *     developer in the console. Otherwise an error will be thrown.\r\n     *     Mobile app redirects will only be applicable if the developer configures\r\n     *     and accepts the Firebase Dynamic Links terms of condition.\r\n     *     The Android package name and iOS bundle ID will be respected only if they\r\n     *     are configured in the same Firebase Auth project used.\r\n     */\r\n    sendEmailVerification(\r\n      actionCodeSettings?: firebase.auth.ActionCodeSettings | null,\r\n    ): Promise<void>;\r\n    /**\r\n     * The current user's tenant ID. This is a read-only property, which indicates\r\n     * the tenant ID used to sign in the current user. This is null if the user is\r\n     * signed in from the parent project.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Set the tenant ID on Auth instance.\r\n     * firebase.auth().tenantId = ‘TENANT_PROJECT_ID’;\r\n     *\r\n     * // All future sign-in request now include tenant ID.\r\n     * firebase.auth().signInWithEmailAndPassword(email, password)\r\n     *   .then(function(result) {\r\n     *     // result.user.tenantId should be ‘TENANT_PROJECT_ID’.\r\n     *   }).catch(function(error) {\r\n     *     // Handle error.\r\n     *   });\r\n     * ```\r\n     */\r\n    tenantId: string | null;\r\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     *\r\n     * @return A JSON-serializable representation of this object.\r\n     */\r\n    toJSON(): Object;\r\n    /**\r\n     * Unlinks a provider from a user account.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/no-such-provider</dt>\r\n     * <dd>Thrown if the user does not have this provider linked or when the\r\n     *     provider ID given does not exist.</dd>\r\n     * </dt>\r\n     *\r\n     * @param providerId\r\n     */\r\n    unlink(providerId: string): Promise<firebase.User>;\r\n    /**\r\n     * Updates the user's email address.\r\n     *\r\n     * An email will be sent to the original email address (if it was set) that\r\n     * allows to revoke the email address change, in order to protect them from\r\n     * account hijacking.\r\n     *\r\n     * <b>Important:</b> this is a security sensitive operation that requires the\r\n     * user to have recently signed in. If this requirement isn't met, ask the user\r\n     * to authenticate again and then call\r\n     * {@link firebase.User.reauthenticateWithCredential}.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/invalid-email</dt>\r\n     * <dd>Thrown if the email used is invalid.</dd>\r\n     * <dt>auth/email-already-in-use</dt>\r\n     * <dd>Thrown if the email is already used by another user.</dd>\r\n     * <dt>auth/requires-recent-login</dt>\r\n     * <dd>Thrown if the user's last sign-in time does not meet the security\r\n     *     threshold. Use {@link firebase.User.reauthenticateWithCredential} to\r\n     *     resolve. This does not apply if the user is anonymous.</dd>\r\n     * </dl>\r\n     *\r\n     * @param newEmail The new email address.\r\n     */\r\n    updateEmail(newEmail: string): Promise<void>;\r\n    /**\r\n     * Updates the user's password.\r\n     *\r\n     * <b>Important:</b> this is a security sensitive operation that requires the\r\n     * user to have recently signed in. If this requirement isn't met, ask the user\r\n     * to authenticate again and then call\r\n     * {@link firebase.User.reauthenticateWithCredential}.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/weak-password</dt>\r\n     * <dd>Thrown if the password is not strong enough.</dd>\r\n     * <dt>auth/requires-recent-login</dt>\r\n     * <dd>Thrown if the user's last sign-in time does not meet the security\r\n     *     threshold. Use {@link firebase.User.reauthenticateWithCredential} to\r\n     *     resolve. This does not apply if the user is anonymous.</dd>\r\n     * </dl>\r\n     *\r\n     * @param newPassword\r\n     */\r\n    updatePassword(newPassword: string): Promise<void>;\r\n    /**\r\n     * Updates the user's phone number.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/invalid-verification-code</dt>\r\n     * <dd>Thrown if the verification code of the credential is not valid.</dd>\r\n     * <dt>auth/invalid-verification-id</dt>\r\n     * <dd>Thrown if the verification ID of the credential is not valid.</dd>\r\n     * </dl>\r\n     *\r\n     * @param phoneCredential\r\n     */\r\n    updatePhoneNumber(\r\n      phoneCredential: firebase.auth.AuthCredential,\r\n    ): Promise<void>;\r\n    /**\r\n     * Updates a user's profile data.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Updates the user attributes:\r\n     * user.updateProfile({\r\n     *   displayName: \"Jane Q. User\",\r\n     *   photoURL: \"https://example.com/jane-q-user/profile.jpg\"\r\n     * }).then(function() {\r\n     *   // Profile updated successfully!\r\n     *   // \"Jane Q. User\"\r\n     *   var displayName = user.displayName;\r\n     *   // \"https://example.com/jane-q-user/profile.jpg\"\r\n     *   var photoURL = user.photoURL;\r\n     * }, function(error) {\r\n     *   // An error happened.\r\n     * });\r\n     *\r\n     * // Passing a null value will delete the current attribute's value, but not\r\n     * // passing a property won't change the current attribute's value:\r\n     * // Let's say we're using the same user than before, after the update.\r\n     * user.updateProfile({photoURL: null}).then(function() {\r\n     *   // Profile updated successfully!\r\n     *   // \"Jane Q. User\", hasn't changed.\r\n     *   var displayName = user.displayName;\r\n     *   // Now, this is null.\r\n     *   var photoURL = user.photoURL;\r\n     * }, function(error) {\r\n     *   // An error happened.\r\n     * });\r\n     * ```\r\n     *\r\n     * @param profile The profile's\r\n     *     displayName and photoURL to update.\r\n     */\r\n    updateProfile(profile: {\r\n      displayName?: string | null;\r\n      photoURL?: string | null;\r\n    }): Promise<void>;\r\n    /**\r\n     * Sends a verification email to a new email address. The user's email will be\r\n     * updated to the new one after being verified.\r\n     *\r\n     * If you have a custom email action handler, you can complete the verification\r\n     * process by calling {@link firebase.auth.Auth.applyActionCode}.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/missing-android-pkg-name</dt>\r\n     * <dd>An Android package name must be provided if the Android app is required\r\n     *     to be installed.</dd>\r\n     * <dt>auth/missing-continue-uri</dt>\r\n     * <dd>A continue URL must be provided in the request.</dd>\r\n     * <dt>auth/missing-ios-bundle-id</dt>\r\n     * <dd>An iOS bundle ID must be provided if an App Store ID is provided.</dd>\r\n     * <dt>auth/invalid-continue-uri</dt>\r\n     * <dd>The continue URL provided in the request is invalid.</dd>\r\n     * <dt>auth/unauthorized-continue-uri</dt>\r\n     * <dd>The domain of the continue URL is not whitelisted. Whitelist\r\n     *     the domain in the Firebase console.</dd>\r\n     * </dl>\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var actionCodeSettings = {\r\n     *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',\r\n     *   iOS: {\r\n     *     bundleId: 'com.example.ios'\r\n     *   },\r\n     *   android: {\r\n     *     packageName: 'com.example.android',\r\n     *     installApp: true,\r\n     *     minimumVersion: '12'\r\n     *   },\r\n     *   handleCodeInApp: true\r\n     * };\r\n     * firebase.auth().currentUser.verifyBeforeUpdateEmail(\r\n     *   'user@example.com', actionCodeSettings)\r\n     *   .then(function() {\r\n     *     // Verification email sent.\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     // Error occurred. Inspect error.code.\r\n     *   });\r\n     * ```\r\n     *\r\n     * @param newEmail The email address to be verified and updated to.\r\n     * @param actionCodeSettings The action\r\n     *     code settings. If specified, the state/continue URL will be set as the\r\n     *     \"continueUrl\" parameter in the email verification link. The default email\r\n     *     verification landing page will use this to display a link to go back to\r\n     *     the app if it is installed.\r\n     *     If the actionCodeSettings is not specified, no URL is appended to the\r\n     *     action URL.\r\n     *     The state URL provided must belong to a domain that is whitelisted by the\r\n     *     developer in the console. Otherwise an error will be thrown.\r\n     *     Mobile app redirects will only be applicable if the developer configures\r\n     *     and accepts the Firebase Dynamic Links terms of condition.\r\n     *     The Android package name and iOS bundle ID will be respected only if they\r\n     *     are configured in the same Firebase Auth project used.\r\n     */\r\n    verifyBeforeUpdateEmail(\r\n      newEmail: string,\r\n      actionCodeSettings?: firebase.auth.ActionCodeSettings | null,\r\n    ): Promise<void>;\r\n  }\r\n\r\n  /**\r\n   * User profile information, visible only to the Firebase project's\r\n   * apps.\r\n   *\r\n   */\r\n  interface UserInfo {\r\n    displayName: string | null;\r\n    email: string | null;\r\n    phoneNumber: string | null;\r\n    photoURL: string | null;\r\n    providerId: string;\r\n    /**\r\n     * The user's unique ID.\r\n     */\r\n    uid: string;\r\n  }\r\n\r\n  type FirebaseSignInProvider =\r\n    | \"custom\"\r\n    | \"email\"\r\n    | \"password\"\r\n    | \"phone\"\r\n    | \"anonymous\"\r\n    | \"google.com\"\r\n    | \"facebook.com\"\r\n    | \"github.com\"\r\n    | \"twitter.com\"\r\n    | \"microsoft.com\"\r\n    | \"apple.com\";\r\n\r\n  interface FirebaseIdToken {\r\n    /** Always set to https://securetoken.google.com/PROJECT_ID */\r\n    iss: string;\r\n\r\n    /** Always set to PROJECT_ID */\r\n    aud: string;\r\n\r\n    /** The user's unique ID */\r\n    sub: string;\r\n\r\n    /** The token issue time, in seconds since epoch */\r\n    iat: number;\r\n\r\n    /** The token expiry time, normally 'iat' + 3600 */\r\n    exp: number;\r\n\r\n    /** The user's unique ID. Must be equal to 'sub' */\r\n    user_id: string;\r\n\r\n    /** The time the user authenticated, normally 'iat' */\r\n    auth_time: number;\r\n\r\n    /** The sign in provider, only set when the provider is 'anonymous' */\r\n    provider_id?: \"anonymous\";\r\n\r\n    /** The user's primary email */\r\n    email?: string;\r\n\r\n    /** The user's email verification status */\r\n    email_verified?: boolean;\r\n\r\n    /** The user's primary phone number */\r\n    phone_number?: string;\r\n\r\n    /** The user's display name */\r\n    name?: string;\r\n\r\n    /** The user's profile photo URL */\r\n    picture?: string;\r\n\r\n    /** Information on all identities linked to this user */\r\n    firebase: {\r\n      /** The primary sign-in provider */\r\n      sign_in_provider: FirebaseSignInProvider;\r\n\r\n      /** A map of providers to the user's list of unique identifiers from each provider */\r\n      identities?: { [provider in FirebaseSignInProvider]?: string[] };\r\n    };\r\n\r\n    /** Custom claims set by the developer */\r\n    [claim: string]: unknown;\r\n\r\n    // NO LONGER SUPPORTED. Use \"sub\" instead. (Not a jsdoc comment to avoid generating docs.)\r\n    uid?: never;\r\n  }\r\n\r\n  export type EmulatorMockTokenOptions = (\r\n    | { user_id: string }\r\n    | { sub: string }\r\n  ) &\r\n    Partial<FirebaseIdToken>;\r\n\r\n  /**\r\n   * Retrieves a Firebase {@link firebase.app.App app} instance.\r\n   *\r\n   * When called with no arguments, the default app is returned. When an app name\r\n   * is provided, the app corresponding to that name is returned.\r\n   *\r\n   * An exception is thrown if the app being retrieved has not yet been\r\n   * initialized.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Return the default app\r\n   * var app = firebase.app();\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Return a named app\r\n   * var otherApp = firebase.app(\"otherApp\");\r\n   * ```\r\n   *\r\n   * @param name Optional name of the app to return. If no name is\r\n   *   provided, the default is `\"[DEFAULT]\"`.\r\n   *\r\n   * @return The app corresponding to the provided app name.\r\n   *   If no app name is provided, the default app is returned.\r\n   */\r\n  function app(name?: string): firebase.app.App;\r\n\r\n  /**\r\n   * A (read-only) array of all initialized apps.\r\n   */\r\n  var apps: firebase.app.App[];\r\n\r\n  /**\r\n   * Gets the {@link firebase.auth.Auth `Auth`} service for the default app or a\r\n   * given app.\r\n   *\r\n   * `firebase.auth()` can be called with no arguments to access the default app's\r\n   * {@link firebase.auth.Auth `Auth`} service or as `firebase.auth(app)` to\r\n   * access the {@link firebase.auth.Auth `Auth`} service associated with a\r\n   * specific app.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   *\r\n   * // Get the Auth service for the default app\r\n   * var defaultAuth = firebase.auth();\r\n   * ```\r\n   * @example\r\n   * ```javascript\r\n   *\r\n   * // Get the Auth service for a given app\r\n   * var otherAuth = firebase.auth(otherApp);\r\n   * ```\r\n   * @param app\r\n   */\r\n  function auth(app?: firebase.app.App): firebase.auth.Auth;\r\n\r\n  /**\r\n   * Gets the {@link firebase.database.Database `Database`} service for the\r\n   * default app or a given app.\r\n   *\r\n   * `firebase.database()` can be called with no arguments to access the default\r\n   * app's {@link firebase.database.Database `Database`} service or as\r\n   * `firebase.database(app)` to access the\r\n   * {@link firebase.database.Database `Database`} service associated with a\r\n   * specific app.\r\n   *\r\n   * `firebase.database` is also a namespace that can be used to access global\r\n   * constants and methods associated with the `Database` service.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Get the Database service for the default app\r\n   * var defaultDatabase = firebase.database();\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Get the Database service for a specific app\r\n   * var otherDatabase = firebase.database(app);\r\n   * ```\r\n   *\r\n   * @namespace\r\n   * @param app Optional app whose Database service to\r\n   *   return. If not provided, the default Database service will be returned.\r\n   * @return The default Database service if no app\r\n   *   is provided or the Database service associated with the provided app.\r\n   */\r\n  function database(app?: firebase.app.App): firebase.database.Database;\r\n\r\n  /**\r\n   * Creates and initializes a Firebase {@link firebase.app.App app} instance.\r\n   *\r\n   * See\r\n   * {@link\r\n   *   https://firebase.google.com/docs/web/setup#add_firebase_to_your_app\r\n   *   Add Firebase to your app} and\r\n   * {@link\r\n   *   https://firebase.google.com/docs/web/learn-more#multiple-projects\r\n   *   Initialize multiple projects} for detailed documentation.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   *\r\n   * // Initialize default app\r\n   * // Retrieve your own options values by adding a web app on\r\n   * // https://console.firebase.google.com\r\n   * firebase.initializeApp({\r\n   *   apiKey: \"AIza....\",                             // Auth / General Use\r\n   *   appId: \"1:27992087142:web:ce....\",              // General Use\r\n   *   projectId: \"my-firebase-project\",               // General Use\r\n   *   authDomain: \"YOUR_APP.firebaseapp.com\",         // Auth with popup/redirect\r\n   *   databaseURL: \"https://YOUR_APP.firebaseio.com\", // Realtime Database\r\n   *   storageBucket: \"YOUR_APP.appspot.com\",          // Storage\r\n   *   messagingSenderId: \"123456789\",                 // Cloud Messaging\r\n   *   measurementId: \"G-12345\"                        // Analytics\r\n   * });\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   *\r\n   * // Initialize another app\r\n   * var otherApp = firebase.initializeApp({\r\n   *   apiKey: \"AIza....\",\r\n   *   appId: \"1:27992087142:web:ce....\",\r\n   *   projectId: \"my-firebase-project\",\r\n   *   databaseURL: \"https://<OTHER_DATABASE_NAME>.firebaseio.com\",\r\n   *   storageBucket: \"<OTHER_STORAGE_BUCKET>.appspot.com\"\r\n   * }, \"nameOfOtherApp\");\r\n   * ```\r\n   *\r\n   * @param options Options to configure the app's services.\r\n   * @param name Optional name of the app to initialize. If no name\r\n   *   is provided, the default is `\"[DEFAULT]\"`.\r\n   *\r\n   * @return {!firebase.app.App} The initialized app.\r\n   */\r\n  function initializeApp(options: Object, name?: string): firebase.app.App;\r\n\r\n  /**\r\n   * Gets the {@link firebase.messaging.Messaging `Messaging`} service for the\r\n   * default app or a given app.\r\n   *\r\n   * `firebase.messaging()` can be called with no arguments to access the default\r\n   * app's {@link firebase.messaging.Messaging `Messaging`} service or as\r\n   * `firebase.messaging(app)` to access the\r\n   * {@link firebase.messaging.Messaging `Messaging`} service associated with a\r\n   * specific app.\r\n   *\r\n   * Calling `firebase.messaging()` in a service worker results in Firebase\r\n   * generating notifications if the push message payload has a `notification`\r\n   * parameter.\r\n   *\r\n   * The Messaging SDK does not work in a Node.js environment.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Get the Messaging service for the default app\r\n   * var defaultMessaging = firebase.messaging();\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Get the Messaging service for a given app\r\n   * var otherMessaging = firebase.messaging(otherApp);\r\n   * ```\r\n   *\r\n   * @namespace\r\n   * @param app The app to create a Messaging service for.\r\n   *     If not passed, uses the default app.\r\n   */\r\n  function messaging(app?: firebase.app.App): firebase.messaging.Messaging;\r\n\r\n  /**\r\n   * Gets the {@link firebase.storage.Storage `Storage`} service for the default\r\n   * app or a given app.\r\n   *\r\n   * `firebase.storage()` can be called with no arguments to access the default\r\n   * app's {@link firebase.storage.Storage `Storage`} service or as\r\n   * `firebase.storage(app)` to access the\r\n   * {@link firebase.storage.Storage `Storage`} service associated with a\r\n   * specific app.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Get the Storage service for the default app\r\n   * var defaultStorage = firebase.storage();\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Get the Storage service for a given app\r\n   * var otherStorage = firebase.storage(otherApp);\r\n   * ```\r\n   *\r\n   * @param app The app to create a storage service for.\r\n   *     If not passed, uses the default app.\r\n   */\r\n  function storage(app?: firebase.app.App): firebase.storage.Storage;\r\n\r\n  function firestore(app?: firebase.app.App): firebase.firestore.Firestore;\r\n\r\n  function functions(app?: firebase.app.App): firebase.functions.Functions;\r\n\r\n  /**\r\n   * Gets the {@link firebase.performance.Performance `Performance`} service.\r\n   *\r\n   * `firebase.performance()` can be called with no arguments to access the default\r\n   * app's {@link firebase.performance.Performance `Performance`} service.\r\n   * The {@link firebase.performance.Performance `Performance`} service does not work with\r\n   * any other app.\r\n   *\r\n   * The Performance SDK does not work in a Node.js environment.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Get the Performance service for the default app\r\n   * const defaultPerformance = firebase.performance();\r\n   * ```\r\n   *\r\n   * @param app The app to create a performance service for. Performance Monitoring only works with\r\n   * the default app.\r\n   * If not passed, uses the default app.\r\n   */\r\n  function performance(\r\n    app?: firebase.app.App,\r\n  ): firebase.performance.Performance;\r\n\r\n  /**\r\n   * Gets the {@link firebase.remoteConfig.RemoteConfig `RemoteConfig`} instance.\r\n   *\r\n   * The Remote Config SDK does not work in a Node.js environment.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Get the RemoteConfig instance for the default app\r\n   * const defaultRemoteConfig = firebase.remoteConfig();\r\n   * ```\r\n   *\r\n   * @param app The app to create a Remote Config service for. If not passed, uses the default app.\r\n   */\r\n  function remoteConfig(\r\n    app?: firebase.app.App,\r\n  ): firebase.remoteConfig.RemoteConfig;\r\n\r\n  /**\r\n   * Gets the {@link firebase.analytics.Analytics `Analytics`} service.\r\n   *\r\n   * `firebase.analytics()` can be called with no arguments to access the default\r\n   * app's {@link firebase.analytics.Analytics `Analytics`} service.\r\n   *\r\n   * The Analytics SDK does not work in a Node.js environment.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Get the Analytics service for the default app\r\n   * const defaultAnalytics = firebase.analytics();\r\n   * ```\r\n   *\r\n   * @param app The app to create an analytics service for.\r\n   * If not passed, uses the default app.\r\n   */\r\n  function analytics(app?: firebase.app.App): firebase.analytics.Analytics;\r\n\r\n  function appCheck(app?: firebase.app.App): firebase.appCheck.AppCheck;\r\n}\r\n\r\ndeclare namespace firebase.app {\r\n  /**\r\n   * A Firebase App holds the initialization information for a collection of\r\n   * services.\r\n   *\r\n   * Do not call this constructor directly. Instead, use\r\n   * {@link firebase.initializeApp|`firebase.initializeApp()`} to create an app.\r\n   *\r\n   */\r\n  interface App {\r\n    /**\r\n     * Gets the {@link firebase.auth.Auth `Auth`} service for the current app.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var auth = app.auth();\r\n     * // The above is shorthand for:\r\n     * // var auth = firebase.auth(app);\r\n     * ```\r\n     */\r\n    auth(): firebase.auth.Auth;\r\n    /**\r\n     * Gets the {@link firebase.database.Database `Database`} service for the\r\n     * current app.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var database = app.database();\r\n     * // The above is shorthand for:\r\n     * // var database = firebase.database(app);\r\n     * ```\r\n     */\r\n    database(url?: string): firebase.database.Database;\r\n    /**\r\n     * Renders this app unusable and frees the resources of all associated\r\n     * services.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * app.delete()\r\n     *   .then(function() {\r\n     *     console.log(\"App deleted successfully\");\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.log(\"Error deleting app:\", error);\r\n     *   });\r\n     * ```\r\n     */\r\n    delete(): Promise<any>;\r\n    /**\r\n     * Gets the {@link firebase.installations.Installations `Installations`} service for the\r\n     * current app.\r\n     *\r\n     * The Installations SDK does not work in a Node.js environment.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const installations = app.installations();\r\n     * // The above is shorthand for:\r\n     * // const installations = firebase.installations(app);\r\n     * ```\r\n     */\r\n    installations(): firebase.installations.Installations;\r\n    /**\r\n     * Gets the {@link firebase.messaging.Messaging `Messaging`} service for the\r\n     * current app.\r\n     *\r\n     * The Messaging SDK does not work in a Node.js environment.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var messaging = app.messaging();\r\n     * // The above is shorthand for:\r\n     * // var messaging = firebase.messaging(app);\r\n     * ```\r\n     */\r\n    messaging(): firebase.messaging.Messaging;\r\n    /**\r\n     * The (read-only) name for this app.\r\n     *\r\n     * The default app's name is `\"[DEFAULT]\"`.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // The default app's name is \"[DEFAULT]\"\r\n     * firebase.initializeApp(defaultAppConfig);\r\n     * console.log(firebase.app().name);  // \"[DEFAULT]\"\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // A named app's name is what you provide to initializeApp()\r\n     * var otherApp = firebase.initializeApp(otherAppConfig, \"other\");\r\n     * console.log(otherApp.name);  // \"other\"\r\n     * ```\r\n     */\r\n    name: string;\r\n    /**\r\n     * The settable config flag for GDPR opt-in/opt-out\r\n     */\r\n    automaticDataCollectionEnabled: boolean;\r\n    /**\r\n     * The (read-only) configuration options for this app. These are the original\r\n     * parameters given in\r\n     * {@link firebase.initializeApp `firebase.initializeApp()`}.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var app = firebase.initializeApp(config);\r\n     * console.log(app.options.databaseURL === config.databaseURL);  // true\r\n     * ```\r\n     */\r\n    options: Object;\r\n    /**\r\n     * Gets the {@link firebase.storage.Storage `Storage`} service for the current\r\n     * app, optionally initialized with a custom storage bucket.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var storage = app.storage();\r\n     * // The above is shorthand for:\r\n     * // var storage = firebase.storage(app);\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var storage = app.storage(\"gs://your-app.appspot.com\");\r\n     * ```\r\n     *\r\n     * @param url The gs:// url to your Firebase Storage Bucket.\r\n     *     If not passed, uses the app's default Storage Bucket.\r\n     */\r\n    storage(url?: string): firebase.storage.Storage;\r\n    firestore(): firebase.firestore.Firestore;\r\n    functions(regionOrCustomDomain?: string): firebase.functions.Functions;\r\n    /**\r\n     * Gets the {@link firebase.performance.Performance `Performance`} service for the\r\n     * current app. If the current app is not the default one, throws an error.\r\n     *\r\n     * The Performance SDK does not work in a Node.js environment.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const perf = app.performance();\r\n     * // The above is shorthand for:\r\n     * // const perf = firebase.performance(app);\r\n     * ```\r\n     */\r\n    performance(): firebase.performance.Performance;\r\n    /**\r\n     * Gets the {@link firebase.remoteConfig.RemoteConfig `RemoteConfig`} instance.\r\n     *\r\n     * The Remote Config SDK does not work in a Node.js environment.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const rc = app.remoteConfig();\r\n     * // The above is shorthand for:\r\n     * // const rc = firebase.remoteConfig(app);\r\n     * ```\r\n     */\r\n    remoteConfig(): firebase.remoteConfig.RemoteConfig;\r\n    /**\r\n     * Gets the {@link firebase.analytics.Analytics `Analytics`} service for the\r\n     * current app. If the current app is not the default one, throws an error.\r\n     *\r\n     * The Analytics SDK does not work in a Node.js environment.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * const analytics = app.analytics();\r\n     * // The above is shorthand for:\r\n     * // const analytics = firebase.analytics(app);\r\n     * ```\r\n     */\r\n    analytics(): firebase.analytics.Analytics;\r\n    appCheck(): firebase.appCheck.AppCheck;\r\n  }\r\n}\r\n\r\n/**\r\n * Firebase App Check does not work in a Node.js environment using `ReCaptchaV3Provider` or\r\n * `ReCaptchaEnterpriseProvider`, but can be used in Node.js if you use\r\n * `CustomProvider` and write your own attestation method.\r\n */\r\ndeclare namespace firebase.appCheck {\r\n  /**\r\n   * Result returned by\r\n   * {@link firebase.appCheck.AppCheck.getToken `firebase.appCheck().getToken()`}.\r\n   */\r\n  interface AppCheckTokenResult {\r\n    token: string;\r\n  }\r\n  /*\r\n   * reCAPTCHA v3 token provider.\r\n   */\r\n  class ReCaptchaV3Provider {\r\n    /**\r\n     * @param siteKey - reCAPTCHA v3 site key (public key).\r\n     */\r\n    constructor(siteKey: string);\r\n  }\r\n  /*\r\n   * reCAPTCHA Enterprise token provider.\r\n   */\r\n  class ReCaptchaEnterpriseProvider {\r\n    /**\r\n     * @param keyId - reCAPTCHA Enterprise key ID.\r\n     */\r\n    constructor(keyId: string);\r\n  }\r\n  /*\r\n   * Custom token provider.\r\n   */\r\n  class CustomProvider {\r\n    /**\r\n     * @param options - Options for creating the custom provider.\r\n     */\r\n    constructor(options: CustomProviderOptions);\r\n  }\r\n  /**\r\n   * Options when creating a CustomProvider.\r\n   */\r\n  interface CustomProviderOptions {\r\n    /**\r\n     * Function to get an App Check token through a custom provider\r\n     * service.\r\n     */\r\n    getToken: () => Promise<AppCheckToken>;\r\n  }\r\n\r\n  /**\r\n   * The Firebase AppCheck service interface.\r\n   *\r\n   * Do not call this constructor directly. Instead, use\r\n   * {@link firebase.appCheck `firebase.appCheck()`}.\r\n   */\r\n  export interface AppCheck {\r\n    /**\r\n     * Activate AppCheck\r\n     * @param provider This can be a `ReCaptchaV3Provider` instance,\r\n     * a `ReCaptchaEnterpriseProvider` instance, a `CustomProvider` instance,\r\n     * an object with a custom `getToken()` method, or a reCAPTCHA site key.\r\n     * @param isTokenAutoRefreshEnabled If true, the SDK automatically\r\n     * refreshes App Check tokens as needed. If undefined, defaults to the\r\n     * value of `app.automaticDataCollectionEnabled`, which defaults to\r\n     * false and can be set in the app config.\r\n     */\r\n    activate(\r\n      provider:\r\n        | ReCaptchaV3Provider\r\n        | ReCaptchaEnterpriseProvider\r\n        | CustomProvider\r\n        | AppCheckProvider\r\n        | { getToken: () => AppCheckToken }\r\n        | string,\r\n      isTokenAutoRefreshEnabled?: boolean,\r\n    ): void;\r\n\r\n    /**\r\n     *\r\n     * @param isTokenAutoRefreshEnabled If true, the SDK automatically\r\n     * refreshes App Check tokens as needed. This overrides any value set\r\n     * during `activate()`.\r\n     */\r\n    setTokenAutoRefreshEnabled(isTokenAutoRefreshEnabled: boolean): void;\r\n    /**\r\n     * Get the current App Check token. Attaches to the most recent\r\n     * in-flight request if one is present. Returns null if no token\r\n     * is present and no token requests are in-flight.\r\n     *\r\n     * @param forceRefresh - If true, will always try to fetch a fresh token.\r\n     * If false, will use a cached token if found in storage.\r\n     */\r\n    getToken(\r\n      forceRefresh?: boolean,\r\n    ): Promise<firebase.appCheck.AppCheckTokenResult>;\r\n\r\n    /**\r\n     * Registers a listener to changes in the token state. There can be more\r\n     * than one listener registered at the same time for one or more\r\n     * App Check instances. The listeners call back on the UI thread whenever\r\n     * the current token associated with this App Check instance changes.\r\n     *\r\n     * @param observer An object with `next`, `error`, and `complete`\r\n     * properties. `next` is called with an\r\n     * {@link firebase.appCheck.AppCheckTokenResult `AppCheckTokenResult`}\r\n     * whenever the token changes. `error` is optional and is called if an\r\n     * error is thrown by the listener (the `next` function). `complete`\r\n     * is unused, as the token stream is unending.\r\n     *\r\n     * @returns A function that unsubscribes this listener.\r\n     */\r\n    onTokenChanged(observer: {\r\n      next: (tokenResult: firebase.appCheck.AppCheckTokenResult) => void;\r\n      error?: (error: Error) => void;\r\n      complete?: () => void;\r\n    }): Unsubscribe;\r\n\r\n    /**\r\n     * Registers a listener to changes in the token state. There can be more\r\n     * than one listener registered at the same time for one or more\r\n     * App Check instances. The listeners call back on the UI thread whenever\r\n     * the current token associated with this App Check instance changes.\r\n     *\r\n     * @param onNext When the token changes, this function is called with aa\r\n     * {@link firebase.appCheck.AppCheckTokenResult `AppCheckTokenResult`}.\r\n     * @param onError Optional. Called if there is an error thrown by the\r\n     * listener (the `onNext` function).\r\n     * @param onCompletion Currently unused, as the token stream is unending.\r\n     * @returns A function that unsubscribes this listener.\r\n     */\r\n    onTokenChanged(\r\n      onNext: (tokenResult: firebase.appCheck.AppCheckTokenResult) => void,\r\n      onError?: (error: Error) => void,\r\n      onCompletion?: () => void,\r\n    ): Unsubscribe;\r\n  }\r\n\r\n  /**\r\n   * An App Check provider. This can be either the built-in reCAPTCHA\r\n   * provider or a custom provider. For more on custom providers, see\r\n   * https://firebase.google.com/docs/app-check/web-custom-provider\r\n   */\r\n  interface AppCheckProvider {\r\n    /**\r\n     * Returns an AppCheck token.\r\n     */\r\n    getToken(): Promise<AppCheckToken>;\r\n  }\r\n\r\n  /**\r\n   * The token returned from an {@link firebase.appCheck.AppCheckProvider `AppCheckProvider`}.\r\n   */\r\n  interface AppCheckToken {\r\n    /**\r\n     * The token string in JWT format.\r\n     */\r\n    readonly token: string;\r\n    /**\r\n     * The local timestamp after which the token will expire.\r\n     */\r\n    readonly expireTimeMillis: number;\r\n  }\r\n}\r\n\r\n/**\r\n * The Installations SDK does not work in a Node.js environment.\r\n */\r\ndeclare namespace firebase.installations {\r\n  /**\r\n   * The Firebase Installations service interface.\r\n   *\r\n   * Do not call this constructor directly. Instead, use\r\n   * {@link firebase.installations `firebase.installations()`}.\r\n   */\r\n  export interface Installations {\r\n    /**\r\n     * The {@link firebase.app.App app} associated with the `Installations` service\r\n     * instance.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var app = analytics.app;\r\n     * ```\r\n     */\r\n    app: firebase.app.App;\r\n    /**\r\n     * Creates a Firebase Installation if there isn't one for the app and\r\n     * returns the Installation ID.\r\n     *\r\n     * @return Firebase Installation ID\r\n     */\r\n    getId(): Promise<string>;\r\n\r\n    /**\r\n     * Returns an Authentication Token for the current Firebase Installation.\r\n     *\r\n     * @return Firebase Installation Authentication Token\r\n     */\r\n    getToken(forceRefresh?: boolean): Promise<string>;\r\n\r\n    /**\r\n     * Deletes the Firebase Installation and all associated data.\r\n     */\r\n    delete(): Promise<void>;\r\n\r\n    /**\r\n     * Sets a new callback that will get called when Installation ID changes.\r\n     * Returns an unsubscribe function that will remove the callback when called.\r\n     */\r\n    onIdChange(callback: (installationId: string) => void): () => void;\r\n  }\r\n}\r\n\r\n/**\r\n * The Performance SDK does not work in a Node.js environment.\r\n */\r\ndeclare namespace firebase.performance {\r\n  /**\r\n   * The Firebase Performance Monitoring service interface.\r\n   *\r\n   * Do not call this constructor directly. Instead, use\r\n   * {@link firebase.performance `firebase.performance()`}.\r\n   */\r\n  export interface Performance {\r\n    /**\r\n     * The {@link firebase.app.App app} associated with the `Performance` service\r\n     * instance.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var app = analytics.app;\r\n     * ```\r\n     */\r\n    app: firebase.app.App;\r\n    /**\r\n     * Creates an uninitialized instance of {@link firebase.performance.Trace `trace`} and returns\r\n     * it.\r\n     *\r\n     * @param traceName The name of the trace instance.\r\n     * @return The Trace instance.\r\n     */\r\n    trace(traceName: string): Trace;\r\n\r\n    /**\r\n     * Controls the logging of automatic traces and HTTP/S network monitoring.\r\n     */\r\n    instrumentationEnabled: boolean;\r\n    /**\r\n     * Controls the logging of custom traces.\r\n     */\r\n    dataCollectionEnabled: boolean;\r\n  }\r\n\r\n  export interface Trace {\r\n    /**\r\n     * Starts the timing for the {@link firebase.performance.Trace `trace`} instance.\r\n     */\r\n    start(): void;\r\n    /**\r\n     * Stops the timing of the {@link firebase.performance.Trace `trace`} instance and logs the\r\n     * data of the instance.\r\n     */\r\n    stop(): void;\r\n    /**\r\n     * Records a {@link firebase.performance.Trace `trace`} from given parameters. This provides a\r\n     * direct way to use {@link firebase.performance.Trace `trace`} without a need to start/stop.\r\n     * This is useful for use cases in which the {@link firebase.performance.Trace `trace`} cannot\r\n     * directly be used (e.g. if the duration was captured before the Performance SDK was loaded).\r\n     *\r\n     * @param startTime Trace start time since epoch in millisec.\r\n     * @param duration The duration of the trace in millisec.\r\n     * @param options An object which can optionally hold maps of custom metrics and\r\n     * custom attributes.\r\n     */\r\n    record(\r\n      startTime: number,\r\n      duration: number,\r\n      options?: {\r\n        metrics?: { [key: string]: number };\r\n        attributes?: { [key: string]: string };\r\n      },\r\n    ): void;\r\n    /**\r\n     * Adds to the value of a custom metric. If a custom metric with the provided name does not\r\n     * exist, it creates one with that name and the value equal to the given number.\r\n     *\r\n     * @param metricName The name of the custom metric.\r\n     * @param num The number to be added to the value of the custom metric. If not provided, it\r\n     * uses a default value of one.\r\n     */\r\n    incrementMetric(metricName: string, num?: number): void;\r\n    /**\r\n     * Sets the value of the specified custom metric to the given number regardless of whether\r\n     * a metric with that name already exists on the {@link firebase.performance.Trace `trace`}\r\n     * instance or not.\r\n     *\r\n     * @param metricName Name of the custom metric.\r\n     * @param num Value to of the custom metric.\r\n     */\r\n    putMetric(metricName: string, num: number): void;\r\n    /**\r\n     * Returns the value of the custom metric by that name. If a custom metric with that name does\r\n     * not exist returns zero.\r\n     *\r\n     * @param metricName Name of the custom metric.\r\n     */\r\n    getMetric(metricName: string): number;\r\n    /**\r\n     * Set a custom attribute of a {@link firebase.performance.Trace `trace`} to a certain value.\r\n     *\r\n     * @param attr Name of the custom attribute.\r\n     * @param value Value of the custom attribute.\r\n     */\r\n    putAttribute(attr: string, value: string): void;\r\n    /**\r\n     * Retrieves the value that the custom attribute is set to.\r\n     *\r\n     * @param attr Name of the custom attribute.\r\n     */\r\n    getAttribute(attr: string): string | undefined;\r\n    /**\r\n     * Removes the specified custom attribute from a {@link firebase.performance.Trace `trace`}\r\n     * instance.\r\n     *\r\n     * @param attr Name of the custom attribute.\r\n     */\r\n\r\n    removeAttribute(attr: string): void;\r\n    /**\r\n     * Returns a map of all custom attributes of a {@link firebase.performance.Trace `trace`}\r\n     * instance.\r\n     */\r\n    getAttributes(): { [key: string]: string };\r\n  }\r\n}\r\n\r\n/**\r\n * The Remote Config SDK does not work in a Node.js environment.\r\n */\r\ndeclare namespace firebase.remoteConfig {\r\n  /**\r\n   * The Firebase Remote Config service interface.\r\n   *\r\n   * Do not call this constructor directly. Instead, use\r\n   * {@link firebase.remoteConfig `firebase.remoteConfig()`}.\r\n   */\r\n  export interface RemoteConfig {\r\n    /**\r\n     * The {@link firebase.app.App app} associated with the `Performance` service\r\n     * instance.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var app = analytics.app;\r\n     * ```\r\n     */\r\n    app: firebase.app.App;\r\n    /**\r\n     * Defines configuration for the Remote Config SDK.\r\n     */\r\n    settings: Settings;\r\n\r\n    /**\r\n     * Object containing default values for configs.\r\n     */\r\n    defaultConfig: { [key: string]: string | number | boolean };\r\n\r\n    /**\r\n     * The Unix timestamp in milliseconds of the last <i>successful</i> fetch, or negative one if\r\n     * the {@link RemoteConfig} instance either hasn't fetched or initialization\r\n     * is incomplete.\r\n     */\r\n    fetchTimeMillis: number;\r\n\r\n    /**\r\n     * The status of the last fetch <i>attempt</i>.\r\n     */\r\n    lastFetchStatus: FetchStatus;\r\n\r\n    /**\r\n     * Makes the last fetched config available to the getters.\r\n     * Returns a promise which resolves to true if the current call activated the fetched configs.\r\n     * If the fetched configs were already activated, the promise will resolve to false.\r\n     */\r\n    activate(): Promise<boolean>;\r\n\r\n    /**\r\n     * Ensures the last activated config are available to the getters.\r\n     */\r\n    ensureInitialized(): Promise<void>;\r\n\r\n    /**\r\n     * Fetches and caches configuration from the Remote Config service.\r\n     */\r\n    fetch(): Promise<void>;\r\n\r\n    /**\r\n     * Performs fetch and activate operations, as a convenience.\r\n     * Returns a promise which resolves to true if the current call activated the fetched configs.\r\n     * If the fetched configs were already activated, the promise will resolve to false.\r\n     */\r\n    fetchAndActivate(): Promise<boolean>;\r\n\r\n    /**\r\n     * Gets all config.\r\n     */\r\n    getAll(): { [key: string]: Value };\r\n\r\n    /**\r\n     * Gets the value for the given key as a boolean.\r\n     *\r\n     * Convenience method for calling <code>remoteConfig.getValue(key).asBoolean()</code>.\r\n     */\r\n    getBoolean(key: string): boolean;\r\n\r\n    /**\r\n     * Gets the value for the given key as a number.\r\n     *\r\n     * Convenience method for calling <code>remoteConfig.getValue(key).asNumber()</code>.\r\n     */\r\n    getNumber(key: string): number;\r\n\r\n    /**\r\n     * Gets the value for the given key as a String.\r\n     *\r\n     * Convenience method for calling <code>remoteConfig.getValue(key).asString()</code>.\r\n     */\r\n    getString(key: string): string;\r\n\r\n    /**\r\n     * Gets the {@link Value} for the given key.\r\n     */\r\n    getValue(key: string): Value;\r\n\r\n    /**\r\n     * Defines the log level to use.\r\n     */\r\n    setLogLevel(logLevel: LogLevel): void;\r\n  }\r\n\r\n  /**\r\n   * Indicates the source of a value.\r\n   *\r\n   * <ul>\r\n   *   <li>\"static\" indicates the value was defined by a static constant.</li>\r\n   *   <li>\"default\" indicates the value was defined by default config.</li>\r\n   *   <li>\"remote\" indicates the value was defined by fetched config.</li>\r\n   * </ul>\r\n   */\r\n  export type ValueSource = \"static\" | \"default\" | \"remote\";\r\n\r\n  /**\r\n   * Wraps a value with metadata and type-safe getters.\r\n   */\r\n  export interface Value {\r\n    /**\r\n     * Gets the value as a boolean.\r\n     *\r\n     * The following values (case-insensitive) are interpreted as true:\r\n     * \"1\", \"true\", \"t\", \"yes\", \"y\", \"on\". Other values are interpreted as false.\r\n     */\r\n    asBoolean(): boolean;\r\n\r\n    /**\r\n     * Gets the value as a number. Comparable to calling <code>Number(value) || 0</code>.\r\n     */\r\n    asNumber(): number;\r\n\r\n    /**\r\n     * Gets the value as a string.\r\n     */\r\n    asString(): string;\r\n\r\n    /**\r\n     * Gets the {@link ValueSource} for the given key.\r\n     */\r\n    getSource(): ValueSource;\r\n  }\r\n\r\n  /**\r\n   * Defines configuration options for the Remote Config SDK.\r\n   */\r\n  export interface Settings {\r\n    /**\r\n     * Defines the maximum age in milliseconds of an entry in the config cache before\r\n     * it is considered stale. Defaults to 43200000 (Twelve hours).\r\n     */\r\n    minimumFetchIntervalMillis: number;\r\n\r\n    /**\r\n     * Defines the maximum amount of milliseconds to wait for a response when fetching\r\n     * configuration from the Remote Config server. Defaults to 60000 (One minute).\r\n     */\r\n    fetchTimeoutMillis: number;\r\n  }\r\n\r\n  /**\r\n   * Summarizes the outcome of the last attempt to fetch config from the Firebase Remote Config server.\r\n   *\r\n   * <ul>\r\n   *   <li>\"no-fetch-yet\" indicates the {@link RemoteConfig} instance has not yet attempted\r\n   *       to fetch config, or that SDK initialization is incomplete.</li>\r\n   *   <li>\"success\" indicates the last attempt succeeded.</li>\r\n   *   <li>\"failure\" indicates the last attempt failed.</li>\r\n   *   <li>\"throttle\" indicates the last attempt was rate-limited.</li>\r\n   * </ul>\r\n   */\r\n  export type FetchStatus = \"no-fetch-yet\" | \"success\" | \"failure\" | \"throttle\";\r\n\r\n  /**\r\n   * Defines levels of Remote Config logging.\r\n   */\r\n  export type LogLevel = \"debug\" | \"error\" | \"silent\";\r\n\r\n  /**\r\n   * This method provides two different checks:\r\n   *\r\n   * 1. Check if IndexedDB exists in the browser environment.\r\n   * 2. Check if the current browser context allows IndexedDB `open()` calls.\r\n   *\r\n   * It returns a `Promise` which resolves to true if a {@link RemoteConfig} instance\r\n   * can be initialized in this environment, or false if it cannot.\r\n   */\r\n  export function isSupported(): Promise<boolean>;\r\n}\r\n\r\ndeclare namespace firebase.functions {\r\n  /**\r\n   * An HttpsCallableResult wraps a single result from a function call.\r\n   */\r\n  export interface HttpsCallableResult {\r\n    readonly data: any;\r\n  }\r\n  /**\r\n   * An HttpsCallable is a reference to a \"callable\" http trigger in\r\n   * Google Cloud Functions.\r\n   */\r\n  export interface HttpsCallable {\r\n    (data?: any): Promise<HttpsCallableResult>;\r\n  }\r\n  export interface HttpsCallableOptions {\r\n    timeout?: number;\r\n  }\r\n  /**\r\n   * The Cloud Functions for Firebase service interface.\r\n   *\r\n   * Do not call this constructor directly. Instead, use\r\n   * {@link firebase.functions `firebase.functions()`}.\r\n   */\r\n  export class Functions {\r\n    private constructor();\r\n\r\n    /**\r\n     * Modify this instance to communicate with the Cloud Functions emulator.\r\n     *\r\n     * Note: this must be called before this instance has been used to do any operations.\r\n     *\r\n     * @param host The emulator host (ex: localhost)\r\n     * @param port The emulator port (ex: 5001)\r\n     */\r\n    useEmulator(host: string, port: number): void;\r\n\r\n    /**\r\n     * Changes this instance to point to a Cloud Functions emulator running\r\n     * locally. See https://firebase.google.com/docs/functions/local-emulator\r\n     *\r\n     * @deprecated Prefer the useEmulator(host, port) method.\r\n     * @param origin The origin of the local emulator, such as\r\n     * \"http://localhost:5005\".\r\n     */\r\n    useFunctionsEmulator(url: string): void;\r\n    /**\r\n     * Gets an `HttpsCallable` instance that refers to the function with the given\r\n     * name.\r\n     *\r\n     * @param name The name of the https callable function.\r\n     * @param options The options for this HttpsCallable instance.\r\n     * @return The `HttpsCallable` instance.\r\n     */\r\n    httpsCallable(name: string, options?: HttpsCallableOptions): HttpsCallable;\r\n  }\r\n  /**\r\n   * The set of Firebase Functions status codes. The codes are the same at the\r\n   * ones exposed by gRPC here:\r\n   * https://github.com/grpc/grpc/blob/master/doc/statuscodes.md\r\n   *\r\n   * Possible values:\r\n   * - 'cancelled': The operation was cancelled (typically by the caller).\r\n   * - 'unknown': Unknown error or an error from a different error domain.\r\n   * - 'invalid-argument': Client specified an invalid argument. Note that this\r\n   *   differs from 'failed-precondition'. 'invalid-argument' indicates\r\n   *   arguments that are problematic regardless of the state of the system\r\n   *   (e.g. an invalid field name).\r\n   * - 'deadline-exceeded': Deadline expired before operation could complete.\r\n   *   For operations that change the state of the system, this error may be\r\n   *   returned even if the operation has completed successfully. For example,\r\n   *   a successful response from a server could have been delayed long enough\r\n   *   for the deadline to expire.\r\n   * - 'not-found': Some requested document was not found.\r\n   * - 'already-exists': Some document that we attempted to create already\r\n   *   exists.\r\n   * - 'permission-denied': The caller does not have permission to execute the\r\n   *   specified operation.\r\n   * - 'resource-exhausted': Some resource has been exhausted, perhaps a\r\n   *   per-user quota, or perhaps the entire file system is out of space.\r\n   * - 'failed-precondition': Operation was rejected because the system is not\r\n   *   in a state required for the operation's execution.\r\n   * - 'aborted': The operation was aborted, typically due to a concurrency\r\n   *   issue like transaction aborts, etc.\r\n   * - 'out-of-range': Operation was attempted past the valid range.\r\n   * - 'unimplemented': Operation is not implemented or not supported/enabled.\r\n   * - 'internal': Internal errors. Means some invariants expected by\r\n   *   underlying system has been broken. If you see one of these errors,\r\n   *   something is very broken.\r\n   * - 'unavailable': The service is currently unavailable. This is most likely\r\n   *   a transient condition and may be corrected by retrying with a backoff.\r\n   * - 'data-loss': Unrecoverable data loss or corruption.\r\n   * - 'unauthenticated': The request does not have valid authentication\r\n   *   credentials for the operation.\r\n   */\r\n  export type FunctionsErrorCode =\r\n    | \"ok\"\r\n    | \"cancelled\"\r\n    | \"unknown\"\r\n    | \"invalid-argument\"\r\n    | \"deadline-exceeded\"\r\n    | \"not-found\"\r\n    | \"already-exists\"\r\n    | \"permission-denied\"\r\n    | \"resource-exhausted\"\r\n    | \"failed-precondition\"\r\n    | \"aborted\"\r\n    | \"out-of-range\"\r\n    | \"unimplemented\"\r\n    | \"internal\"\r\n    | \"unavailable\"\r\n    | \"data-loss\"\r\n    | \"unauthenticated\";\r\n  export interface HttpsError extends Error {\r\n    /**\r\n     * A standard error code that will be returned to the client. This also\r\n     * determines the HTTP status code of the response, as defined in code.proto.\r\n     */\r\n    readonly code: FunctionsErrorCode;\r\n    /**\r\n     * Extra data to be converted to JSON and included in the error response.\r\n     */\r\n    readonly details?: any;\r\n  }\r\n}\r\n\r\ndeclare namespace firebase.auth {\r\n  /**\r\n   * A utility class to parse email action URLs.\r\n   */\r\n  class ActionCodeURL {\r\n    private constructor();\r\n    /**\r\n     * The API key of the email action link.\r\n     */\r\n    apiKey: string;\r\n    /**\r\n     * The action code of the email action link.\r\n     */\r\n    code: string;\r\n    /**\r\n     * The continue URL of the email action link. Null if not provided.\r\n     */\r\n    continueUrl: string | null;\r\n    /**\r\n     * The language code of the email action link. Null if not provided.\r\n     */\r\n    languageCode: string | null;\r\n    /**\r\n     * The action performed by the email action link. It returns from one\r\n     * of the types from {@link firebase.auth.ActionCodeInfo}.\r\n     */\r\n    operation: firebase.auth.ActionCodeInfo.Operation;\r\n    /**\r\n     * Parses the email action link string and returns an ActionCodeURL object\r\n     * if the link is valid, otherwise returns null.\r\n     *\r\n     * @param link The email action link string.\r\n     * @return The ActionCodeURL object, or null if the link is invalid.\r\n     */\r\n    static parseLink(link: string): firebase.auth.ActionCodeURL | null;\r\n    /**\r\n     * The tenant ID of the email action link. Null if the email action\r\n     * is from the parent project.\r\n     */\r\n    tenantId: string | null;\r\n  }\r\n  /**\r\n   * A response from {@link firebase.auth.Auth.checkActionCode}.\r\n   */\r\n  interface ActionCodeInfo {\r\n    /**\r\n     * The data associated with the action code.\r\n     *\r\n     * For the `PASSWORD_RESET`, `VERIFY_EMAIL`, and `RECOVER_EMAIL` actions, this object\r\n     * contains an `email` field with the address the email was sent to.\r\n     *\r\n     * For the RECOVER_EMAIL action, which allows a user to undo an email address\r\n     * change, this object also contains a `previousEmail` field with the user account's\r\n     * current email address. After the action completes, the user's email address will\r\n     * revert to the value in the `email` field from the value in `previousEmail` field.\r\n     *\r\n     * For the VERIFY_AND_CHANGE_EMAIL action, which allows a user to verify the email\r\n     * before updating it, this object contains a `previousEmail` field with the user\r\n     * account's email address before updating. After the action completes, the user's\r\n     * email address will be updated to the value in the `email` field from the value\r\n     * in `previousEmail` field.\r\n     *\r\n     * For the REVERT_SECOND_FACTOR_ADDITION action, which allows a user to unenroll\r\n     * a newly added second factor, this object contains a `multiFactorInfo` field with\r\n     * the information about the second factor. For phone second factor, the\r\n     * `multiFactorInfo` is a {@link firebase.auth.PhoneMultiFactorInfo} object,\r\n     * which contains the phone number.\r\n     */\r\n    data: {\r\n      email?: string | null;\r\n      /**\r\n       * @deprecated\r\n       * This field is deprecated in favor of previousEmail.\r\n       */\r\n      fromEmail?: string | null;\r\n      multiFactorInfo?: firebase.auth.MultiFactorInfo | null;\r\n      previousEmail?: string | null;\r\n    };\r\n    /**\r\n     * The type of operation that generated the action code. This could be:\r\n     * <ul>\r\n     * <li>`EMAIL_SIGNIN`: email sign in code generated via\r\n     *     {@link firebase.auth.Auth.sendSignInLinkToEmail}.</li>\r\n     * <li>`PASSWORD_RESET`: password reset code generated via\r\n     *     {@link firebase.auth.Auth.sendPasswordResetEmail}.</li>\r\n     * <li>`RECOVER_EMAIL`: email change revocation code generated via\r\n     *     {@link firebase.User.updateEmail}.</li>\r\n     * <li>`REVERT_SECOND_FACTOR_ADDITION`: revert second factor addition\r\n     *     code generated via\r\n     *     {@link firebase.User.MultiFactorUser.enroll}.</li>\r\n     * <li>`VERIFY_AND_CHANGE_EMAIL`: verify and change email code generated\r\n     *     via {@link firebase.User.verifyBeforeUpdateEmail}.</li>\r\n     * <li>`VERIFY_EMAIL`: email verification code generated via\r\n     *     {@link firebase.User.sendEmailVerification}.</li>\r\n     * </ul>\r\n     */\r\n    operation: string;\r\n  }\r\n\r\n  /**\r\n   * This is the interface that defines the required continue/state URL with\r\n   * optional Android and iOS bundle identifiers.\r\n   * The action code setting fields are:\r\n   * <ul>\r\n   * <li><p>url: Sets the link continue/state URL, which has different meanings\r\n   *     in different contexts:</p>\r\n   *     <ul>\r\n   *     <li>When the link is handled in the web action widgets, this is the deep\r\n   *         link in the continueUrl query parameter.</li>\r\n   *     <li>When the link is handled in the app directly, this is the continueUrl\r\n   *         query parameter in the deep link of the Dynamic Link.</li>\r\n   *     </ul>\r\n   *     </li>\r\n   * <li>iOS: Sets the iOS bundle ID. This will try to open the link in an iOS app\r\n   *     if it is installed.</li>\r\n   * <li>android: Sets the Android package name. This will try to open the link in\r\n   *     an android app if it is installed. If installApp is passed, it specifies\r\n   *     whether to install the Android app if the device supports it and the app\r\n   *     is not already installed. If this field is provided without a\r\n   *     packageName, an error is thrown explaining that the packageName must be\r\n   *     provided in conjunction with this field.\r\n   *     If minimumVersion is specified, and an older version of the app is\r\n   *     installed, the user is taken to the Play Store to upgrade the app.</li>\r\n   * <li>handleCodeInApp: The default is false. When set to true, the action code\r\n   *     link will be be sent as a Universal Link or Android App Link and will be\r\n   *     opened by the app if installed. In the false case, the code will be sent\r\n   *     to the web widget first and then on continue will redirect to the app if\r\n   *     installed.</li>\r\n   * </ul>\r\n   */\r\n  type ActionCodeSettings = {\r\n    android?: {\r\n      installApp?: boolean;\r\n      minimumVersion?: string;\r\n      packageName: string;\r\n    };\r\n    handleCodeInApp?: boolean;\r\n    iOS?: { bundleId: string };\r\n    url: string;\r\n    dynamicLinkDomain?: string;\r\n  };\r\n\r\n  /**\r\n   * A structure containing additional user information from a federated identity\r\n   * provider.\r\n   */\r\n  type AdditionalUserInfo = {\r\n    isNewUser: boolean;\r\n    profile: Object | null;\r\n    providerId: string;\r\n    username?: string | null;\r\n  };\r\n\r\n  /**\r\n   * A verifier for domain verification and abuse prevention. Currently, the\r\n   * only implementation is {@link firebase.auth.RecaptchaVerifier}.\r\n   */\r\n  interface ApplicationVerifier {\r\n    /**\r\n     * Identifies the type of application verifier (e.g. \"recaptcha\").\r\n     */\r\n    type: string;\r\n    /**\r\n     * Executes the verification process.\r\n     * @return A Promise for a token that can be used to\r\n     *     assert the validity of a request.\r\n     */\r\n    verify(): Promise<string>;\r\n  }\r\n\r\n  /**\r\n   * Interface representing an Auth instance's settings, currently used for\r\n   * enabling/disabling app verification for phone Auth testing.\r\n   */\r\n  interface AuthSettings {\r\n    /**\r\n     * When set, this property disables app verification for the purpose of testing\r\n     * phone authentication. For this property to take effect, it needs to be set\r\n     * before rendering a reCAPTCHA app verifier. When this is disabled, a\r\n     * mock reCAPTCHA is rendered instead. This is useful for manual testing during\r\n     * development or for automated integration tests.\r\n     *\r\n     * In order to use this feature, you will need to\r\n     * {@link https://firebase.google.com/docs/auth/web/phone-auth#test-with-whitelisted-phone-numbers\r\n     * whitelist your phone number} via the\r\n     * Firebase Console.\r\n     *\r\n     * The default value is false (app verification is enabled).\r\n     */\r\n    appVerificationDisabledForTesting: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface representing the Auth config.\r\n   *\r\n   * @public\r\n   */\r\n  export interface Config {\r\n    /**\r\n     * The API Key used to communicate with the Firebase Auth backend.\r\n     */\r\n    apiKey: string;\r\n    /**\r\n     * The host at which the Firebase Auth backend is running.\r\n     */\r\n    apiHost: string;\r\n    /**\r\n     * The scheme used to communicate with the Firebase Auth backend.\r\n     */\r\n    apiScheme: string;\r\n    /**\r\n     * The host at which the Secure Token API is running.\r\n     */\r\n    tokenApiHost: string;\r\n    /**\r\n     * The SDK Client Version.\r\n     */\r\n    sdkClientVersion: string;\r\n    /**\r\n     * The domain at which the web widgets are hosted (provided via Firebase Config).\r\n     */\r\n    authDomain?: string;\r\n  }\r\n\r\n  /**\r\n   * Configuration of Firebase Authentication Emulator.\r\n   */\r\n  export interface EmulatorConfig {\r\n    /**\r\n     * The protocol used to communicate with the emulator (\"http\"/\"https\").\r\n     */\r\n    readonly protocol: string;\r\n    /**\r\n     * The hostname of the emulator, which may be a domain (\"localhost\"), IPv4 address (\"127.0.0.1\")\r\n     * or quoted IPv6 address (\"[::1]\").\r\n     */\r\n    readonly host: string;\r\n    /**\r\n     * The port of the emulator, or null if port isn't specified (i.e. protocol default).\r\n     */\r\n    readonly port: number | null;\r\n    /**\r\n     * The emulator-specific options.\r\n     */\r\n    readonly options: {\r\n      /**\r\n       * Whether the warning banner attached to the DOM was disabled.\r\n       */\r\n      readonly disableWarnings: boolean;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * The Firebase Auth service interface.\r\n   *\r\n   * Do not call this constructor directly. Instead, use\r\n   * {@link firebase.auth `firebase.auth()`}.\r\n   *\r\n   * See\r\n   * {@link https://firebase.google.com/docs/auth/ Firebase Authentication}\r\n   * for a full guide on how to use the Firebase Auth service.\r\n   *\r\n   */\r\n  interface Auth {\r\n    /** The name of the app associated with the Auth service instance. */\r\n    readonly name: string;\r\n    /** The config used to initialize this instance. */\r\n    readonly config: Config;\r\n    /** The current emulator configuration (or null). */\r\n    readonly emulatorConfig: EmulatorConfig | null;\r\n    /**\r\n     * The {@link firebase.app.App app} associated with the `Auth` service\r\n     * instance.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var app = auth.app;\r\n     * ```\r\n     */\r\n    app: firebase.app.App;\r\n    /**\r\n     * Applies a verification code sent to the user by email or other out-of-band\r\n     * mechanism.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/expired-action-code</dt>\r\n     * <dd>Thrown if the action code has expired.</dd>\r\n     * <dt>auth/invalid-action-code</dt>\r\n     * <dd>Thrown if the action code is invalid. This can happen if the code is\r\n     *     malformed or has already been used.</dd>\r\n     * <dt>auth/user-disabled</dt>\r\n     * <dd>Thrown if the user corresponding to the given action code has been\r\n     *     disabled.</dd>\r\n     * <dt>auth/user-not-found</dt>\r\n     * <dd>Thrown if there is no user corresponding to the action code. This may\r\n     *     have happened if the user was deleted between when the action code was\r\n     *     issued and when this method was called.</dd>\r\n     * </dl>\r\n     *\r\n     * @param code A verification code sent to the user.\r\n     */\r\n    applyActionCode(code: string): Promise<void>;\r\n    /**\r\n     * Checks a verification code sent to the user by email or other out-of-band\r\n     * mechanism.\r\n     *\r\n     * Returns metadata about the code.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/expired-action-code</dt>\r\n     * <dd>Thrown if the action code has expired.</dd>\r\n     * <dt>auth/invalid-action-code</dt>\r\n     * <dd>Thrown if the action code is invalid. This can happen if the code is\r\n     *     malformed or has already been used.</dd>\r\n     * <dt>auth/user-disabled</dt>\r\n     * <dd>Thrown if the user corresponding to the given action code has been\r\n     *     disabled.</dd>\r\n     * <dt>auth/user-not-found</dt>\r\n     * <dd>Thrown if there is no user corresponding to the action code. This may\r\n     *     have happened if the user was deleted between when the action code was\r\n     *     issued and when this method was called.</dd>\r\n     * </dl>\r\n     *\r\n     * @param code A verification code sent to the user.\r\n     */\r\n    checkActionCode(code: string): Promise<firebase.auth.ActionCodeInfo>;\r\n    /**\r\n     * Completes the password reset process, given a confirmation code and new\r\n     * password.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/expired-action-code</dt>\r\n     * <dd>Thrown if the password reset code has expired.</dd>\r\n     * <dt>auth/invalid-action-code</dt>\r\n     * <dd>Thrown if the password reset code is invalid. This can happen if the\r\n     *     code is malformed or has already been used.</dd>\r\n     * <dt>auth/user-disabled</dt>\r\n     * <dd>Thrown if the user corresponding to the given password reset code has\r\n     *     been disabled.</dd>\r\n     * <dt>auth/user-not-found</dt>\r\n     * <dd>Thrown if there is no user corresponding to the password reset code. This\r\n     *     may have happened if the user was deleted between when the code was\r\n     *     issued and when this method was called.</dd>\r\n     * <dt>auth/weak-password</dt>\r\n     * <dd>Thrown if the new password is not strong enough.</dd>\r\n     * </dl>\r\n     *\r\n     * @param code The confirmation code send via email to the user.\r\n     * @param newPassword The new password.\r\n     */\r\n    confirmPasswordReset(code: string, newPassword: string): Promise<void>;\r\n\r\n    /**\r\n     * Creates a new user account associated with the specified email address and\r\n     * password.\r\n     *\r\n     * On successful creation of the user account, this user will also be\r\n     * signed in to your application.\r\n     *\r\n     * User account creation can fail if the account already exists or the password\r\n     * is invalid.\r\n     *\r\n     * Note: The email address acts as a unique identifier for the user and\r\n     * enables an email-based password reset.  This function will create\r\n     * a new user account and set the initial user password.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/email-already-in-use</dt>\r\n     * <dd>Thrown if there already exists an account with the given email\r\n     *     address.</dd>\r\n     * <dt>auth/invalid-email</dt>\r\n     * <dd>Thrown if the email address is not valid.</dd>\r\n     * <dt>auth/operation-not-allowed</dt>\r\n     * <dd>Thrown if email/password accounts are not enabled. Enable email/password\r\n     *     accounts in the Firebase Console, under the Auth tab.</dd>\r\n     * <dt>auth/weak-password</dt>\r\n     * <dd>Thrown if the password is not strong enough.</dd>\r\n     * </dl>\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * firebase.auth().createUserWithEmailAndPassword(email, password)\r\n     *     .catch(function(error) {\r\n     *   // Handle Errors here.\r\n     *   var errorCode = error.code;\r\n     *   var errorMessage = error.message;\r\n     *   if (errorCode == 'auth/weak-password') {\r\n     *     alert('The password is too weak.');\r\n     *   } else {\r\n     *     alert(errorMessage);\r\n     *   }\r\n     *   console.log(error);\r\n     * });\r\n     * ```\r\n     * @param email The user's email address.\r\n     * @param password The user's chosen password.\r\n     */\r\n    createUserWithEmailAndPassword(\r\n      email: string,\r\n      password: string,\r\n    ): Promise<firebase.auth.UserCredential>;\r\n    /**\r\n     * The currently signed-in user (or null).\r\n     */\r\n    currentUser: firebase.User | null;\r\n\r\n    /**\r\n     * Gets the list of possible sign in methods for the given email address. This\r\n     * is useful to differentiate methods of sign-in for the same provider,\r\n     * eg. `EmailAuthProvider` which has 2 methods of sign-in, email/password and\r\n     * email/link.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/invalid-email</dt>\r\n     * <dd>Thrown if the email address is not valid.</dd>\r\n     * </dl>\r\n     */\r\n    fetchSignInMethodsForEmail(email: string): Promise<Array<string>>;\r\n\r\n    /**\r\n     * Checks if an incoming link is a sign-in with email link.\r\n     */\r\n    isSignInWithEmailLink(emailLink: string): boolean;\r\n    /**\r\n     * Returns a UserCredential from the redirect-based sign-in flow.\r\n     *\r\n     * If sign-in succeeded, returns the signed in user. If sign-in was\r\n     * unsuccessful, fails with an error. If no redirect operation was called, returns `null`.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/account-exists-with-different-credential</dt>\r\n     * <dd>Thrown if there already exists an account with the email address\r\n     *     asserted by the credential. Resolve this by calling\r\n     *     {@link firebase.auth.Auth.fetchSignInMethodsForEmail} with the error.email\r\n     *     and then asking the user to sign in using one of the returned providers.\r\n     *     Once the user is signed in, the original credential retrieved from the\r\n     *     error.credential can be linked to the user with\r\n     *     {@link firebase.User.linkWithCredential} to prevent the user from signing\r\n     *     in again to the original provider via popup or redirect. If you are using\r\n     *     redirects for sign in, save the credential in session storage and then\r\n     *     retrieve on redirect and repopulate the credential using for example\r\n     *     {@link firebase.auth.GoogleAuthProvider.credential} depending on the\r\n     *     credential provider id and complete the link.</dd>\r\n     * <dt>auth/auth-domain-config-required</dt>\r\n     * <dd>Thrown if authDomain configuration is not provided when calling\r\n     *     firebase.initializeApp(). Check Firebase Console for instructions on\r\n     *     determining and passing that field.</dd>\r\n     * <dt>auth/credential-already-in-use</dt>\r\n     * <dd>Thrown if the account corresponding to the credential already exists\r\n     *     among your users, or is already linked to a Firebase User.\r\n     *     For example, this error could be thrown if you are upgrading an anonymous\r\n     *     user to a Google user by linking a Google credential to it and the Google\r\n     *     credential used is already associated with an existing Firebase Google\r\n     *     user.\r\n     *     An <code>error.email</code> and <code>error.credential</code>\r\n     *     ({@link firebase.auth.AuthCredential}) fields are also provided. You can\r\n     *     recover from this error by signing in with that credential directly via\r\n     *     {@link firebase.auth.Auth.signInWithCredential}.</dd>\r\n     * <dt>auth/email-already-in-use</dt>\r\n     * <dd>Thrown if the email corresponding to the credential already exists\r\n     *     among your users. When thrown while linking a credential to an existing\r\n     *     user, an <code>error.email</code> and <code>error.credential</code>\r\n     *     ({@link firebase.auth.AuthCredential}) fields are also provided.\r\n     *     You have to link the credential to the existing user with that email if\r\n     *     you wish to continue signing in with that credential. To do so, call\r\n     *     {@link firebase.auth.Auth.fetchSignInMethodsForEmail}, sign in to\r\n     *     <code>error.email</code> via one of the providers returned and then\r\n     *     {@link firebase.User.linkWithCredential} the original credential to that\r\n     *     newly signed in user.</dd>\r\n     * <dt>auth/operation-not-allowed</dt>\r\n     * <dd>Thrown if the type of account corresponding to the credential\r\n     *     is not enabled. Enable the account type in the Firebase Console, under\r\n     *     the Auth tab.</dd>\r\n     * <dt>auth/operation-not-supported-in-this-environment</dt>\r\n     * <dd>Thrown if this operation is not supported in the environment your\r\n     *     application is running on. \"location.protocol\" must be http or https.\r\n     *     </dd>\r\n     * <dt>auth/timeout</dt>\r\n     * <dd>Thrown typically if the app domain is not authorized for OAuth operations\r\n     *     for your Firebase project. Edit the list of authorized domains from the\r\n     *     Firebase console.</dd>\r\n     * </dl>\r\n     *\r\n     * This method does not work in a Node.js environment.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // First, we perform the signInWithRedirect.\r\n     * // Creates the provider object.\r\n     * var provider = new firebase.auth.FacebookAuthProvider();\r\n     * // You can add additional scopes to the provider:\r\n     * provider.addScope('email');\r\n     * provider.addScope('user_friends');\r\n     * // Sign in with redirect:\r\n     * auth.signInWithRedirect(provider)\r\n     * ////////////////////////////////////////////////////////////\r\n     * // The user is redirected to the provider's sign in flow...\r\n     * ////////////////////////////////////////////////////////////\r\n     * // Then redirected back to the app, where we check the redirect result:\r\n     * auth.getRedirectResult().then(function(result) {\r\n     *   // The firebase.User instance:\r\n     *   var user = result.user;\r\n     *   // The Facebook firebase.auth.AuthCredential containing the Facebook\r\n     *   // access token:\r\n     *   var credential = result.credential;\r\n     *   // As this API can be used for sign-in, linking and reauthentication,\r\n     *   // check the operationType to determine what triggered this redirect\r\n     *   // operation.\r\n     *   var operationType = result.operationType;\r\n     * }, function(error) {\r\n     *   // The provider's account email, can be used in case of\r\n     *   // auth/account-exists-with-different-credential to fetch the providers\r\n     *   // linked to the email:\r\n     *   var email = error.email;\r\n     *   // The provider's credential:\r\n     *   var credential = error.credential;\r\n     *   // In case of auth/account-exists-with-different-credential error,\r\n     *   // you can fetch the providers using this:\r\n     *   if (error.code === 'auth/account-exists-with-different-credential') {\r\n     *     auth.fetchSignInMethodsForEmail(email).then(function(providers) {\r\n     *       // The returned 'providers' is a list of the available providers\r\n     *       // linked to the email address. Please refer to the guide for a more\r\n     *       // complete explanation on how to recover from this error.\r\n     *     });\r\n     *   }\r\n     * });\r\n     * ```\r\n     */\r\n    getRedirectResult(): Promise<firebase.auth.UserCredential>;\r\n    /**\r\n     * The current Auth instance's language code. This is a readable/writable\r\n     * property. When set to null, the default Firebase Console language setting\r\n     * is applied. The language code will propagate to email action templates\r\n     * (password reset, email verification and email change revocation), SMS\r\n     * templates for phone authentication, reCAPTCHA verifier and OAuth\r\n     * popup/redirect operations provided the specified providers support\r\n     * localization with the language code specified.\r\n     */\r\n    languageCode: string | null;\r\n    /**\r\n     * The current Auth instance's settings. This is used to edit/read configuration\r\n     * related options like app verification mode for phone authentication.\r\n     */\r\n    settings: firebase.auth.AuthSettings;\r\n    /**\r\n     * Adds an observer for changes to the user's sign-in state.\r\n     *\r\n     * Prior to 4.0.0, this triggered the observer when users were signed in,\r\n     * signed out, or when the user's ID token changed in situations such as token\r\n     * expiry or password change. After 4.0.0, the observer is only triggered\r\n     * on sign-in or sign-out.\r\n     *\r\n     * To keep the old behavior, see {@link firebase.auth.Auth.onIdTokenChanged}.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * firebase.auth().onAuthStateChanged(function(user) {\r\n     *   if (user) {\r\n     *     // User is signed in.\r\n     *   }\r\n     * });\r\n     * ```\r\n     */\r\n    onAuthStateChanged(\r\n      nextOrObserver:\r\n        | firebase.Observer<any>\r\n        | ((a: firebase.User | null) => any),\r\n      error?: (a: firebase.auth.Error) => any,\r\n      completed?: firebase.Unsubscribe,\r\n    ): firebase.Unsubscribe;\r\n    /**\r\n     * Adds an observer for changes to the signed-in user's ID token, which includes\r\n     * sign-in, sign-out, and token refresh events. This method has the same\r\n     * behavior as {@link firebase.auth.Auth.onAuthStateChanged} had prior to 4.0.0.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * firebase.auth().onIdTokenChanged(function(user) {\r\n     *   if (user) {\r\n     *     // User is signed in or token was refreshed.\r\n     *   }\r\n     * });\r\n     * ```\r\n     * @param\r\n     *     nextOrObserver An observer object or a function triggered on change.\r\n     * @param error Optional A function\r\n     *     triggered on auth error.\r\n     * @param completed Optional A function triggered when the\r\n     *     observer is removed.\r\n     */\r\n    onIdTokenChanged(\r\n      nextOrObserver:\r\n        | firebase.Observer<any>\r\n        | ((a: firebase.User | null) => any),\r\n      error?: (a: firebase.auth.Error) => any,\r\n      completed?: firebase.Unsubscribe,\r\n    ): firebase.Unsubscribe;\r\n    /**\r\n     * Sends a sign-in email link to the user with the specified email.\r\n     *\r\n     * The sign-in operation has to always be completed in the app unlike other out\r\n     * of band email actions (password reset and email verifications). This is\r\n     * because, at the end of the flow, the user is expected to be signed in and\r\n     * their Auth state persisted within the app.\r\n     *\r\n     * To complete sign in with the email link, call\r\n     * {@link firebase.auth.Auth.signInWithEmailLink} with the email address and\r\n     * the email link supplied in the email sent to the user.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/argument-error</dt>\r\n     * <dd>Thrown if handleCodeInApp is false.</dd>\r\n     * <dt>auth/invalid-email</dt>\r\n     * <dd>Thrown if the email address is not valid.</dd>\r\n     * <dt>auth/missing-android-pkg-name</dt>\r\n     * <dd>An Android package name must be provided if the Android app is required\r\n     *     to be installed.</dd>\r\n     * <dt>auth/missing-continue-uri</dt>\r\n     * <dd>A continue URL must be provided in the request.</dd>\r\n     * <dt>auth/missing-ios-bundle-id</dt>\r\n     * <dd>An iOS Bundle ID must be provided if an App Store ID is provided.</dd>\r\n     * <dt>auth/invalid-continue-uri</dt>\r\n     * <dd>The continue URL provided in the request is invalid.</dd>\r\n     * <dt>auth/unauthorized-continue-uri</dt>\r\n     * <dd>The domain of the continue URL is not whitelisted. Whitelist\r\n     *     the domain in the Firebase console.</dd>\r\n     * </dl>\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var actionCodeSettings = {\r\n     *   // The URL to redirect to for sign-in completion. This is also the deep\r\n     *   // link for mobile redirects. The domain (www.example.com) for this URL\r\n     *   // must be whitelisted in the Firebase Console.\r\n     *   url: 'https://www.example.com/finishSignUp?cartId=1234',\r\n     *   iOS: {\r\n     *     bundleId: 'com.example.ios'\r\n     *   },\r\n     *   android: {\r\n     *     packageName: 'com.example.android',\r\n     *     installApp: true,\r\n     *     minimumVersion: '12'\r\n     *   },\r\n     *   // This must be true.\r\n     *   handleCodeInApp: true\r\n     * };\r\n     * firebase.auth().sendSignInLinkToEmail('user@example.com', actionCodeSettings)\r\n     *     .then(function() {\r\n     *       // The link was successfully sent. Inform the user. Save the email\r\n     *       // locally so you don't need to ask the user for it again if they open\r\n     *       // the link on the same device.\r\n     *     })\r\n     *     .catch(function(error) {\r\n     *       // Some error occurred, you can inspect the code: error.code\r\n     *     });\r\n     * ```\r\n     * @param email The email account to sign in with.\r\n     * @param actionCodeSettings The action\r\n     *     code settings. The action code settings which provides Firebase with\r\n     *     instructions on how to construct the email link. This includes the\r\n     *     sign in completion URL or the deep link for mobile redirects, the mobile\r\n     *     apps to use when the sign-in link is opened on an Android or iOS device.\r\n     *     Mobile app redirects will only be applicable if the developer configures\r\n     *     and accepts the Firebase Dynamic Links terms of condition.\r\n     *     The Android package name and iOS bundle ID will be respected only if they\r\n     *     are configured in the same Firebase Auth project used.\r\n     */\r\n    sendSignInLinkToEmail(\r\n      email: string,\r\n      actionCodeSettings: firebase.auth.ActionCodeSettings,\r\n    ): Promise<void>;\r\n\r\n    /**\r\n     * Sends a password reset email to the given email address.\r\n     *\r\n     * To complete the password reset, call\r\n     * {@link firebase.auth.Auth.confirmPasswordReset} with the code supplied in the\r\n     * email sent to the user, along with the new password specified by the user.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/invalid-email</dt>\r\n     * <dd>Thrown if the email address is not valid.</dd>\r\n     * <dt>auth/missing-android-pkg-name</dt>\r\n     * <dd>An Android package name must be provided if the Android app is required\r\n     *     to be installed.</dd>\r\n     * <dt>auth/missing-continue-uri</dt>\r\n     * <dd>A continue URL must be provided in the request.</dd>\r\n     * <dt>auth/missing-ios-bundle-id</dt>\r\n     * <dd>An iOS Bundle ID must be provided if an App Store ID is provided.</dd>\r\n     * <dt>auth/invalid-continue-uri</dt>\r\n     * <dd>The continue URL provided in the request is invalid.</dd>\r\n     * <dt>auth/unauthorized-continue-uri</dt>\r\n     * <dd>The domain of the continue URL is not whitelisted. Whitelist\r\n     *     the domain in the Firebase console.</dd>\r\n     * <dt>auth/user-not-found</dt>\r\n     * <dd>Thrown if there is no user corresponding to the email address.</dd>\r\n     * </dl>\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var actionCodeSettings = {\r\n     *   url: 'https://www.example.com/?email=user@example.com',\r\n     *   iOS: {\r\n     *     bundleId: 'com.example.ios'\r\n     *   },\r\n     *   android: {\r\n     *     packageName: 'com.example.android',\r\n     *     installApp: true,\r\n     *     minimumVersion: '12'\r\n     *   },\r\n     *   handleCodeInApp: true\r\n     * };\r\n     * firebase.auth().sendPasswordResetEmail(\r\n     *     'user@example.com', actionCodeSettings)\r\n     *     .then(function() {\r\n     *       // Password reset email sent.\r\n     *     })\r\n     *     .catch(function(error) {\r\n     *       // Error occurred. Inspect error.code.\r\n     *     });\r\n     * ```\r\n     *\r\n     * @param email The email address with the password to be reset.\r\n     * @param actionCodeSettings The action\r\n     *     code settings. If specified, the state/continue URL will be set as the\r\n     *     \"continueUrl\" parameter in the password reset link. The default password\r\n     *     reset landing page will use this to display a link to go back to the app\r\n     *     if it is installed.\r\n     *     If the actionCodeSettings is not specified, no URL is appended to the\r\n     *     action URL.\r\n     *     The state URL provided must belong to a domain that is whitelisted by the\r\n     *     developer in the console. Otherwise an error will be thrown.\r\n     *     Mobile app redirects will only be applicable if the developer configures\r\n     *     and accepts the Firebase Dynamic Links terms of condition.\r\n     *     The Android package name and iOS bundle ID will be respected only if they\r\n     *     are configured in the same Firebase Auth project used.\r\n     */\r\n    sendPasswordResetEmail(\r\n      email: string,\r\n      actionCodeSettings?: firebase.auth.ActionCodeSettings | null,\r\n    ): Promise<void>;\r\n\r\n    /**\r\n     * Changes the current type of persistence on the current Auth instance for the\r\n     * currently saved Auth session and applies this type of persistence for\r\n     * future sign-in requests, including sign-in with redirect requests. This will\r\n     * return a promise that will resolve once the state finishes copying from one\r\n     * type of storage to the other.\r\n     * Calling a sign-in method after changing persistence will wait for that\r\n     * persistence change to complete before applying it on the new Auth state.\r\n     *\r\n     * This makes it easy for a user signing in to specify whether their session\r\n     * should be remembered or not. It also makes it easier to never persist the\r\n     * Auth state for applications that are shared by other users or have sensitive\r\n     * data.\r\n     *\r\n     * The default for web browser apps and React Native apps is 'local' (provided\r\n     * the browser supports this mechanism) whereas it is 'none' for Node.js backend\r\n     * apps.\r\n     *\r\n     * <h4>Error Codes (thrown synchronously)</h4>\r\n     * <dl>\r\n     * <dt>auth/invalid-persistence-type</dt>\r\n     * <dd>Thrown if the specified persistence type is invalid.</dd>\r\n     * <dt>auth/unsupported-persistence-type</dt>\r\n     * <dd>Thrown if the current environment does not support the specified\r\n     *     persistence type.</dd>\r\n     * </dl>\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * firebase.auth().setPersistence(firebase.auth.Auth.Persistence.SESSION)\r\n     *     .then(function() {\r\n     *   // Existing and future Auth states are now persisted in the current\r\n     *   // session only. Closing the window would clear any existing state even if\r\n     *   // a user forgets to sign out.\r\n     * });\r\n     * ```\r\n     */\r\n    setPersistence(persistence: firebase.auth.Auth.Persistence): Promise<void>;\r\n\r\n    /**\r\n     * Asynchronously signs in with the given credentials, and returns any available\r\n     * additional user information, such as user name.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/account-exists-with-different-credential</dt>\r\n     * <dd>Thrown if there already exists an account with the email address\r\n     *     asserted by the credential. Resolve this by calling\r\n     *     {@link firebase.auth.Auth.fetchSignInMethodsForEmail} and then asking the\r\n     *     user to sign in using one of the returned providers. Once the user is\r\n     *     signed in, the original credential can be linked to the user with\r\n     *     {@link firebase.User.linkWithCredential}.</dd>\r\n     * <dt>auth/invalid-credential</dt>\r\n     * <dd>Thrown if the credential is malformed or has expired.</dd>\r\n     * <dt>auth/operation-not-allowed</dt>\r\n     * <dd>Thrown if the type of account corresponding to the credential\r\n     *     is not enabled. Enable the account type in the Firebase Console, under\r\n     *     the Auth tab.</dd>\r\n     * <dt>auth/user-disabled</dt>\r\n     * <dd>Thrown if the user corresponding to the given credential has been\r\n     *     disabled.</dd>\r\n     * <dt>auth/user-not-found</dt>\r\n     * <dd>Thrown if signing in with a credential from\r\n     *     {@link firebase.auth.EmailAuthProvider.credential} and there is no user\r\n     *     corresponding to the given email. </dd>\r\n     * <dt>auth/wrong-password</dt>\r\n     * <dd>Thrown if signing in with a credential from\r\n     *     {@link firebase.auth.EmailAuthProvider.credential} and the password is\r\n     *     invalid for the given email, or if the account corresponding to the email\r\n     *     does not have a password set.</dd>\r\n     * <dt>auth/invalid-verification-code</dt>\r\n     * <dd>Thrown if the credential is a\r\n     *     {@link firebase.auth.PhoneAuthProvider.credential} and the verification\r\n     *     code of the credential is not valid.</dd>\r\n     * <dt>auth/invalid-verification-id</dt>\r\n     * <dd>Thrown if the credential is a\r\n     *     {@link firebase.auth.PhoneAuthProvider.credential}  and the verification\r\n     *     ID of the credential is not valid.</dd>\r\n     * </dl>\r\n     *\r\n     * @deprecated\r\n     * This method is deprecated. Use\r\n     * {@link firebase.auth.Auth.signInWithCredential} instead.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * firebase.auth().signInAndRetrieveDataWithCredential(credential)\r\n     *     .then(function(userCredential) {\r\n     *       console.log(userCredential.additionalUserInfo.username);\r\n     *     });\r\n     * ```\r\n     * @param credential The auth credential.\r\n     */\r\n    signInAndRetrieveDataWithCredential(\r\n      credential: firebase.auth.AuthCredential,\r\n    ): Promise<firebase.auth.UserCredential>;\r\n    /**\r\n     * Asynchronously signs in as an anonymous user.\r\n     *\r\n     *\r\n     * If there is already an anonymous user signed in, that user will be returned;\r\n     * otherwise, a new anonymous user identity will be created and returned.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/operation-not-allowed</dt>\r\n     * <dd>Thrown if anonymous accounts are not enabled. Enable anonymous accounts\r\n     *     in the Firebase Console, under the Auth tab.</dd>\r\n     * </dl>\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * firebase.auth().signInAnonymously().catch(function(error) {\r\n     *   // Handle Errors here.\r\n     *   var errorCode = error.code;\r\n     *   var errorMessage = error.message;\r\n     *\r\n     *   if (errorCode === 'auth/operation-not-allowed') {\r\n     *     alert('You must enable Anonymous auth in the Firebase Console.');\r\n     *   } else {\r\n     *     console.error(error);\r\n     *   }\r\n     * });\r\n     * ```\r\n     */\r\n    signInAnonymously(): Promise<firebase.auth.UserCredential>;\r\n\r\n    /**\r\n     * Asynchronously signs in with the given credentials.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/account-exists-with-different-credential</dt>\r\n     * <dd>Thrown if there already exists an account with the email address\r\n     *     asserted by the credential. Resolve this by calling\r\n     *     {@link firebase.auth.Auth.fetchSignInMethodsForEmail} and then asking the\r\n     *     user to sign in using one of the returned providers. Once the user is\r\n     *     signed in, the original credential can be linked to the user with\r\n     *     {@link firebase.User.linkWithCredential}.</dd>\r\n     * <dt>auth/invalid-credential</dt>\r\n     * <dd>Thrown if the credential is malformed or has expired.</dd>\r\n     * <dt>auth/operation-not-allowed</dt>\r\n     * <dd>Thrown if the type of account corresponding to the credential\r\n     *     is not enabled. Enable the account type in the Firebase Console, under\r\n     *     the Auth tab.</dd>\r\n     * <dt>auth/user-disabled</dt>\r\n     * <dd>Thrown if the user corresponding to the given credential has been\r\n     *     disabled.</dd>\r\n     * <dt>auth/user-not-found</dt>\r\n     * <dd>Thrown if signing in with a credential from\r\n     *     {@link firebase.auth.EmailAuthProvider.credential} and there is no user\r\n     *     corresponding to the given email. </dd>\r\n     * <dt>auth/wrong-password</dt>\r\n     * <dd>Thrown if signing in with a credential from\r\n     *     {@link firebase.auth.EmailAuthProvider.credential} and the password is\r\n     *     invalid for the given email, or if the account corresponding to the email\r\n     *     does not have a password set.</dd>\r\n     * <dt>auth/invalid-verification-code</dt>\r\n     * <dd>Thrown if the credential is a\r\n     *     {@link firebase.auth.PhoneAuthProvider.credential} and the verification\r\n     *     code of the credential is not valid.</dd>\r\n     * <dt>auth/invalid-verification-id</dt>\r\n     * <dd>Thrown if the credential is a\r\n     *     {@link firebase.auth.PhoneAuthProvider.credential}  and the verification\r\n     *     ID of the credential is not valid.</dd>\r\n     * </dl>\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * firebase.auth().signInWithCredential(credential).catch(function(error) {\r\n     *   // Handle Errors here.\r\n     *   var errorCode = error.code;\r\n     *   var errorMessage = error.message;\r\n     *   // The email of the user's account used.\r\n     *   var email = error.email;\r\n     *   // The firebase.auth.AuthCredential type that was used.\r\n     *   var credential = error.credential;\r\n     *   if (errorCode === 'auth/account-exists-with-different-credential') {\r\n     *     alert('Email already associated with another account.');\r\n     *     // Handle account linking here, if using.\r\n     *   } else {\r\n     *     console.error(error);\r\n     *   }\r\n     *  });\r\n     * ```\r\n     *\r\n     * @param credential The auth credential.\r\n     */\r\n    signInWithCredential(\r\n      credential: firebase.auth.AuthCredential,\r\n    ): Promise<firebase.auth.UserCredential>;\r\n    /**\r\n     * Asynchronously signs in using a custom token.\r\n     *\r\n     * Custom tokens are used to integrate Firebase Auth with existing auth systems,\r\n     * and must be generated by the auth backend.\r\n     *\r\n     * Fails with an error if the token is invalid, expired, or not accepted by the\r\n     * Firebase Auth service.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/custom-token-mismatch</dt>\r\n     * <dd>Thrown if the custom token is for a different Firebase App.</dd>\r\n     * <dt>auth/invalid-custom-token</dt>\r\n     * <dd>Thrown if the custom token format is incorrect.</dd>\r\n     * </dl>\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * firebase.auth().signInWithCustomToken(token).catch(function(error) {\r\n     *   // Handle Errors here.\r\n     *   var errorCode = error.code;\r\n     *   var errorMessage = error.message;\r\n     *   if (errorCode === 'auth/invalid-custom-token') {\r\n     *     alert('The token you provided is not valid.');\r\n     *   } else {\r\n     *     console.error(error);\r\n     *   }\r\n     * });\r\n     * ```\r\n     *\r\n     * @param token The custom token to sign in with.\r\n     */\r\n    signInWithCustomToken(token: string): Promise<firebase.auth.UserCredential>;\r\n    /**\r\n     * Asynchronously signs in using an email and password.\r\n     *\r\n     * Fails with an error if the email address and password do not match.\r\n     *\r\n     * Note: The user's password is NOT the password used to access the user's email\r\n     * account. The email address serves as a unique identifier for the user, and\r\n     * the password is used to access the user's account in your Firebase project.\r\n     *\r\n     * See also: {@link firebase.auth.Auth.createUserWithEmailAndPassword}.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/invalid-email</dt>\r\n     * <dd>Thrown if the email address is not valid.</dd>\r\n     * <dt>auth/user-disabled</dt>\r\n     * <dd>Thrown if the user corresponding to the given email has been\r\n     *     disabled.</dd>\r\n     * <dt>auth/user-not-found</dt>\r\n     * <dd>Thrown if there is no user corresponding to the given email.</dd>\r\n     * <dt>auth/wrong-password</dt>\r\n     * <dd>Thrown if the password is invalid for the given email, or the account\r\n     *     corresponding to the email does not have a password set.</dd>\r\n     * </dl>\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * firebase.auth().signInWithEmailAndPassword(email, password)\r\n     *     .catch(function(error) {\r\n     *   // Handle Errors here.\r\n     *   var errorCode = error.code;\r\n     *   var errorMessage = error.message;\r\n     *   if (errorCode === 'auth/wrong-password') {\r\n     *     alert('Wrong password.');\r\n     *   } else {\r\n     *     alert(errorMessage);\r\n     *   }\r\n     *   console.log(error);\r\n     * });\r\n     * ```\r\n     *\r\n     * @param email The users email address.\r\n     * @param password The users password.\r\n     */\r\n    signInWithEmailAndPassword(\r\n      email: string,\r\n      password: string,\r\n    ): Promise<firebase.auth.UserCredential>;\r\n\r\n    /**\r\n     * Asynchronously signs in using a phone number. This method sends a code via\r\n     * SMS to the given phone number, and returns a\r\n     * {@link firebase.auth.ConfirmationResult}. After the user provides the code\r\n     * sent to their phone, call {@link firebase.auth.ConfirmationResult.confirm}\r\n     * with the code to sign the user in.\r\n     *\r\n     * For abuse prevention, this method also requires a\r\n     * {@link firebase.auth.ApplicationVerifier}. The Firebase Auth SDK includes\r\n     * a reCAPTCHA-based implementation, {@link firebase.auth.RecaptchaVerifier}.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/captcha-check-failed</dt>\r\n     * <dd>Thrown if the reCAPTCHA response token was invalid, expired, or if\r\n     *     this method was called from a non-whitelisted domain.</dd>\r\n     * <dt>auth/invalid-phone-number</dt>\r\n     * <dd>Thrown if the phone number has an invalid format.</dd>\r\n     * <dt>auth/missing-phone-number</dt>\r\n     * <dd>Thrown if the phone number is missing.</dd>\r\n     * <dt>auth/quota-exceeded</dt>\r\n     * <dd>Thrown if the SMS quota for the Firebase project has been exceeded.</dd>\r\n     * <dt>auth/user-disabled</dt>\r\n     * <dd>Thrown if the user corresponding to the given phone number has been\r\n     *     disabled.</dd>\r\n     * <dt>auth/operation-not-allowed</dt>\r\n     * <dd>Thrown if you have not enabled the provider in the Firebase Console. Go\r\n     *     to the Firebase Console for your project, in the Auth section and the\r\n     *     <strong>Sign in Method</strong> tab and configure the provider.</dd>\r\n     * </dl>\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // 'recaptcha-container' is the ID of an element in the DOM.\r\n     * var applicationVerifier = new firebase.auth.RecaptchaVerifier(\r\n     *     'recaptcha-container');\r\n     * firebase.auth().signInWithPhoneNumber(phoneNumber, applicationVerifier)\r\n     *     .then(function(confirmationResult) {\r\n     *       var verificationCode = window.prompt('Please enter the verification ' +\r\n     *           'code that was sent to your mobile device.');\r\n     *       return confirmationResult.confirm(verificationCode);\r\n     *     })\r\n     *     .catch(function(error) {\r\n     *       // Handle Errors here.\r\n     *     });\r\n     * ```\r\n     *\r\n     * @param phoneNumber The user's phone number in E.164 format (e.g.\r\n     *     +16505550101).\r\n     * @param applicationVerifier\r\n     */\r\n    signInWithPhoneNumber(\r\n      phoneNumber: string,\r\n      applicationVerifier: firebase.auth.ApplicationVerifier,\r\n    ): Promise<firebase.auth.ConfirmationResult>;\r\n    /**\r\n     * Asynchronously signs in using an email and sign-in email link. If no link\r\n     * is passed, the link is inferred from the current URL.\r\n     *\r\n     * Fails with an error if the email address is invalid or OTP in email link\r\n     * expires.\r\n     *\r\n     * Note: Confirm the link is a sign-in email link before calling this method\r\n     * {@link firebase.auth.Auth.isSignInWithEmailLink}.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/expired-action-code</dt>\r\n     * <dd>Thrown if OTP in email link expires.</dd>\r\n     * <dt>auth/invalid-email</dt>\r\n     * <dd>Thrown if the email address is not valid.</dd>\r\n     * <dt>auth/user-disabled</dt>\r\n     * <dd>Thrown if the user corresponding to the given email has been\r\n     *     disabled.</dd>\r\n     * </dl>\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * firebase.auth().signInWithEmailLink(email, emailLink)\r\n     *     .catch(function(error) {\r\n     *       // Some error occurred, you can inspect the code: error.code\r\n     *       // Common errors could be invalid email and invalid or expired OTPs.\r\n     *     });\r\n     * ```\r\n     *\r\n     * @param email The email account to sign in with.\r\n     * @param emailLink The optional link which contains the OTP needed\r\n     *     to complete the sign in with email link. If not specified, the current\r\n     *     URL is used instead.\r\n     */\r\n    signInWithEmailLink(\r\n      email: string,\r\n      emailLink?: string,\r\n    ): Promise<firebase.auth.UserCredential>;\r\n    /**\r\n     * Authenticates a Firebase client using a popup-based OAuth authentication\r\n     * flow.\r\n     *\r\n     * If succeeds, returns the signed in user along with the provider's credential.\r\n     * If sign in was unsuccessful, returns an error object containing additional\r\n     * information about the error.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/account-exists-with-different-credential</dt>\r\n     * <dd>Thrown if there already exists an account with the email address\r\n     *     asserted by the credential. Resolve this by calling\r\n     *     {@link firebase.auth.Auth.fetchSignInMethodsForEmail} with the error.email\r\n     *     and then asking the user to sign in using one of the returned providers.\r\n     *     Once the user is signed in, the original credential retrieved from the\r\n     *     error.credential can be linked to the user with\r\n     *     {@link firebase.User.linkWithCredential} to prevent the user from signing\r\n     *     in again to the original provider via popup or redirect. If you are using\r\n     *     redirects for sign in, save the credential in session storage and then\r\n     *     retrieve on redirect and repopulate the credential using for example\r\n     *     {@link firebase.auth.GoogleAuthProvider.credential} depending on the\r\n     *     credential provider id and complete the link.</dd>\r\n     * <dt>auth/auth-domain-config-required</dt>\r\n     * <dd>Thrown if authDomain configuration is not provided when calling\r\n     *     firebase.initializeApp(). Check Firebase Console for instructions on\r\n     *     determining and passing that field.</dd>\r\n     * <dt>auth/cancelled-popup-request</dt>\r\n     * <dd>Thrown if successive popup operations are triggered. Only one popup\r\n     *     request is allowed at one time. All the popups would fail with this error\r\n     *     except for the last one.</dd>\r\n     * <dt>auth/operation-not-allowed</dt>\r\n     * <dd>Thrown if the type of account corresponding to the credential\r\n     *     is not enabled. Enable the account type in the Firebase Console, under\r\n     *     the Auth tab.</dd>\r\n     * <dt>auth/operation-not-supported-in-this-environment</dt>\r\n     * <dd>Thrown if this operation is not supported in the environment your\r\n     *     application is running on. \"location.protocol\" must be http or https.\r\n     *     </dd>\r\n     * <dt>auth/popup-blocked</dt>\r\n     * <dd>Thrown if the popup was blocked by the browser, typically when this\r\n     *     operation is triggered outside of a click handler.</dd>\r\n     * <dt>auth/popup-closed-by-user</dt>\r\n     * <dd>Thrown if the popup window is closed by the user without completing the\r\n     *     sign in to the provider.</dd>\r\n     * <dt>auth/unauthorized-domain</dt>\r\n     * <dd>Thrown if the app domain is not authorized for OAuth operations for your\r\n     *     Firebase project. Edit the list of authorized domains from the Firebase\r\n     *     console.</dd>\r\n     * </dl>\r\n     *\r\n     * This method does not work in a Node.js environment.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Creates the provider object.\r\n     * var provider = new firebase.auth.FacebookAuthProvider();\r\n     * // You can add additional scopes to the provider:\r\n     * provider.addScope('email');\r\n     * provider.addScope('user_friends');\r\n     * // Sign in with popup:\r\n     * auth.signInWithPopup(provider).then(function(result) {\r\n     *   // The firebase.User instance:\r\n     *   var user = result.user;\r\n     *   // The Facebook firebase.auth.AuthCredential containing the Facebook\r\n     *   // access token:\r\n     *   var credential = result.credential;\r\n     * }, function(error) {\r\n     *   // The provider's account email, can be used in case of\r\n     *   // auth/account-exists-with-different-credential to fetch the providers\r\n     *   // linked to the email:\r\n     *   var email = error.email;\r\n     *   // The provider's credential:\r\n     *   var credential = error.credential;\r\n     *   // In case of auth/account-exists-with-different-credential error,\r\n     *   // you can fetch the providers using this:\r\n     *   if (error.code === 'auth/account-exists-with-different-credential') {\r\n     *     auth.fetchSignInMethodsForEmail(email).then(function(providers) {\r\n     *       // The returned 'providers' is a list of the available providers\r\n     *       // linked to the email address. Please refer to the guide for a more\r\n     *       // complete explanation on how to recover from this error.\r\n     *     });\r\n     *   }\r\n     * });\r\n     * ```\r\n     *\r\n     * @param provider The provider to authenticate.\r\n     *     The provider has to be an OAuth provider. Non-OAuth providers like {@link\r\n     *     firebase.auth.EmailAuthProvider} will throw an error.\r\n     */\r\n    signInWithPopup(\r\n      provider: firebase.auth.AuthProvider,\r\n    ): Promise<firebase.auth.UserCredential>;\r\n    /**\r\n     * Authenticates a Firebase client using a full-page redirect flow. To handle\r\n     * the results and errors for this operation, refer to {@link\r\n     * firebase.auth.Auth.getRedirectResult}.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/auth-domain-config-required</dt>\r\n     * <dd>Thrown if authDomain configuration is not provided when calling\r\n     *     firebase.initializeApp(). Check Firebase Console for instructions on\r\n     *     determining and passing that field.</dd>\r\n     * <dt>auth/operation-not-supported-in-this-environment</dt>\r\n     * <dd>Thrown if this operation is not supported in the environment your\r\n     *     application is running on. \"location.protocol\" must be http or https.\r\n     *     </dd>\r\n     * <dt>auth/unauthorized-domain</dt>\r\n     * <dd>Thrown if the app domain is not authorized for OAuth operations for your\r\n     *     Firebase project. Edit the list of authorized domains from the Firebase\r\n     *     console.</dd>\r\n     * </dl>\r\n     *\r\n     * This method does not work in a Node.js environment.\r\n     *\r\n     * @param provider The provider to authenticate.\r\n     *     The provider has to be an OAuth provider. Non-OAuth providers like {@link\r\n     *     firebase.auth.EmailAuthProvider} will throw an error.\r\n     */\r\n    signInWithRedirect(provider: firebase.auth.AuthProvider): Promise<void>;\r\n    /**\r\n     * Signs out the current user.\r\n     */\r\n    signOut(): Promise<void>;\r\n    /**\r\n     * The current Auth instance's tenant ID. This is a readable/writable\r\n     * property. When you set the tenant ID of an Auth instance, all future\r\n     * sign-in/sign-up operations will pass this tenant ID and sign in or\r\n     * sign up users to the specified tenant project.\r\n     * When set to null, users are signed in to the parent project. By default,\r\n     * this is set to null.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Set the tenant ID on Auth instance.\r\n     * firebase.auth().tenantId = ‘TENANT_PROJECT_ID’;\r\n     *\r\n     * // All future sign-in request now include tenant ID.\r\n     * firebase.auth().signInWithEmailAndPassword(email, password)\r\n     *   .then(function(result) {\r\n     *     // result.user.tenantId should be ‘TENANT_PROJECT_ID’.\r\n     *   }).catch(function(error) {\r\n     *     // Handle error.\r\n     *   });\r\n     * ```\r\n     */\r\n    tenantId: string | null;\r\n    /**\r\n     * Asynchronously sets the provided user as `currentUser` on the current Auth\r\n     * instance. A new instance copy of the user provided will be made and set as\r\n     * `currentUser`.\r\n     *\r\n     * This will trigger {@link firebase.auth.Auth.onAuthStateChanged} and\r\n     * {@link firebase.auth.Auth.onIdTokenChanged} listeners like other sign in\r\n     * methods.\r\n     *\r\n     * The operation fails with an error if the user to be updated belongs to a\r\n     * different Firebase project.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/invalid-user-token</dt>\r\n     * <dd>Thrown if the user to be updated belongs to a different Firebase\r\n     *     project.</dd>\r\n     * <dt>auth/user-token-expired</dt>\r\n     * <dd>Thrown if the token of the user to be updated is expired.</dd>\r\n     * <dt>auth/null-user</dt>\r\n     * <dd>Thrown if the user to be updated is null.</dd>\r\n     * <dt>auth/tenant-id-mismatch</dt>\r\n     * <dd>Thrown if the provided user's tenant ID does not match the\r\n     *     underlying Auth instance's configured tenant ID</dd>\r\n     * </dl>\r\n     */\r\n    updateCurrentUser(user: firebase.User | null): Promise<void>;\r\n    /**\r\n     * Sets the current language to the default device/browser preference.\r\n     */\r\n    useDeviceLanguage(): void;\r\n    /**\r\n     * Modify this Auth instance to communicate with the Firebase Auth emulator.  This must be\r\n     * called synchronously immediately following the first call to `firebase.auth()`.  Do not use\r\n     * with production credentials as emulator traffic is not encrypted.\r\n     *\r\n     * @param url The URL at which the emulator is running (eg, 'http://localhost:9099')\r\n     */\r\n    useEmulator(url: string): void;\r\n    /**\r\n     * Checks a password reset code sent to the user by email or other out-of-band\r\n     * mechanism.\r\n     *\r\n     * Returns the user's email address if valid.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/expired-action-code</dt>\r\n     * <dd>Thrown if the password reset code has expired.</dd>\r\n     * <dt>auth/invalid-action-code</dt>\r\n     * <dd>Thrown if the password reset code is invalid. This can happen if the code\r\n     *     is malformed or has already been used.</dd>\r\n     * <dt>auth/user-disabled</dt>\r\n     * <dd>Thrown if the user corresponding to the given password reset code has\r\n     *     been disabled.</dd>\r\n     * <dt>auth/user-not-found</dt>\r\n     * <dd>Thrown if there is no user corresponding to the password reset code. This\r\n     *     may have happened if the user was deleted between when the code was\r\n     *     issued and when this method was called.</dd>\r\n     * </dl>\r\n     *\r\n     * @param code A verification code sent to the user.\r\n     */\r\n    verifyPasswordResetCode(code: string): Promise<string>;\r\n  }\r\n\r\n  /**\r\n   * Interface that represents the credentials returned by an auth provider.\r\n   * Implementations specify the details about each auth provider's credential\r\n   * requirements.\r\n   *\r\n   */\r\n  abstract class AuthCredential {\r\n    /**\r\n     * The authentication provider ID for the credential.\r\n     * For example, 'facebook.com', or 'google.com'.\r\n     */\r\n    providerId: string;\r\n    /**\r\n     * The authentication sign in method for the credential.\r\n     * For example, 'password', or 'emailLink. This corresponds to the sign-in\r\n     * method identifier as returned in\r\n     * {@link firebase.auth.Auth.fetchSignInMethodsForEmail}.\r\n     */\r\n    signInMethod: string;\r\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     */\r\n    toJSON(): Object;\r\n    /**\r\n     * Static method to deserialize a JSON representation of an object into an\r\n     * {@link firebase.auth.AuthCredential}. Input can be either Object or the\r\n     * stringified representation of the object. When string is provided,\r\n     * JSON.parse would be called first. If the JSON input does not represent\r\n     * an`AuthCredential`, null is returned.\r\n     * @param json The plain object representation of an\r\n     *     AuthCredential.\r\n     */\r\n    static fromJSON(json: Object | string): AuthCredential | null;\r\n  }\r\n\r\n  /**\r\n   * Interface that represents the OAuth credentials returned by an OAuth\r\n   * provider. Implementations specify the details about each auth provider's\r\n   * credential requirements.\r\n   *\r\n   */\r\n  class OAuthCredential extends AuthCredential {\r\n    private constructor();\r\n    /**\r\n     * The OAuth ID token associated with the credential if it belongs to an\r\n     * OIDC provider, such as `google.com`.\r\n     */\r\n    idToken?: string;\r\n    /**\r\n     * The OAuth access token associated with the credential if it belongs to\r\n     * an OAuth provider, such as `facebook.com`, `twitter.com`, etc.\r\n     */\r\n    accessToken?: string;\r\n    /**\r\n     * The OAuth access token secret associated with the credential if it\r\n     * belongs to an OAuth 1.0 provider, such as `twitter.com`.\r\n     */\r\n    secret?: string;\r\n  }\r\n\r\n  /**\r\n   * Interface that represents an auth provider.\r\n   */\r\n  interface AuthProvider {\r\n    providerId: string;\r\n  }\r\n\r\n  /**\r\n   * A result from a phone number sign-in, link, or reauthenticate call.\r\n   */\r\n  interface ConfirmationResult {\r\n    /**\r\n     * Finishes a phone number sign-in, link, or reauthentication, given the code\r\n     * that was sent to the user's mobile device.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/invalid-verification-code</dt>\r\n     * <dd>Thrown if the verification code is not valid.</dd>\r\n     * <dt>auth/missing-verification-code</dt>\r\n     * <dd>Thrown if the verification code is missing.</dd>\r\n     * </dl>\r\n     */\r\n    confirm(verificationCode: string): Promise<firebase.auth.UserCredential>;\r\n    /**\r\n     * The phone number authentication operation's verification ID. This can be used\r\n     * along with the verification code to initialize a phone auth credential.\r\n     */\r\n    verificationId: string;\r\n  }\r\n\r\n  /**\r\n   * Email and password auth provider implementation.\r\n   *\r\n   * To authenticate: {@link firebase.auth.Auth.createUserWithEmailAndPassword}\r\n   * and {@link firebase.auth.Auth.signInWithEmailAndPassword}.\r\n   */\r\n  class EmailAuthProvider extends EmailAuthProvider_Instance {\r\n    static PROVIDER_ID: string;\r\n    /**\r\n     * This corresponds to the sign-in method identifier as returned in\r\n     * {@link firebase.auth.Auth.fetchSignInMethodsForEmail}.\r\n     */\r\n    static EMAIL_PASSWORD_SIGN_IN_METHOD: string;\r\n    /**\r\n     * This corresponds to the sign-in method identifier as returned in\r\n     * {@link firebase.auth.Auth.fetchSignInMethodsForEmail}.\r\n     */\r\n    static EMAIL_LINK_SIGN_IN_METHOD: string;\r\n    /**\r\n     * @example\r\n     * ```javascript\r\n     * var cred = firebase.auth.EmailAuthProvider.credential(\r\n     *     email,\r\n     *     password\r\n     * );\r\n     * ```\r\n     *\r\n     * @param email Email address.\r\n     * @param password User account password.\r\n     * @return The auth provider credential.\r\n     */\r\n    static credential(\r\n      email: string,\r\n      password: string,\r\n    ): firebase.auth.AuthCredential;\r\n    /**\r\n     * Initialize an `EmailAuthProvider` credential using an email and an email link\r\n     * after a sign in with email link operation.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var cred = firebase.auth.EmailAuthProvider.credentialWithLink(\r\n     *     email,\r\n     *     emailLink\r\n     * );\r\n     * ```\r\n     *\r\n     * @param email Email address.\r\n     * @param emailLink Sign-in email link.\r\n     * @return The auth provider credential.\r\n     */\r\n    static credentialWithLink(\r\n      email: string,\r\n      emailLink: string,\r\n    ): firebase.auth.AuthCredential;\r\n  }\r\n  /**\r\n   * @hidden\r\n   */\r\n  class EmailAuthProvider_Instance implements firebase.auth.AuthProvider {\r\n    providerId: string;\r\n  }\r\n\r\n  /**\r\n   * An authentication error.\r\n   * For method-specific error codes, refer to the specific methods in the\r\n   * documentation. For common error codes, check the reference below. Use{@link\r\n   * firebase.auth.Error.code} to get the specific error code. For a detailed\r\n   * message, use {@link firebase.auth.Error.message}.\r\n   * Errors with the code <strong>auth/account-exists-with-different-credential\r\n   * </strong> will have the additional fields <strong>email</strong> and <strong>\r\n   * credential</strong> which are needed to provide a way to resolve these\r\n   * specific errors. Refer to {@link firebase.auth.Auth.signInWithPopup} for more\r\n   * information.\r\n   *\r\n   * <h4>Common Error Codes</h4>\r\n   * <dl>\r\n   * <dt>auth/app-deleted</dt>\r\n   * <dd>Thrown if the instance of FirebaseApp has been deleted.</dd>\r\n   * <dt>auth/app-not-authorized</dt>\r\n   * <dd>Thrown if the app identified by the domain where it's hosted, is not\r\n   *     authorized to use Firebase Authentication with the provided API key.\r\n   *     Review your key configuration in the Google API console.</dd>\r\n   * <dt>auth/argument-error</dt>\r\n   * <dd>Thrown if a method is called with incorrect arguments.</dd>\r\n   * <dt>auth/invalid-api-key</dt>\r\n   * <dd>Thrown if the provided API key is invalid. Please check that you have\r\n   *     copied it correctly from the Firebase Console.</dd>\r\n   * <dt>auth/invalid-user-token</dt>\r\n   * <dd>Thrown if the user's credential is no longer valid. The user must sign in\r\n   *     again.</dd>\r\n   * <dt>auth/invalid-tenant-id</dt>\r\n   * <dd>Thrown if the tenant ID provided is invalid.</dd>\r\n   * <dt>auth/network-request-failed</dt>\r\n   * <dd>Thrown if a network error (such as timeout, interrupted connection or\r\n   *     unreachable host) has occurred.</dd>\r\n   * <dt>auth/operation-not-allowed</dt>\r\n   * <dd>Thrown if you have not enabled the provider in the Firebase Console. Go\r\n   *     to the Firebase Console for your project, in the Auth section and the\r\n   *     <strong>Sign in Method</strong> tab and configure the provider.</dd>\r\n   * <dt>auth/requires-recent-login</dt>\r\n   * <dd>Thrown if the user's last sign-in time does not meet the security\r\n   *     threshold. Use {@link firebase.User.reauthenticateWithCredential} to\r\n   *     resolve. This does not apply if the user is anonymous.</dd>\r\n   * <dt>auth/too-many-requests</dt>\r\n   * <dd>Thrown if requests are blocked from a device due to unusual activity.\r\n   *     Trying again after some delay would unblock.</dd>\r\n   * <dt>auth/unauthorized-domain</dt>\r\n   * <dd>Thrown if the app domain is not authorized for OAuth operations for your\r\n   *     Firebase project. Edit the list of authorized domains from the Firebase\r\n   *     console.</dd>\r\n   * <dt>auth/user-disabled</dt>\r\n   * <dd>Thrown if the user account has been disabled by an administrator.\r\n   *     Accounts can be enabled or disabled in the Firebase Console, the Auth\r\n   *     section and Users subsection.</dd>\r\n   * <dt>auth/user-token-expired</dt>\r\n   * <dd>Thrown if the user's credential has expired. This could also be thrown if\r\n   *     a user has been deleted. Prompting the user to sign in again should\r\n   *     resolve this for either case.</dd>\r\n   * <dt>auth/web-storage-unsupported</dt>\r\n   * <dd>Thrown if the browser does not support web storage or if the user\r\n   *     disables them.</dd>\r\n   * </dl>\r\n   */\r\n  interface Error {\r\n    name: string;\r\n    /**\r\n     * Unique error code.\r\n     */\r\n    code: string;\r\n    /**\r\n     * Complete error message.\r\n     */\r\n    message: string;\r\n  }\r\n\r\n  /**\r\n   * The account conflict error.\r\n   * Refer to {@link firebase.auth.Auth.signInWithPopup} for more information.\r\n   *\r\n   * <h4>Common Error Codes</h4>\r\n   * <dl>\r\n   * <dt>auth/account-exists-with-different-credential</dt>\r\n   * <dd>Thrown if there already exists an account with the email address\r\n   *     asserted by the credential. Resolve this by calling\r\n   *     {@link firebase.auth.Auth.fetchSignInMethodsForEmail} with the error.email\r\n   *     and then asking the user to sign in using one of the returned providers.\r\n   *     Once the user is signed in, the original credential retrieved from the\r\n   *     error.credential can be linked to the user with\r\n   *     {@link firebase.User.linkWithCredential} to prevent the user from signing\r\n   *     in again to the original provider via popup or redirect. If you are using\r\n   *     redirects for sign in, save the credential in session storage and then\r\n   *     retrieve on redirect and repopulate the credential using for example\r\n   *     {@link firebase.auth.GoogleAuthProvider.credential} depending on the\r\n   *     credential provider id and complete the link.</dd>\r\n   * <dt>auth/credential-already-in-use</dt>\r\n   * <dd>Thrown if the account corresponding to the credential already exists\r\n   *     among your users, or is already linked to a Firebase User.\r\n   *     For example, this error could be thrown if you are upgrading an anonymous\r\n   *     user to a Google user by linking a Google credential to it and the Google\r\n   *     credential used is already associated with an existing Firebase Google\r\n   *     user.\r\n   *     The fields <code>error.email</code>, <code>error.phoneNumber</code>, and\r\n   *     <code>error.credential</code> ({@link firebase.auth.AuthCredential})\r\n   *     may be provided, depending on the type of credential. You can recover\r\n   *     from this error by signing in with <code>error.credential</code> directly\r\n   *     via {@link firebase.auth.Auth.signInWithCredential}.</dd>\r\n   * <dt>auth/email-already-in-use</dt>\r\n   * <dd>Thrown if the email corresponding to the credential already exists\r\n   *     among your users. When thrown while linking a credential to an existing\r\n   *     user, an <code>error.email</code> and <code>error.credential</code>\r\n   *     ({@link firebase.auth.AuthCredential}) fields are also provided.\r\n   *     You have to link the credential to the existing user with that email if\r\n   *     you wish to continue signing in with that credential. To do so, call\r\n   *     {@link firebase.auth.Auth.fetchSignInMethodsForEmail}, sign in to\r\n   *     <code>error.email</code> via one of the providers returned and then\r\n   *     {@link firebase.User.linkWithCredential} the original credential to that\r\n   *     newly signed in user.</dd>\r\n   * </dl>\r\n   */\r\n  interface AuthError extends firebase.auth.Error {\r\n    /**\r\n     * The {@link firebase.auth.AuthCredential} that can be used to resolve the\r\n     * error.\r\n     */\r\n    credential?: firebase.auth.AuthCredential;\r\n    /**\r\n     * The email of the user's account used for sign-in/linking.\r\n     */\r\n    email?: string;\r\n    /**\r\n     * The phone number of the user's account used for sign-in/linking.\r\n     */\r\n    phoneNumber?: string;\r\n    /**\r\n     * The tenant ID being used for sign-in/linking. If you use\r\n     * {@link firebase.auth.Auth.signInWithRedirect} to sign in, you have to\r\n     * set the tenant ID on Auth instance again as the tenant ID is not\r\n     * persisted after redirection.\r\n     */\r\n    tenantId?: string;\r\n  }\r\n\r\n  /**\r\n   * The error thrown when the user needs to provide a second factor to sign in\r\n   * successfully.\r\n   * The error code for this error is <code>auth/multi-factor-auth-required</code>.\r\n   * This error provides a {@link firebase.auth.MultiFactorResolver} object,\r\n   * which you can use to get the second sign-in factor from the user.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * firebase.auth().signInWithEmailAndPassword()\r\n   *     .then(function(result) {\r\n   *       // User signed in. No 2nd factor challenge is needed.\r\n   *     })\r\n   *     .catch(function(error) {\r\n   *       if (error.code == 'auth/multi-factor-auth-required') {\r\n   *         var resolver = error.resolver;\r\n   *         var multiFactorHints = resolver.hints;\r\n   *       } else {\r\n   *         // Handle other errors.\r\n   *       }\r\n   *     });\r\n   *\r\n   * resolver.resolveSignIn(multiFactorAssertion)\r\n   *     .then(function(userCredential) {\r\n   *       // User signed in.\r\n   *     });\r\n   * ```\r\n   */\r\n  interface MultiFactorError extends firebase.auth.AuthError {\r\n    /**\r\n     * The multi-factor resolver to complete second factor sign-in.\r\n     */\r\n    resolver: firebase.auth.MultiFactorResolver;\r\n  }\r\n\r\n  /**\r\n   * Facebook auth provider.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Sign in using a redirect.\r\n   * firebase.auth().getRedirectResult().then(function(result) {\r\n   *   if (result.credential) {\r\n   *     // This gives you a Google Access Token.\r\n   *     var token = result.credential.accessToken;\r\n   *   }\r\n   *   var user = result.user;\r\n   * })\r\n   * // Start a sign in process for an unauthenticated user.\r\n   * var provider = new firebase.auth.FacebookAuthProvider();\r\n   * provider.addScope('user_birthday');\r\n   * firebase.auth().signInWithRedirect(provider);\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Sign in using a popup.\r\n   * var provider = new firebase.auth.FacebookAuthProvider();\r\n   * provider.addScope('user_birthday');\r\n   * firebase.auth().signInWithPopup(provider).then(function(result) {\r\n   *   // This gives you a Facebook Access Token.\r\n   *   var token = result.credential.accessToken;\r\n   *   // The signed-in user info.\r\n   *   var user = result.user;\r\n   * });\r\n   * ```\r\n   *\r\n   * @see {@link firebase.auth.Auth.onAuthStateChanged} to receive sign in state\r\n   * changes.\r\n   */\r\n  class FacebookAuthProvider extends FacebookAuthProvider_Instance {\r\n    static PROVIDER_ID: string;\r\n    /**\r\n     * This corresponds to the sign-in method identifier as returned in\r\n     * {@link firebase.auth.Auth.fetchSignInMethodsForEmail}.\r\n     */\r\n    static FACEBOOK_SIGN_IN_METHOD: string;\r\n    /**\r\n     * @example\r\n     * ```javascript\r\n     * var cred = firebase.auth.FacebookAuthProvider.credential(\r\n     *     // `event` from the Facebook auth.authResponseChange callback.\r\n     *     event.authResponse.accessToken\r\n     * );\r\n     * ```\r\n     *\r\n     * @param token Facebook access token.\r\n     */\r\n    static credential(token: string): firebase.auth.OAuthCredential;\r\n  }\r\n  /**\r\n   * @hidden\r\n   */\r\n  class FacebookAuthProvider_Instance implements firebase.auth.AuthProvider {\r\n    /**\r\n     * @param scope Facebook OAuth scope.\r\n     * @return The provider instance itself.\r\n     */\r\n    addScope(scope: string): firebase.auth.AuthProvider;\r\n    providerId: string;\r\n    /**\r\n     * Sets the OAuth custom parameters to pass in a Facebook OAuth request for\r\n     * popup and redirect sign-in operations.\r\n     * Valid parameters include 'auth_type', 'display' and 'locale'.\r\n     * For a detailed list, check the\r\n     * {@link https://goo.gl/pve4fo Facebook}\r\n     * documentation.\r\n     * Reserved required OAuth 2.0 parameters such as 'client_id', 'redirect_uri',\r\n     * 'scope', 'response_type' and 'state' are not allowed and will be ignored.\r\n     * @param customOAuthParameters The custom OAuth parameters to pass\r\n     *     in the OAuth request.\r\n     * @return The provider instance itself.\r\n     */\r\n    setCustomParameters(\r\n      customOAuthParameters: Object,\r\n    ): firebase.auth.AuthProvider;\r\n  }\r\n\r\n  /**\r\n   * GitHub auth provider.\r\n   *\r\n   * GitHub requires an OAuth 2.0 redirect, so you can either handle the redirect\r\n   * directly, or use the signInWithPopup handler:\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Using a redirect.\r\n   * firebase.auth().getRedirectResult().then(function(result) {\r\n   *   if (result.credential) {\r\n   *     // This gives you a GitHub Access Token.\r\n   *     var token = result.credential.accessToken;\r\n   *   }\r\n   *   var user = result.user;\r\n   * }).catch(function(error) {\r\n   *   // Handle Errors here.\r\n   *   var errorCode = error.code;\r\n   *   var errorMessage = error.message;\r\n   *   // The email of the user's account used.\r\n   *   var email = error.email;\r\n   *   // The firebase.auth.AuthCredential type that was used.\r\n   *   var credential = error.credential;\r\n   *   if (errorCode === 'auth/account-exists-with-different-credential') {\r\n   *     alert('You have signed up with a different provider for that email.');\r\n   *     // Handle linking here if your app allows it.\r\n   *   } else {\r\n   *     console.error(error);\r\n   *   }\r\n   * });\r\n   *\r\n   * // Start a sign in process for an unauthenticated user.\r\n   * var provider = new firebase.auth.GithubAuthProvider();\r\n   * provider.addScope('repo');\r\n   * firebase.auth().signInWithRedirect(provider);\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // With popup.\r\n   * var provider = new firebase.auth.GithubAuthProvider();\r\n   *  provider.addScope('repo');\r\n   *  firebase.auth().signInWithPopup(provider).then(function(result) {\r\n   *    // This gives you a GitHub Access Token.\r\n   *    var token = result.credential.accessToken;\r\n   *    // The signed-in user info.\r\n   *    var user = result.user;\r\n   *  }).catch(function(error) {\r\n   *    // Handle Errors here.\r\n   *    var errorCode = error.code;\r\n   *    var errorMessage = error.message;\r\n   *    // The email of the user's account used.\r\n   *    var email = error.email;\r\n   *    // The firebase.auth.AuthCredential type that was used.\r\n   *    var credential = error.credential;\r\n   *    if (errorCode === 'auth/account-exists-with-different-credential') {\r\n   *      alert('You have signed up with a different provider for that email.');\r\n   *      // Handle linking here if your app allows it.\r\n   *    } else {\r\n   *      console.error(error);\r\n   *    }\r\n   *  });\r\n   * ```\r\n   *\r\n   * @see {@link firebase.auth.Auth.onAuthStateChanged} to receive sign in state\r\n   * changes.\r\n   */\r\n  class GithubAuthProvider extends GithubAuthProvider_Instance {\r\n    static PROVIDER_ID: string;\r\n    /**\r\n     * This corresponds to the sign-in method identifier as returned in\r\n     * {@link firebase.auth.Auth.fetchSignInMethodsForEmail}.\r\n     */\r\n    static GITHUB_SIGN_IN_METHOD: string;\r\n    /**\r\n     * @example\r\n     * ```javascript\r\n     * var cred = firebase.auth.GithubAuthProvider.credential(\r\n     *     // `event` from the GitHub auth.authResponseChange callback.\r\n     *     event.authResponse.accessToken\r\n     * );\r\n     * ```\r\n     *\r\n     * @param token GitHub access token.\r\n     * @return {!firebase.auth.OAuthCredential} The auth provider credential.\r\n     */\r\n    static credential(token: string): firebase.auth.OAuthCredential;\r\n  }\r\n  /**\r\n   * @hidden\r\n   */\r\n  class GithubAuthProvider_Instance implements firebase.auth.AuthProvider {\r\n    /**\r\n     * @param scope GitHub OAuth scope.\r\n     * @return The provider instance itself.\r\n     */\r\n    addScope(scope: string): firebase.auth.AuthProvider;\r\n    providerId: string;\r\n    /**\r\n     * Sets the OAuth custom parameters to pass in a GitHub OAuth request for popup\r\n     * and redirect sign-in operations.\r\n     * Valid parameters include 'allow_signup'.\r\n     * For a detailed list, check the\r\n     * {@link https://developer.github.com/v3/oauth/ GitHub} documentation.\r\n     * Reserved required OAuth 2.0 parameters such as 'client_id', 'redirect_uri',\r\n     * 'scope', 'response_type' and 'state' are not allowed and will be ignored.\r\n     * @param customOAuthParameters The custom OAuth parameters to pass\r\n     *     in the OAuth request.\r\n     * @return The provider instance itself.\r\n     */\r\n    setCustomParameters(\r\n      customOAuthParameters: Object,\r\n    ): firebase.auth.AuthProvider;\r\n  }\r\n\r\n  /**\r\n   * Google auth provider.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Using a redirect.\r\n   * firebase.auth().getRedirectResult().then(function(result) {\r\n   *   if (result.credential) {\r\n   *     // This gives you a Google Access Token.\r\n   *     var token = result.credential.accessToken;\r\n   *   }\r\n   *   var user = result.user;\r\n   * });\r\n   *\r\n   * // Start a sign in process for an unauthenticated user.\r\n   * var provider = new firebase.auth.GoogleAuthProvider();\r\n   * provider.addScope('profile');\r\n   * provider.addScope('email');\r\n   * firebase.auth().signInWithRedirect(provider);\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Using a popup.\r\n   * var provider = new firebase.auth.GoogleAuthProvider();\r\n   * provider.addScope('profile');\r\n   * provider.addScope('email');\r\n   * firebase.auth().signInWithPopup(provider).then(function(result) {\r\n   *  // This gives you a Google Access Token.\r\n   *  var token = result.credential.accessToken;\r\n   *  // The signed-in user info.\r\n   *  var user = result.user;\r\n   * });\r\n   * ```\r\n   *\r\n   * @see {@link firebase.auth.Auth.onAuthStateChanged} to receive sign in state\r\n   * changes.\r\n   */\r\n  class GoogleAuthProvider extends GoogleAuthProvider_Instance {\r\n    static PROVIDER_ID: string;\r\n    /**\r\n     * This corresponds to the sign-in method identifier as returned in\r\n     * {@link firebase.auth.Auth.fetchSignInMethodsForEmail}.\r\n     */\r\n    static GOOGLE_SIGN_IN_METHOD: string;\r\n    /**\r\n     * Creates a credential for Google. At least one of ID token and access token\r\n     * is required.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // \\`googleUser\\` from the onsuccess Google Sign In callback.\r\n     * var credential = firebase.auth.GoogleAuthProvider.credential(\r\n                  googleUser.getAuthResponse().id_token);\r\n     * firebase.auth().signInWithCredential(credential)\r\n     * ```\r\n     * @param idToken Google ID token.\r\n     * @param accessToken Google access token.\r\n     * @return The auth provider credential.\r\n     */\r\n    static credential(\r\n      idToken?: string | null,\r\n      accessToken?: string | null,\r\n    ): firebase.auth.OAuthCredential;\r\n  }\r\n  /**\r\n   * @hidden\r\n   */\r\n  class GoogleAuthProvider_Instance implements firebase.auth.AuthProvider {\r\n    /**\r\n     * @param scope Google OAuth scope.\r\n     * @return The provider instance itself.\r\n     */\r\n    addScope(scope: string): firebase.auth.AuthProvider;\r\n    providerId: string;\r\n    /**\r\n     * Sets the OAuth custom parameters to pass in a Google OAuth request for popup\r\n     * and redirect sign-in operations.\r\n     * Valid parameters include 'hd', 'hl', 'include_granted_scopes', 'login_hint'\r\n     * and 'prompt'.\r\n     * For a detailed list, check the\r\n     * {@link https://goo.gl/Xo01Jm Google}\r\n     * documentation.\r\n     * Reserved required OAuth 2.0 parameters such as 'client_id', 'redirect_uri',\r\n     * 'scope', 'response_type' and 'state' are not allowed and will be ignored.\r\n     * @param customOAuthParameters The custom OAuth parameters to pass\r\n     *     in the OAuth request.\r\n     * @return The provider instance itself.\r\n     */\r\n    setCustomParameters(\r\n      customOAuthParameters: Object,\r\n    ): firebase.auth.AuthProvider;\r\n  }\r\n\r\n  /**\r\n   * Generic OAuth provider.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Using a redirect.\r\n   * firebase.auth().getRedirectResult().then(function(result) {\r\n   *   if (result.credential) {\r\n   *     // This gives you the OAuth Access Token for that provider.\r\n   *     var token = result.credential.accessToken;\r\n   *   }\r\n   *   var user = result.user;\r\n   * });\r\n   *\r\n   * // Start a sign in process for an unauthenticated user.\r\n   * var provider = new firebase.auth.OAuthProvider('google.com');\r\n   * provider.addScope('profile');\r\n   * provider.addScope('email');\r\n   * firebase.auth().signInWithRedirect(provider);\r\n   * ```\r\n   * @example\r\n   * ```javascript\r\n   * // Using a popup.\r\n   * var provider = new firebase.auth.OAuthProvider('google.com');\r\n   * provider.addScope('profile');\r\n   * provider.addScope('email');\r\n   * firebase.auth().signInWithPopup(provider).then(function(result) {\r\n   *  // This gives you the OAuth Access Token for that provider.\r\n   *  var token = result.credential.accessToken;\r\n   *  // The signed-in user info.\r\n   *  var user = result.user;\r\n   * });\r\n   * ```\r\n   *\r\n   * @see {@link firebase.auth.Auth.onAuthStateChanged} to receive sign in state\r\n   * changes.\r\n   * @param providerId The associated provider ID, such as `github.com`.\r\n   */\r\n  class OAuthProvider implements firebase.auth.AuthProvider {\r\n    constructor(providerId: string);\r\n    providerId: string;\r\n    /**\r\n     * @param scope Provider OAuth scope to add.\r\n     */\r\n    addScope(scope: string): firebase.auth.AuthProvider;\r\n    /**\r\n     * Creates a Firebase credential from a generic OAuth provider's access token or\r\n     * ID token. The raw nonce is required when an ID token with a nonce field is\r\n     * provided. The SHA-256 hash of the raw nonce must match the nonce field in\r\n     * the ID token.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // `googleUser` from the onsuccess Google Sign In callback.\r\n     * // Initialize a generate OAuth provider with a `google.com` providerId.\r\n     * var provider = new firebase.auth.OAuthProvider('google.com');\r\n     * var credential = provider.credential({\r\n     *   idToken: googleUser.getAuthResponse().id_token,\r\n     * });\r\n     * firebase.auth().signInWithCredential(credential)\r\n     * ```\r\n     *\r\n     * @param optionsOrIdToken Either the options object containing\r\n     *     the ID token, access token and raw nonce or the ID token string.\r\n     * @param accessToken The OAuth access token.\r\n     */\r\n    credential(\r\n      optionsOrIdToken: firebase.auth.OAuthCredentialOptions | string | null,\r\n      accessToken?: string,\r\n    ): firebase.auth.OAuthCredential;\r\n    /**\r\n     * Sets the OAuth custom parameters to pass in an OAuth request for popup\r\n     * and redirect sign-in operations.\r\n     * For a detailed list, check the\r\n     * reserved required OAuth 2.0 parameters such as `client_id`, `redirect_uri`,\r\n     * `scope`, `response_type` and `state` are not allowed and will be ignored.\r\n     * @param customOAuthParameters The custom OAuth parameters to pass\r\n     *     in the OAuth request.\r\n     */\r\n    setCustomParameters(\r\n      customOAuthParameters: Object,\r\n    ): firebase.auth.AuthProvider;\r\n  }\r\n\r\n  class SAMLAuthProvider implements firebase.auth.AuthProvider {\r\n    constructor(providerId: string);\r\n    providerId: string;\r\n  }\r\n\r\n  /**\r\n   * Interface representing ID token result obtained from\r\n   * {@link firebase.User.getIdTokenResult}. It contains the ID token JWT string\r\n   * and other helper properties for getting different data associated with the\r\n   * token as well as all the decoded payload claims.\r\n   *\r\n   * Note that these claims are not to be trusted as they are parsed client side.\r\n   * Only server side verification can guarantee the integrity of the token\r\n   * claims.\r\n   */\r\n  interface IdTokenResult {\r\n    /**\r\n     * The Firebase Auth ID token JWT string.\r\n     */\r\n    token: string;\r\n    /**\r\n     * The ID token expiration time formatted as a UTC string.\r\n     */\r\n    expirationTime: string;\r\n    /**\r\n     * The authentication time formatted as a UTC string. This is the time the\r\n     * user authenticated (signed in) and not the time the token was refreshed.\r\n     */\r\n    authTime: string;\r\n    /**\r\n     * The ID token issued at time formatted as a UTC string.\r\n     */\r\n    issuedAtTime: string;\r\n    /**\r\n     * The sign-in provider through which the ID token was obtained (anonymous,\r\n     * custom, phone, password, etc). Note, this does not map to provider IDs.\r\n     */\r\n    signInProvider: string | null;\r\n    /**\r\n     * The type of second factor associated with this session, provided the user\r\n     * was multi-factor authenticated (eg. phone, etc).\r\n     */\r\n    signInSecondFactor: string | null;\r\n    /**\r\n     * The entire payload claims of the ID token including the standard reserved\r\n     * claims as well as the custom claims.\r\n     */\r\n    claims: {\r\n      [key: string]: any;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Defines the options for initializing an\r\n   * {@link firebase.auth.OAuthCredential}. For ID tokens with nonce claim,\r\n   * the raw nonce has to also be provided.\r\n   */\r\n  interface OAuthCredentialOptions {\r\n    /**\r\n     * The OAuth ID token used to initialize the OAuthCredential.\r\n     */\r\n    idToken?: string;\r\n    /**\r\n     * The OAuth access token used to initialize the OAuthCredential.\r\n     */\r\n    accessToken?: string;\r\n    /**\r\n     * The raw nonce associated with the ID token. It is required when an ID token\r\n     * with a nonce field is provided. The SHA-256 hash of the raw nonce must match\r\n     * the nonce field in the ID token.\r\n     */\r\n    rawNonce?: string;\r\n  }\r\n\r\n  /**\r\n   * The base class for asserting ownership of a second factor. This is used to\r\n   * facilitate enrollment of a second factor on an existing user\r\n   * or sign-in of a user who already verified the first factor.\r\n   *\r\n   */\r\n  abstract class MultiFactorAssertion {\r\n    /**\r\n     * The identifier of the second factor.\r\n     */\r\n    factorId: string;\r\n  }\r\n\r\n  /**\r\n   * The class for asserting ownership of a phone second factor.\r\n   */\r\n  class PhoneMultiFactorAssertion extends firebase.auth.MultiFactorAssertion {\r\n    private constructor();\r\n  }\r\n\r\n  /**\r\n   * The class used to initialize {@link firebase.auth.PhoneMultiFactorAssertion}.\r\n   */\r\n  class PhoneMultiFactorGenerator {\r\n    private constructor();\r\n    /**\r\n     * The identifier of the phone second factor: `phone`.\r\n     */\r\n    static FACTOR_ID: string;\r\n    /**\r\n     * Initializes the {@link firebase.auth.PhoneMultiFactorAssertion} to confirm ownership\r\n     * of the phone second factor.\r\n     */\r\n    static assertion(\r\n      phoneAuthCredential: firebase.auth.PhoneAuthCredential,\r\n    ): firebase.auth.PhoneMultiFactorAssertion;\r\n  }\r\n\r\n  /**\r\n   * A structure containing the information of a second factor entity.\r\n   */\r\n  interface MultiFactorInfo {\r\n    /**\r\n     * The multi-factor enrollment ID.\r\n     */\r\n    uid: string;\r\n    /**\r\n     * The user friendly name of the current second factor.\r\n     */\r\n    displayName?: string | null;\r\n    /**\r\n     * The enrollment date of the second factor formatted as a UTC string.\r\n     */\r\n    enrollmentTime: string;\r\n    /**\r\n     * The identifier of the second factor.\r\n     */\r\n    factorId: string;\r\n  }\r\n\r\n  /**\r\n   * The subclass of the MultiFactorInfo interface for phone number second factors.\r\n   * The factorId of this second factor is\r\n   * {@link firebase.auth.PhoneMultiFactorGenerator.FACTOR_ID}.\r\n   */\r\n  interface PhoneMultiFactorInfo extends firebase.auth.MultiFactorInfo {\r\n    /**\r\n     * The phone number associated with the current second factor.\r\n     */\r\n    phoneNumber: string;\r\n  }\r\n\r\n  /**\r\n   * The information required to verify the ownership of a phone number. The\r\n   * information that's required depends on whether you are doing single-factor\r\n   * sign-in, multi-factor enrollment or multi-factor sign-in.\r\n   */\r\n  type PhoneInfoOptions =\r\n    | firebase.auth.PhoneSingleFactorInfoOptions\r\n    | firebase.auth.PhoneMultiFactorEnrollInfoOptions\r\n    | firebase.auth.PhoneMultiFactorSignInInfoOptions;\r\n  /**\r\n   * The phone info options for single-factor sign-in. Only phone number is\r\n   * required.\r\n   */\r\n  interface PhoneSingleFactorInfoOptions {\r\n    phoneNumber: string;\r\n  }\r\n\r\n  /**\r\n   * The phone info options for multi-factor enrollment. Phone number and\r\n   * multi-factor session are required.\r\n   */\r\n  interface PhoneMultiFactorEnrollInfoOptions {\r\n    phoneNumber: string;\r\n    session: firebase.auth.MultiFactorSession;\r\n  }\r\n\r\n  /**\r\n   * The phone info options for multi-factor sign-in. Either multi-factor hint or\r\n   * multi-factor UID and multi-factor session are required.\r\n   */\r\n  interface PhoneMultiFactorSignInInfoOptions {\r\n    multiFactorHint?: firebase.auth.MultiFactorInfo;\r\n    multiFactorUid?: string;\r\n    session: firebase.auth.MultiFactorSession;\r\n  }\r\n\r\n  /**\r\n   * The class used to facilitate recovery from\r\n   * {@link firebase.auth.MultiFactorError} when a user needs to provide a second\r\n   * factor to sign in.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * firebase.auth().signInWithEmailAndPassword()\r\n   *     .then(function(result) {\r\n   *       // User signed in. No 2nd factor challenge is needed.\r\n   *     })\r\n   *     .catch(function(error) {\r\n   *       if (error.code == 'auth/multi-factor-auth-required') {\r\n   *         var resolver = error.resolver;\r\n   *         // Show UI to let user select second factor.\r\n   *         var multiFactorHints = resolver.hints;\r\n   *       } else {\r\n   *         // Handle other errors.\r\n   *       }\r\n   *     });\r\n   *\r\n   * // The enrolled second factors that can be used to complete\r\n   * // sign-in are returned in the `MultiFactorResolver.hints` list.\r\n   * // UI needs to be presented to allow the user to select a second factor\r\n   * // from that list.\r\n   *\r\n   * var selectedHint = // ; selected from multiFactorHints\r\n   * var phoneAuthProvider = new firebase.auth.PhoneAuthProvider();\r\n   * var phoneInfoOptions = {\r\n   *   multiFactorHint: selectedHint,\r\n   *   session: resolver.session\r\n   * };\r\n   * phoneAuthProvider.verifyPhoneNumber(\r\n   *   phoneInfoOptions,\r\n   *   appVerifier\r\n   * ).then(function(verificationId) {\r\n   *   // store verificationID and show UI to let user enter verification code.\r\n   * });\r\n   *\r\n   * // UI to enter verification code and continue.\r\n   * // Continue button click handler\r\n   * var phoneAuthCredential =\r\n   *     firebase.auth.PhoneAuthProvider.credential(verificationId, verificationCode);\r\n   * var multiFactorAssertion =\r\n   *     firebase.auth.PhoneMultiFactorGenerator.assertion(phoneAuthCredential);\r\n   * resolver.resolveSignIn(multiFactorAssertion)\r\n   *     .then(function(userCredential) {\r\n   *       // User signed in.\r\n   *     });\r\n   * ```\r\n   */\r\n  class MultiFactorResolver {\r\n    private constructor();\r\n    /**\r\n     * The Auth instance used to sign in with the first factor.\r\n     */\r\n    auth: firebase.auth.Auth;\r\n    /**\r\n     * The session identifier for the current sign-in flow, which can be used\r\n     * to complete the second factor sign-in.\r\n     */\r\n    session: firebase.auth.MultiFactorSession;\r\n    /**\r\n     * The list of hints for the second factors needed to complete the sign-in\r\n     * for the current session.\r\n     */\r\n    hints: firebase.auth.MultiFactorInfo[];\r\n    /**\r\n     * A helper function to help users complete sign in with a second factor\r\n     * using an {@link firebase.auth.MultiFactorAssertion} confirming the user\r\n     * successfully completed the second factor challenge.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/invalid-verification-code</dt>\r\n     * <dd>Thrown if the verification code is not valid.</dd>\r\n     * <dt>auth/missing-verification-code</dt>\r\n     * <dd>Thrown if the verification code is missing.</dd>\r\n     * <dt>auth/invalid-verification-id</dt>\r\n     * <dd>Thrown if the credential is a\r\n     *     {@link firebase.auth.PhoneAuthProvider.credential} and the verification\r\n     *     ID of the credential is not valid.</dd>\r\n     * <dt>auth/missing-verification-id</dt>\r\n     * <dd>Thrown if the verification ID is missing.</dd>\r\n     * <dt>auth/code-expired</dt>\r\n     * <dd>Thrown if the verification code has expired.</dd>\r\n     * <dt>auth/invalid-multi-factor-session</dt>\r\n     * <dd>Thrown if the request does not contain a valid proof of first factor\r\n     *     successful sign-in.</dd>\r\n     * <dt>auth/missing-multi-factor-session</dt>\r\n     * <dd>Thrown if The request is missing proof of first factor successful\r\n     *     sign-in.</dd>\r\n     * </dl>\r\n     *\r\n     * @param assertion The multi-factor assertion to resolve sign-in with.\r\n     * @return The promise that resolves with the user credential object.\r\n     */\r\n    resolveSignIn(\r\n      assertion: firebase.auth.MultiFactorAssertion,\r\n    ): Promise<firebase.auth.UserCredential>;\r\n  }\r\n\r\n  /**\r\n   * The multi-factor session object used for enrolling a second factor on a\r\n   * user or helping sign in an enrolled user with a second factor.\r\n   */\r\n  class MultiFactorSession {\r\n    private constructor();\r\n  }\r\n\r\n  /**\r\n   * Classes that represents the Phone Auth credentials returned by a\r\n   * {@link firebase.auth.PhoneAuthProvider}.\r\n   *\r\n   */\r\n  class PhoneAuthCredential extends AuthCredential {\r\n    private constructor();\r\n  }\r\n\r\n  /**\r\n   * Phone number auth provider.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // 'recaptcha-container' is the ID of an element in the DOM.\r\n   * var applicationVerifier = new firebase.auth.RecaptchaVerifier(\r\n   *     'recaptcha-container');\r\n   * var provider = new firebase.auth.PhoneAuthProvider();\r\n   * provider.verifyPhoneNumber('+16505550101', applicationVerifier)\r\n   *     .then(function(verificationId) {\r\n   *       var verificationCode = window.prompt('Please enter the verification ' +\r\n   *           'code that was sent to your mobile device.');\r\n   *       return firebase.auth.PhoneAuthProvider.credential(verificationId,\r\n   *           verificationCode);\r\n   *     })\r\n   *     .then(function(phoneCredential) {\r\n   *       return firebase.auth().signInWithCredential(phoneCredential);\r\n   *     });\r\n   * ```\r\n   * @param auth The Firebase Auth instance in which\r\n   *     sign-ins should occur. Uses the default Auth instance if unspecified.\r\n   */\r\n  class PhoneAuthProvider extends PhoneAuthProvider_Instance {\r\n    static PROVIDER_ID: string;\r\n    /**\r\n     * This corresponds to the sign-in method identifier as returned in\r\n     * {@link firebase.auth.Auth.fetchSignInMethodsForEmail}.\r\n     */\r\n    static PHONE_SIGN_IN_METHOD: string;\r\n    /**\r\n     * Creates a phone auth credential, given the verification ID from\r\n     * {@link firebase.auth.PhoneAuthProvider.verifyPhoneNumber} and the code\r\n     * that was sent to the user's mobile device.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/missing-verification-code</dt>\r\n     * <dd>Thrown if the verification code is missing.</dd>\r\n     * <dt>auth/missing-verification-id</dt>\r\n     * <dd>Thrown if the verification ID is missing.</dd>\r\n     * </dl>\r\n     *\r\n     * @param verificationId The verification ID returned from\r\n     *     {@link firebase.auth.PhoneAuthProvider.verifyPhoneNumber}.\r\n     * @param verificationCode The verification code sent to the user's\r\n     *     mobile device.\r\n     * @return The auth provider credential.\r\n     */\r\n    static credential(\r\n      verificationId: string,\r\n      verificationCode: string,\r\n    ): firebase.auth.AuthCredential;\r\n  }\r\n  /**\r\n   * @hidden\r\n   */\r\n  class PhoneAuthProvider_Instance implements firebase.auth.AuthProvider {\r\n    constructor(auth?: firebase.auth.Auth | null);\r\n    providerId: string;\r\n    /**\r\n     * Starts a phone number authentication flow by sending a verification code to\r\n     * the given phone number. Returns an ID that can be passed to\r\n     * {@link firebase.auth.PhoneAuthProvider.credential} to identify this flow.\r\n     *\r\n     * For abuse prevention, this method also requires a\r\n     * {@link firebase.auth.ApplicationVerifier}. The Firebase Auth SDK includes\r\n     * a reCAPTCHA-based implementation, {@link firebase.auth.RecaptchaVerifier}.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/captcha-check-failed</dt>\r\n     * <dd>Thrown if the reCAPTCHA response token was invalid, expired, or if\r\n     *     this method was called from a non-whitelisted domain.</dd>\r\n     * <dt>auth/invalid-phone-number</dt>\r\n     * <dd>Thrown if the phone number has an invalid format.</dd>\r\n     * <dt>auth/missing-phone-number</dt>\r\n     * <dd>Thrown if the phone number is missing.</dd>\r\n     * <dt>auth/quota-exceeded</dt>\r\n     * <dd>Thrown if the SMS quota for the Firebase project has been exceeded.</dd>\r\n     * <dt>auth/user-disabled</dt>\r\n     * <dd>Thrown if the user corresponding to the given phone number has been\r\n     *     disabled.</dd>\r\n     * <dt>auth/maximum-second-factor-count-exceeded</dt>\r\n     * <dd>Thrown if The maximum allowed number of second factors on a user\r\n     *     has been exceeded.</dd>\r\n     * <dt>auth/second-factor-already-in-use</dt>\r\n     * <dd>Thrown if the second factor is already enrolled on this account.</dd>\r\n     * <dt>auth/unsupported-first-factor</dt>\r\n     * <dd>Thrown if the first factor being used to sign in is not supported.</dd>\r\n     * <dt>auth/unverified-email</dt>\r\n     * <dd>Thrown if the email of the account is not verified.</dd>\r\n     * </dl>\r\n     *\r\n     * @param phoneInfoOptions The user's {@link firebase.auth.PhoneInfoOptions}.\r\n     *     The phone number should be in E.164 format (e.g. +16505550101).\r\n     * @param applicationVerifier\r\n     * @return A Promise for the verification ID.\r\n     */\r\n    verifyPhoneNumber(\r\n      phoneInfoOptions: firebase.auth.PhoneInfoOptions | string,\r\n      applicationVerifier: firebase.auth.ApplicationVerifier,\r\n    ): Promise<string>;\r\n  }\r\n\r\n  /**\r\n   * An {@link https://www.google.com/recaptcha/ reCAPTCHA}-based application\r\n   * verifier.\r\n   *\r\n   * This class does not work in a Node.js environment.\r\n   *\r\n   * @param container The reCAPTCHA container parameter. This\r\n   *     has different meaning depending on whether the reCAPTCHA is hidden or\r\n   *     visible. For a visible reCAPTCHA the container must be empty. If a string\r\n   *     is used, it has to correspond to an element ID. The corresponding element\r\n   *     must also must be in the DOM at the time of initialization.\r\n   * @param parameters The optional reCAPTCHA parameters. Check the\r\n   *     reCAPTCHA docs for a comprehensive list. All parameters are accepted\r\n   *     except for the sitekey. Firebase Auth backend provisions a reCAPTCHA for\r\n   *     each project and will configure this upon rendering. For an invisible\r\n   *     reCAPTCHA, a size key must have the value 'invisible'.\r\n   * @param app The corresponding Firebase app. If none is\r\n   *     provided, the default Firebase App instance is used. A Firebase App\r\n   *     instance must be initialized with an API key, otherwise an error will be\r\n   *     thrown.\r\n   */\r\n  class RecaptchaVerifier extends RecaptchaVerifier_Instance {}\r\n  /**\r\n   * @hidden\r\n   */\r\n  class RecaptchaVerifier_Instance\r\n    implements firebase.auth.ApplicationVerifier\r\n  {\r\n    constructor(\r\n      container: any | string,\r\n      parameters?: Object | null,\r\n      app?: firebase.app.App | null,\r\n    );\r\n    /**\r\n     * Clears the reCAPTCHA widget from the page and destroys the current instance.\r\n     */\r\n    clear(): void;\r\n    /**\r\n     * Renders the reCAPTCHA widget on the page.\r\n     * @return A Promise that resolves with the\r\n     *     reCAPTCHA widget ID.\r\n     */\r\n    render(): Promise<number>;\r\n    /**\r\n     * The application verifier type. For a reCAPTCHA verifier, this is 'recaptcha'.\r\n     */\r\n    type: string;\r\n    /**\r\n     * Waits for the user to solve the reCAPTCHA and resolves with the reCAPTCHA\r\n     * token.\r\n     * @return A Promise for the reCAPTCHA token.\r\n     */\r\n    verify(): Promise<string>;\r\n  }\r\n\r\n  /**\r\n   * Twitter auth provider.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Using a redirect.\r\n   * firebase.auth().getRedirectResult().then(function(result) {\r\n   *   if (result.credential) {\r\n   *     // For accessing the Twitter API.\r\n   *     var token = result.credential.accessToken;\r\n   *     var secret = result.credential.secret;\r\n   *   }\r\n   *   var user = result.user;\r\n   * });\r\n   *\r\n   * // Start a sign in process for an unauthenticated user.\r\n   * var provider = new firebase.auth.TwitterAuthProvider();\r\n   * firebase.auth().signInWithRedirect(provider);\r\n   * ```\r\n   * @example\r\n   * ```javascript\r\n   * // Using a popup.\r\n   * var provider = new firebase.auth.TwitterAuthProvider();\r\n   * firebase.auth().signInWithPopup(provider).then(function(result) {\r\n   *   // For accessing the Twitter API.\r\n   *   var token = result.credential.accessToken;\r\n   *   var secret = result.credential.secret;\r\n   *   // The signed-in user info.\r\n   *   var user = result.user;\r\n   * });\r\n   * ```\r\n   *\r\n   * @see {@link firebase.auth.Auth.onAuthStateChanged} to receive sign in state\r\n   * changes.\r\n   */\r\n  class TwitterAuthProvider extends TwitterAuthProvider_Instance {\r\n    static PROVIDER_ID: string;\r\n    /**\r\n     * This corresponds to the sign-in method identifier as returned in\r\n     * {@link firebase.auth.Auth.fetchSignInMethodsForEmail}.\r\n     *\r\n     */\r\n    static TWITTER_SIGN_IN_METHOD: string;\r\n    /**\r\n     * @param token Twitter access token.\r\n     * @param secret Twitter secret.\r\n     * @return The auth provider credential.\r\n     */\r\n    static credential(\r\n      token: string,\r\n      secret: string,\r\n    ): firebase.auth.OAuthCredential;\r\n  }\r\n  /**\r\n   * @hidden\r\n   */\r\n  class TwitterAuthProvider_Instance implements firebase.auth.AuthProvider {\r\n    providerId: string;\r\n    /**\r\n     * Sets the OAuth custom parameters to pass in a Twitter OAuth request for popup\r\n     * and redirect sign-in operations.\r\n     * Valid parameters include 'lang'.\r\n     * Reserved required OAuth 1.0 parameters such as 'oauth_consumer_key',\r\n     * 'oauth_token', 'oauth_signature', etc are not allowed and will be ignored.\r\n     * @param customOAuthParameters The custom OAuth parameters to pass\r\n     *     in the OAuth request.\r\n     * @return The provider instance itself.\r\n     */\r\n    setCustomParameters(\r\n      customOAuthParameters: Object,\r\n    ): firebase.auth.AuthProvider;\r\n  }\r\n\r\n  /**\r\n   * A structure containing a User, an AuthCredential, the operationType, and\r\n   * any additional user information that was returned from the identity provider.\r\n   * operationType could be 'signIn' for a sign-in operation, 'link' for a linking\r\n   * operation and 'reauthenticate' for a reauthentication operation.\r\n   */\r\n  type UserCredential = {\r\n    additionalUserInfo?: firebase.auth.AdditionalUserInfo | null;\r\n    credential: firebase.auth.AuthCredential | null;\r\n    operationType?: string | null;\r\n    user: firebase.User | null;\r\n  };\r\n\r\n  /**\r\n   * Interface representing a user's metadata.\r\n   */\r\n  interface UserMetadata {\r\n    creationTime?: string;\r\n    lastSignInTime?: string;\r\n  }\r\n}\r\n\r\n/**\r\n * The Analytics SDK does not work in a Node.js environment.\r\n */\r\ndeclare namespace firebase.analytics {\r\n  /**\r\n   * The Firebase Analytics service interface.\r\n   *\r\n   * Do not call this constructor directly. Instead, use\r\n   * {@link firebase.analytics `firebase.analytics()`}.\r\n   */\r\n  export interface Analytics {\r\n    /**\r\n     * The {@link firebase.app.App app} associated with the `Analytics` service\r\n     * instance.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var app = analytics.app;\r\n     * ```\r\n     */\r\n    app: firebase.app.App;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"add_payment_info\",\r\n      eventParams?: {\r\n        coupon?: EventParams[\"coupon\"];\r\n        currency?: EventParams[\"currency\"];\r\n        items?: EventParams[\"items\"];\r\n        payment_type?: EventParams[\"payment_type\"];\r\n        value?: EventParams[\"value\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"add_shipping_info\",\r\n      eventParams?: {\r\n        coupon?: EventParams[\"coupon\"];\r\n        currency?: EventParams[\"currency\"];\r\n        items?: EventParams[\"items\"];\r\n        shipping_tier?: EventParams[\"shipping_tier\"];\r\n        value?: EventParams[\"value\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"add_to_cart\" | \"add_to_wishlist\" | \"remove_from_cart\",\r\n      eventParams?: {\r\n        currency?: EventParams[\"currency\"];\r\n        value?: EventParams[\"value\"];\r\n        items?: EventParams[\"items\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"begin_checkout\",\r\n      eventParams?: {\r\n        currency?: EventParams[\"currency\"];\r\n        coupon?: EventParams[\"coupon\"];\r\n        value?: EventParams[\"value\"];\r\n        items?: EventParams[\"items\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"checkout_progress\",\r\n      eventParams?: {\r\n        currency?: EventParams[\"currency\"];\r\n        coupon?: EventParams[\"coupon\"];\r\n        value?: EventParams[\"value\"];\r\n        items?: EventParams[\"items\"];\r\n        checkout_step?: EventParams[\"checkout_step\"];\r\n        checkout_option?: EventParams[\"checkout_option\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * See\r\n     * {@link https://developers.google.com/analytics/devguides/collection/ga4/exceptions\r\n     * | Measure exceptions}.\r\n     */\r\n    logEvent(\r\n      eventName: \"exception\",\r\n      eventParams?: {\r\n        description?: EventParams[\"description\"];\r\n        fatal?: EventParams[\"fatal\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"generate_lead\",\r\n      eventParams?: {\r\n        value?: EventParams[\"value\"];\r\n        currency?: EventParams[\"currency\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"login\",\r\n      eventParams?: {\r\n        method?: EventParams[\"method\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * See\r\n     * {@link https://developers.google.com/analytics/devguides/collection/ga4/views\r\n     * | Page views}.\r\n     */\r\n    logEvent(\r\n      eventName: \"page_view\",\r\n      eventParams?: {\r\n        page_title?: string;\r\n        page_location?: string;\r\n        page_path?: string;\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"purchase\" | \"refund\",\r\n      eventParams?: {\r\n        value?: EventParams[\"value\"];\r\n        currency?: EventParams[\"currency\"];\r\n        transaction_id: EventParams[\"transaction_id\"];\r\n        tax?: EventParams[\"tax\"];\r\n        shipping?: EventParams[\"shipping\"];\r\n        items?: EventParams[\"items\"];\r\n        coupon?: EventParams[\"coupon\"];\r\n        affiliation?: EventParams[\"affiliation\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * See {@link https://firebase.google.com/docs/analytics/screenviews\r\n     * | Track Screenviews}.\r\n     */\r\n    logEvent(\r\n      eventName: \"screen_view\",\r\n      eventParams?: {\r\n        firebase_screen: EventParams[\"firebase_screen\"];\r\n        firebase_screen_class: EventParams[\"firebase_screen_class\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"search\" | \"view_search_results\",\r\n      eventParams?: {\r\n        search_term?: EventParams[\"search_term\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"select_content\",\r\n      eventParams?: {\r\n        content_type?: EventParams[\"content_type\"];\r\n        item_id?: EventParams[\"item_id\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"select_item\",\r\n      eventParams?: {\r\n        items?: EventParams[\"items\"];\r\n        item_list_name?: EventParams[\"item_list_name\"];\r\n        item_list_id?: EventParams[\"item_list_id\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"select_promotion\" | \"view_promotion\",\r\n      eventParams?: {\r\n        items?: EventParams[\"items\"];\r\n        promotion_id?: EventParams[\"promotion_id\"];\r\n        promotion_name?: EventParams[\"promotion_name\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"set_checkout_option\",\r\n      eventParams?: {\r\n        checkout_step?: EventParams[\"checkout_step\"];\r\n        checkout_option?: EventParams[\"checkout_option\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"share\",\r\n      eventParams?: {\r\n        method?: EventParams[\"method\"];\r\n        content_type?: EventParams[\"content_type\"];\r\n        item_id?: EventParams[\"item_id\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"sign_up\",\r\n      eventParams?: {\r\n        method?: EventParams[\"method\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"timing_complete\",\r\n      eventParams?: {\r\n        name: string;\r\n        value: number;\r\n        event_category?: string;\r\n        event_label?: string;\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"view_cart\" | \"view_item\",\r\n      eventParams?: {\r\n        currency?: EventParams[\"currency\"];\r\n        items?: EventParams[\"items\"];\r\n        value?: EventParams[\"value\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent(\r\n      eventName: \"view_item_list\",\r\n      eventParams?: {\r\n        items?: EventParams[\"items\"];\r\n        item_list_name?: EventParams[\"item_list_name\"];\r\n        item_list_id?: EventParams[\"item_list_id\"];\r\n        [key: string]: any;\r\n      },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sends analytics event with given `eventParams`. This method\r\n     * automatically associates this logged event with this Firebase web\r\n     * app instance on this device.\r\n     * List of recommended event parameters can be found in\r\n     * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n     * | the GA4 reference documentation}.\r\n     */\r\n    logEvent<T extends string>(\r\n      eventName: CustomEventName<T>,\r\n      eventParams?: { [key: string]: any },\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Use gtag 'config' command to set 'screen_name'.\r\n     *\r\n     * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n     * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n     */\r\n    setCurrentScreen(\r\n      screenName: string,\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Use gtag 'config' command to set 'user_id'.\r\n     */\r\n    setUserId(\r\n      id: string,\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Use gtag 'config' command to set all params specified.\r\n     */\r\n    setUserProperties(\r\n      properties: firebase.analytics.CustomParams,\r\n      options?: firebase.analytics.AnalyticsCallOptions,\r\n    ): void;\r\n\r\n    /**\r\n     * Sets whether analytics collection is enabled for this app on this device.\r\n     * window['ga-disable-analyticsId'] = true;\r\n     */\r\n    setAnalyticsCollectionEnabled(enabled: boolean): void;\r\n  }\r\n\r\n  export type CustomEventName<T> = T extends EventNameString ? never : T;\r\n\r\n  /**\r\n   * Additional options that can be passed to Firebase Analytics method\r\n   * calls such as `logEvent`, `setCurrentScreen`, etc.\r\n   */\r\n  export interface AnalyticsCallOptions {\r\n    /**\r\n     * If true, this config or event call applies globally to all\r\n     * analytics properties on the page.\r\n     */\r\n    global: boolean;\r\n  }\r\n\r\n  /**\r\n   * Specifies custom options for your Firebase Analytics instance.\r\n   * You must set these before initializing `firebase.analytics()`.\r\n   */\r\n  export interface SettingsOptions {\r\n    /** Sets custom name for `gtag` function. */\r\n    gtagName?: string;\r\n    /** Sets custom name for `dataLayer` array used by gtag. */\r\n    dataLayerName?: string;\r\n  }\r\n\r\n  /**\r\n   * Configures Firebase Analytics to use custom `gtag` or `dataLayer` names.\r\n   * Intended to be used if `gtag.js` script has been installed on\r\n   * this page independently of Firebase Analytics, and is using non-default\r\n   * names for either the `gtag` function or for `dataLayer`.\r\n   * Must be called before calling `firebase.analytics()` or it won't\r\n   * have any effect.\r\n   */\r\n  export function settings(settings: firebase.analytics.SettingsOptions): void;\r\n\r\n  /**\r\n   * Standard gtag.js control parameters.\r\n   * For more information, see\r\n   * {@link https://developers.google.com/gtagjs/reference/parameter\r\n   * the gtag.js documentation on parameters}.\r\n   */\r\n  export interface ControlParams {\r\n    groups?: string | string[];\r\n    send_to?: string | string[];\r\n    event_callback?: () => void;\r\n    event_timeout?: number;\r\n  }\r\n\r\n  /**\r\n   * Standard gtag.js event parameters.\r\n   * For more information, see\r\n   * {@link https://developers.google.com/gtagjs/reference/parameter\r\n   * the gtag.js documentation on parameters}.\r\n   */\r\n  export interface EventParams {\r\n    checkout_option?: string;\r\n    checkout_step?: number;\r\n    item_id?: string;\r\n    content_type?: string;\r\n    coupon?: string;\r\n    currency?: string;\r\n    description?: string;\r\n    fatal?: boolean;\r\n    items?: Item[];\r\n    method?: string;\r\n    number?: string;\r\n    promotions?: Promotion[];\r\n    screen_name?: string;\r\n    /**\r\n     * Firebase-specific. Use to log a `screen_name` to Firebase Analytics.\r\n     */\r\n    firebase_screen?: string;\r\n    /**\r\n     * Firebase-specific. Use to log a `screen_class` to Firebase Analytics.\r\n     */\r\n    firebase_screen_class?: string;\r\n    search_term?: string;\r\n    shipping?: Currency;\r\n    tax?: Currency;\r\n    transaction_id?: string;\r\n    value?: number;\r\n    event_label?: string;\r\n    event_category: string;\r\n    shipping_tier?: string;\r\n    item_list_id?: string;\r\n    item_list_name?: string;\r\n    promotion_id?: string;\r\n    promotion_name?: string;\r\n    payment_type?: string;\r\n    affiliation?: string;\r\n  }\r\n\r\n  /**\r\n   * Any custom params the user may pass to gtag.js.\r\n   */\r\n  export interface CustomParams {\r\n    [key: string]: any;\r\n  }\r\n\r\n  /**\r\n   * Type for standard gtag.js event names. `logEvent` also accepts any\r\n   * custom string and interprets it as a custom event name.\r\n   */\r\n  export type EventNameString =\r\n    | \"add_payment_info\"\r\n    | \"add_shipping_info\"\r\n    | \"add_to_cart\"\r\n    | \"add_to_wishlist\"\r\n    | \"begin_checkout\"\r\n    | \"checkout_progress\"\r\n    | \"exception\"\r\n    | \"generate_lead\"\r\n    | \"login\"\r\n    | \"page_view\"\r\n    | \"purchase\"\r\n    | \"refund\"\r\n    | \"remove_from_cart\"\r\n    | \"screen_view\"\r\n    | \"search\"\r\n    | \"select_content\"\r\n    | \"select_item\"\r\n    | \"select_promotion\"\r\n    | \"set_checkout_option\"\r\n    | \"share\"\r\n    | \"sign_up\"\r\n    | \"timing_complete\"\r\n    | \"view_cart\"\r\n    | \"view_item\"\r\n    | \"view_item_list\"\r\n    | \"view_promotion\"\r\n    | \"view_search_results\";\r\n\r\n  /**\r\n   * Enum of standard gtag.js event names provided for convenient\r\n   * developer usage. `logEvent` will also accept any custom string\r\n   * and interpret it as a custom event name.\r\n   */\r\n  export enum EventName {\r\n    ADD_PAYMENT_INFO = \"add_payment_info\",\r\n    ADD_SHIPPING_INFO = \"add_shipping_info\",\r\n    ADD_TO_CART = \"add_to_cart\",\r\n    ADD_TO_WISHLIST = \"add_to_wishlist\",\r\n    BEGIN_CHECKOUT = \"begin_checkout\",\r\n    /** @deprecated */\r\n    CHECKOUT_PROGRESS = \"checkout_progress\",\r\n    EXCEPTION = \"exception\",\r\n    GENERATE_LEAD = \"generate_lead\",\r\n    LOGIN = \"login\",\r\n    PAGE_VIEW = \"page_view\",\r\n    PURCHASE = \"purchase\",\r\n    REFUND = \"refund\",\r\n    REMOVE_FROM_CART = \"remove_from_cart\",\r\n    SCREEN_VIEW = \"screen_view\",\r\n    SEARCH = \"search\",\r\n    SELECT_CONTENT = \"select_content\",\r\n    SELECT_ITEM = \"select_item\",\r\n    SELECT_PROMOTION = \"select_promotion\",\r\n    /** @deprecated */\r\n    SET_CHECKOUT_OPTION = \"set_checkout_option\",\r\n    SHARE = \"share\",\r\n    SIGN_UP = \"sign_up\",\r\n    TIMING_COMPLETE = \"timing_complete\",\r\n    VIEW_CART = \"view_cart\",\r\n    VIEW_ITEM = \"view_item\",\r\n    VIEW_ITEM_LIST = \"view_item_list\",\r\n    VIEW_PROMOTION = \"view_promotion\",\r\n    VIEW_SEARCH_RESULTS = \"view_search_results\",\r\n  }\r\n\r\n  export type Currency = string | number;\r\n\r\n  export interface Item {\r\n    item_id?: string;\r\n    item_name?: string;\r\n    item_brand?: string;\r\n    item_category?: string;\r\n    item_category2?: string;\r\n    item_category3?: string;\r\n    item_category4?: string;\r\n    item_category5?: string;\r\n    item_variant?: string;\r\n    price?: Currency;\r\n    quantity?: number;\r\n    index?: number;\r\n    coupon?: string;\r\n    item_list_name?: string;\r\n    item_list_id?: string;\r\n    discount?: Currency;\r\n    affiliation?: string;\r\n    creative_name?: string;\r\n    creative_slot?: string;\r\n    promotion_id?: string;\r\n    promotion_name?: string;\r\n    location_id?: string;\r\n    /** @deprecated Use item_brand instead. */\r\n    brand?: string;\r\n    /** @deprecated Use item_category instead. */\r\n    category?: string;\r\n    /** @deprecated Use item_id instead. */\r\n    id?: string;\r\n    /** @deprecated Use item_name instead. */\r\n    name?: string;\r\n  }\r\n\r\n  /** @deprecated Use Item instead. */\r\n  export interface Promotion {\r\n    creative_name?: string;\r\n    creative_slot?: string;\r\n    id?: string;\r\n    name?: string;\r\n  }\r\n\r\n  /**\r\n   * An async function that returns true if current browser context supports initialization of analytics module\r\n   * (`firebase.analytics()`).\r\n   *\r\n   * Returns false otherwise.\r\n   *\r\n   *\r\n   */\r\n  function isSupported(): Promise<boolean>;\r\n}\r\n\r\ndeclare namespace firebase.auth.Auth {\r\n  type Persistence = string;\r\n  /**\r\n   * An enumeration of the possible persistence mechanism types.\r\n   */\r\n  var Persistence: {\r\n    /**\r\n     * Indicates that the state will be persisted even when the browser window is\r\n     * closed or the activity is destroyed in react-native.\r\n     */\r\n    LOCAL: Persistence;\r\n    /**\r\n     * Indicates that the state will only be stored in memory and will be cleared\r\n     * when the window or activity is refreshed.\r\n     */\r\n    NONE: Persistence;\r\n    /**\r\n     * Indicates that the state will only persist in current session/tab, relevant\r\n     * to web only, and will be cleared when the tab is closed.\r\n     */\r\n    SESSION: Persistence;\r\n  };\r\n}\r\n\r\ndeclare namespace firebase.User {\r\n  /**\r\n   * This is the interface that defines the multi-factor related properties and\r\n   * operations pertaining to a {@link firebase.User}.\r\n   */\r\n  interface MultiFactorUser {\r\n    /**\r\n     * Returns a list of the user's enrolled second factors.\r\n     */\r\n    enrolledFactors: firebase.auth.MultiFactorInfo[];\r\n    /**\r\n     * Enrolls a second factor as identified by the\r\n     * {@link firebase.auth.MultiFactorAssertion} for the current user.\r\n     * On resolution, the user tokens are updated to reflect the change in the\r\n     * JWT payload.\r\n     * Accepts an additional display name parameter used to identify the second\r\n     * factor to the end user.\r\n     * Recent re-authentication is required for this operation to succeed.\r\n     * On successful enrollment, existing Firebase sessions (refresh tokens) are\r\n     * revoked. When a new factor is enrolled, an email notification is sent\r\n     * to the user’s email.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/invalid-verification-code</dt>\r\n     * <dd>Thrown if the verification code is not valid.</dd>\r\n     * <dt>auth/missing-verification-code</dt>\r\n     * <dd>Thrown if the verification code is missing.</dd>\r\n     * <dt>auth/invalid-verification-id</dt>\r\n     * <dd>Thrown if the credential is a\r\n     *     {@link firebase.auth.PhoneAuthProvider.credential} and the verification\r\n     *     ID of the credential is not valid.</dd>\r\n     * <dt>auth/missing-verification-id</dt>\r\n     * <dd>Thrown if the verification ID is missing.</dd>\r\n     * <dt>auth/code-expired</dt>\r\n     * <dd>Thrown if the verification code has expired.</dd>\r\n     * <dt>auth/maximum-second-factor-count-exceeded</dt>\r\n     * <dd>Thrown if The maximum allowed number of second factors on a user\r\n     *     has been exceeded.</dd>\r\n     * <dt>auth/second-factor-already-in-use</dt>\r\n     * <dd>Thrown if the second factor is already enrolled on this account.</dd>\r\n     * <dt>auth/unsupported-first-factor</dt>\r\n     * <dd>Thrown if the first factor being used to sign in is not supported.</dd>\r\n     * <dt>auth/unverified-email</dt>\r\n     * <dd>Thrown if the email of the account is not verified.</dd>\r\n     * <dt>auth/requires-recent-login</dt>\r\n     * <dd>Thrown if the user's last sign-in time does not meet the security\r\n     *     threshold. Use {@link firebase.User.reauthenticateWithCredential} to\r\n     *     resolve.</dd>\r\n     * </dl>\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * firebase.auth().currentUser.multiFactor.getSession()\r\n     *     .then(function(multiFactorSession) {\r\n     *       // Send verification code\r\n     *     var phoneAuthProvider = new firebase.auth.PhoneAuthProvider();\r\n     *     var phoneInfoOptions = {\r\n     *       phoneNumber: phoneNumber,\r\n     *       session: multiFactorSession\r\n     *     };\r\n     *     return phoneAuthProvider.verifyPhoneNumber(\r\n     *         phoneInfoOptions, appVerifier);\r\n     *     }).then(function(verificationId) {\r\n     *       // Store verificationID and show UI to let user enter verification code.\r\n     *     });\r\n     *\r\n     * var phoneAuthCredential =\r\n     *     firebase.auth.PhoneAuthProvider.credential(verificationId, verificationCode);\r\n     * var multiFactorAssertion =\r\n     *     firebase.auth.PhoneMultiFactorGenerator.assertion(phoneAuthCredential);\r\n     * firebase.auth().currentUser.multiFactor.enroll(multiFactorAssertion)\r\n     *     .then(function() {\r\n     *       // Second factor enrolled.\r\n     *     });\r\n     * ```\r\n     *\r\n     * @param assertion The multi-factor assertion to enroll with.\r\n     * @param displayName The display name of the second factor.\r\n     */\r\n    enroll(\r\n      assertion: firebase.auth.MultiFactorAssertion,\r\n      displayName?: string | null,\r\n    ): Promise<void>;\r\n    /**\r\n     * Returns the session identifier for a second factor enrollment operation.\r\n     * This is used to identify the current user trying to enroll a second factor.\r\n     * @return The promise that resolves with the\r\n     * {@link firebase.auth.MultiFactorSession}.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/user-token-expired</dt>\r\n     * <dd>Thrown if the token of the user is expired.</dd>\r\n     * </dl>\r\n     */\r\n    getSession(): Promise<firebase.auth.MultiFactorSession>;\r\n    /**\r\n     * Unenrolls the specified second factor. To specify the factor to remove, pass\r\n     * a {@link firebase.auth.MultiFactorInfo} object\r\n     * (retrieved from <code>enrolledFactors()</code>)\r\n     * or the factor's UID string.\r\n     * Sessions are not revoked when the account is downgraded. An email\r\n     * notification is likely to be sent to the user notifying them of the change.\r\n     * Recent re-authentication is required for this operation to succeed.\r\n     * When an existing factor is unenrolled, an email notification is sent to the\r\n     * user’s email.\r\n     *\r\n     * <h4>Error Codes</h4>\r\n     * <dl>\r\n     * <dt>auth/multi-factor-info-not-found</dt>\r\n     * <dd>Thrown if the user does not have a second factor matching the\r\n     *     identifier provided.</dd>\r\n     * <dt>auth/requires-recent-login</dt>\r\n     * <dd>Thrown if the user's last sign-in time does not meet the security\r\n     *     threshold. Use {@link firebase.User.reauthenticateWithCredential} to\r\n     *     resolve.</dd>\r\n     * </dl>\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var options = firebase.auth().currentUser.multiFactor.enrolledFactors;\r\n     * // Present user the option to unenroll.\r\n     * return firebase.auth().currentUser.multiFactor.unenroll(options[i])\r\n     *   .then(function() {\r\n     *     // User successfully unenrolled selected factor.\r\n     *   }).catch(function(error) {\r\n     *     // Handler error.\r\n     *   });\r\n     * ```\r\n     *\r\n     * @param option The multi-factor option to unenroll.\r\n     */\r\n    unenroll(option: firebase.auth.MultiFactorInfo | string): Promise<void>;\r\n  }\r\n}\r\n\r\ndeclare namespace firebase.auth.ActionCodeInfo {\r\n  type Operation = string;\r\n  /**\r\n   * An enumeration of the possible email action types.\r\n   */\r\n  var Operation: {\r\n    /**\r\n     * The email link sign-in action.\r\n     */\r\n    EMAIL_SIGNIN: Operation;\r\n    /**\r\n     * The password reset action.\r\n     */\r\n    PASSWORD_RESET: Operation;\r\n    /**\r\n     * The email revocation action.\r\n     */\r\n    RECOVER_EMAIL: Operation;\r\n    /**\r\n     * The revert second factor addition email action.\r\n     */\r\n    REVERT_SECOND_FACTOR_ADDITION: Operation;\r\n    /**\r\n     * The verify and update email action.\r\n     */\r\n    VERIFY_AND_CHANGE_EMAIL: Operation;\r\n    /**\r\n     * The email verification action.\r\n     */\r\n    VERIFY_EMAIL: Operation;\r\n  };\r\n}\r\n\r\ndeclare namespace firebase.database {\r\n  /**\r\n   * A `DataSnapshot` contains data from a Database location.\r\n   *\r\n   * Any time you read data from the Database, you receive the data as a\r\n   * `DataSnapshot`. A `DataSnapshot` is passed to the event callbacks you attach\r\n   * with `on()` or `once()`. You can extract the contents of the snapshot as a\r\n   * JavaScript object by calling the `val()` method. Alternatively, you can\r\n   * traverse into the snapshot by calling `child()` to return child snapshots\r\n   * (which you could then call `val()` on).\r\n   *\r\n   * A `DataSnapshot` is an efficiently generated, immutable copy of the data at\r\n   * a Database location. It cannot be modified and will never change (to modify\r\n   * data, you always call the `set()` method on a `Reference` directly).\r\n   *\r\n   */\r\n  interface DataSnapshot {\r\n    /**\r\n     * Gets another `DataSnapshot` for the location at the specified relative path.\r\n     *\r\n     * Passing a relative path to the `child()` method of a DataSnapshot returns\r\n     * another `DataSnapshot` for the location at the specified relative path. The\r\n     * relative path can either be a simple child name (for example, \"ada\") or a\r\n     * deeper, slash-separated path (for example, \"ada/name/first\"). If the child\r\n     * location has no data, an empty `DataSnapshot` (that is, a `DataSnapshot`\r\n     * whose value is `null`) is returned.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Assume we have the following data in the Database:\r\n     * {\r\n     *   \"name\": {\r\n     *     \"first\": \"Ada\",\r\n     *     \"last\": \"Lovelace\"\r\n     *   }\r\n     * }\r\n     *\r\n     * // Test for the existence of certain keys within a DataSnapshot\r\n     * var ref = firebase.database().ref(\"users/ada\");\r\n     * ref.once(\"value\")\r\n     *   .then(function(snapshot) {\r\n     *     var name = snapshot.child(\"name\").val(); // {first:\"Ada\",last:\"Lovelace\"}\r\n     *     var firstName = snapshot.child(\"name/first\").val(); // \"Ada\"\r\n     *     var lastName = snapshot.child(\"name\").child(\"last\").val(); // \"Lovelace\"\r\n     *     var age = snapshot.child(\"age\").val(); // null\r\n     *   });\r\n     * ```\r\n     *\r\n     * @param path A relative path to the location of child data.\r\n     */\r\n    child(path: string): firebase.database.DataSnapshot;\r\n    /**\r\n     * Returns true if this `DataSnapshot` contains any data. It is slightly more\r\n     * efficient than using `snapshot.val() !== null`.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Assume we have the following data in the Database:\r\n     * {\r\n     *   \"name\": {\r\n     *     \"first\": \"Ada\",\r\n     *     \"last\": \"Lovelace\"\r\n     *   }\r\n     * }\r\n     *\r\n     * // Test for the existence of certain keys within a DataSnapshot\r\n     * var ref = firebase.database().ref(\"users/ada\");\r\n     * ref.once(\"value\")\r\n     *   .then(function(snapshot) {\r\n     *     var a = snapshot.exists();  // true\r\n     *     var b = snapshot.child(\"name\").exists(); // true\r\n     *     var c = snapshot.child(\"name/first\").exists(); // true\r\n     *     var d = snapshot.child(\"name/middle\").exists(); // false\r\n     *   });\r\n     * ```\r\n     */\r\n    exists(): boolean;\r\n    /**\r\n     * Exports the entire contents of the DataSnapshot as a JavaScript object.\r\n     *\r\n     * The `exportVal()` method is similar to `val()`, except priority information\r\n     * is included (if available), making it suitable for backing up your data.\r\n     *\r\n     * @return The DataSnapshot's contents as a JavaScript value (Object,\r\n     *   Array, string, number, boolean, or `null`).\r\n     */\r\n    exportVal(): any;\r\n    /**\r\n     * Enumerates the top-level children in the `DataSnapshot`.\r\n     *\r\n     * Because of the way JavaScript objects work, the ordering of data in the\r\n     * JavaScript object returned by `val()` is not guaranteed to match the ordering\r\n     * on the server nor the ordering of `child_added` events. That is where\r\n     * `forEach()` comes in handy. It guarantees the children of a `DataSnapshot`\r\n     * will be iterated in their query order.\r\n     *\r\n     * If no explicit `orderBy*()` method is used, results are returned\r\n     * ordered by key (unless priorities are used, in which case, results are\r\n     * returned by priority).\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Assume we have the following data in the Database:\r\n     * {\r\n     *   \"users\": {\r\n     *     \"ada\": {\r\n     *       \"first\": \"Ada\",\r\n     *       \"last\": \"Lovelace\"\r\n     *     },\r\n     *     \"alan\": {\r\n     *       \"first\": \"Alan\",\r\n     *       \"last\": \"Turing\"\r\n     *     }\r\n     *   }\r\n     * }\r\n     *\r\n     * // Loop through users in order with the forEach() method. The callback\r\n     * // provided to forEach() will be called synchronously with a DataSnapshot\r\n     * // for each child:\r\n     * var query = firebase.database().ref(\"users\").orderByKey();\r\n     * query.once(\"value\")\r\n     *   .then(function(snapshot) {\r\n     *     snapshot.forEach(function(childSnapshot) {\r\n     *       // key will be \"ada\" the first time and \"alan\" the second time\r\n     *       var key = childSnapshot.key;\r\n     *       // childData will be the actual contents of the child\r\n     *       var childData = childSnapshot.val();\r\n     *   });\r\n     * });\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // You can cancel the enumeration at any point by having your callback\r\n     * // function return true. For example, the following code sample will only\r\n     * // fire the callback function one time:\r\n     * var query = firebase.database().ref(\"users\").orderByKey();\r\n     * query.once(\"value\")\r\n     *   .then(function(snapshot) {\r\n     *     snapshot.forEach(function(childSnapshot) {\r\n     *       var key = childSnapshot.key; // \"ada\"\r\n     *\r\n     *       // Cancel enumeration\r\n     *       return true;\r\n     *   });\r\n     * });\r\n     * ```\r\n     *\r\n     * @param action A function\r\n     *   that will be called for each child DataSnapshot. The callback can return\r\n     *   true to cancel further enumeration.\r\n     * @return true if enumeration was canceled due to your callback\r\n     *   returning true.\r\n     */\r\n    forEach(\r\n      action: (a: firebase.database.IteratedDataSnapshot) => boolean | void,\r\n    ): boolean;\r\n    /**\r\n     * Gets the priority value of the data in this `DataSnapshot`.\r\n     *\r\n     * Applications need not use priority but can order collections by\r\n     * ordinary properties (see\r\n     * {@link\r\n     *  https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data\r\n     *  Sorting and filtering data}).\r\n     */\r\n    getPriority(): string | number | null;\r\n    /**\r\n     * Returns true if the specified child path has (non-null) data.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Assume we have the following data in the Database:\r\n     * {\r\n     *   \"name\": {\r\n     *     \"first\": \"Ada\",\r\n     *     \"last\": \"Lovelace\"\r\n     *   }\r\n     * }\r\n     *\r\n     * // Determine which child keys in DataSnapshot have data.\r\n     * var ref = firebase.database().ref(\"users/ada\");\r\n     * ref.once(\"value\")\r\n     *   .then(function(snapshot) {\r\n     *     var hasName = snapshot.hasChild(\"name\"); // true\r\n     *     var hasAge = snapshot.hasChild(\"age\"); // false\r\n     *   });\r\n     * ```\r\n     *\r\n     * @param path A relative path to the location of a potential child.\r\n     * @return `true` if data exists at the specified child path; else\r\n     *  `false`.\r\n     */\r\n    hasChild(path: string): boolean;\r\n    /**\r\n     * Returns whether or not the `DataSnapshot` has any non-`null` child\r\n     * properties.\r\n     *\r\n     * You can use `hasChildren()` to determine if a `DataSnapshot` has any\r\n     * children. If it does, you can enumerate them using `forEach()`. If it\r\n     * doesn't, then either this snapshot contains a primitive value (which can be\r\n     * retrieved with `val()`) or it is empty (in which case, `val()` will return\r\n     * `null`).\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Assume we have the following data in the Database:\r\n     * {\r\n     *   \"name\": {\r\n     *     \"first\": \"Ada\",\r\n     *     \"last\": \"Lovelace\"\r\n     *   }\r\n     * }\r\n     *\r\n     * var ref = firebase.database().ref(\"users/ada\");\r\n     * ref.once(\"value\")\r\n     *   .then(function(snapshot) {\r\n     *     var a = snapshot.hasChildren(); // true\r\n     *     var b = snapshot.child(\"name\").hasChildren(); // true\r\n     *     var c = snapshot.child(\"name/first\").hasChildren(); // false\r\n     *   });\r\n     * ```\r\n     *\r\n     * @return true if this snapshot has any children; else false.\r\n     */\r\n    hasChildren(): boolean;\r\n    /**\r\n     * The key (last part of the path) of the location of this `DataSnapshot`.\r\n     *\r\n     * The last token in a Database location is considered its key. For example,\r\n     * \"ada\" is the key for the /users/ada/ node. Accessing the key on any\r\n     * `DataSnapshot` will return the key for the location that generated it.\r\n     * However, accessing the key on the root URL of a Database will return `null`.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Assume we have the following data in the Database:\r\n     * {\r\n     *   \"name\": {\r\n     *     \"first\": \"Ada\",\r\n     *     \"last\": \"Lovelace\"\r\n     *   }\r\n     * }\r\n     *\r\n     * var ref = firebase.database().ref(\"users/ada\");\r\n     * ref.once(\"value\")\r\n     *   .then(function(snapshot) {\r\n     *     var key = snapshot.key; // \"ada\"\r\n     *     var childKey = snapshot.child(\"name/last\").key; // \"last\"\r\n     *   });\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var rootRef = firebase.database().ref();\r\n     * rootRef.once(\"value\")\r\n     *   .then(function(snapshot) {\r\n     *     var key = snapshot.key; // null\r\n     *     var childKey = snapshot.child(\"users/ada\").key; // \"ada\"\r\n     *   });\r\n     * ```\r\n     */\r\n    key: string | null;\r\n    /**\r\n     * Returns the number of child properties of this `DataSnapshot`.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Assume we have the following data in the Database:\r\n     * {\r\n     *   \"name\": {\r\n     *     \"first\": \"Ada\",\r\n     *     \"last\": \"Lovelace\"\r\n     *   }\r\n     * }\r\n     *\r\n     * var ref = firebase.database().ref(\"users/ada\");\r\n     * ref.once(\"value\")\r\n     *   .then(function(snapshot) {\r\n     *     var a = snapshot.numChildren(); // 1 (\"name\")\r\n     *     var b = snapshot.child(\"name\").numChildren(); // 2 (\"first\", \"last\")\r\n     *     var c = snapshot.child(\"name/first\").numChildren(); // 0\r\n     *   });\r\n     * ```\r\n     */\r\n    numChildren(): number;\r\n    /**\r\n     * Extracts a JavaScript value from a `DataSnapshot`.\r\n     *\r\n     * Depending on the data in a `DataSnapshot`, the `val()` method may return a\r\n     * scalar type (string, number, or boolean), an array, or an object. It may also\r\n     * return null, indicating that the `DataSnapshot` is empty (contains no data).\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Write and then read back a string from the Database.\r\n     * ref.set(\"hello\")\r\n     *   .then(function() {\r\n     *     return ref.once(\"value\");\r\n     *   })\r\n     *   .then(function(snapshot) {\r\n     *     var data = snapshot.val(); // data === \"hello\"\r\n     *   });\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Write and then read back a JavaScript object from the Database.\r\n     * ref.set({ name: \"Ada\", age: 36 })\r\n     *   .then(function() {\r\n     *    return ref.once(\"value\");\r\n     *   })\r\n     *   .then(function(snapshot) {\r\n     *     var data = snapshot.val();\r\n     *     // data is { \"name\": \"Ada\", \"age\": 36 }\r\n     *     // data.name === \"Ada\"\r\n     *     // data.age === 36\r\n     *   });\r\n     * ```\r\n     *\r\n     * @return The DataSnapshot's contents as a JavaScript value (Object,\r\n     *   Array, string, number, boolean, or `null`).\r\n     */\r\n    val(): any;\r\n    /**\r\n     * The `Reference` for the location that generated this `DataSnapshot`.\r\n     */\r\n    ref: firebase.database.Reference;\r\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     */\r\n    toJSON(): Object | null;\r\n  }\r\n\r\n  interface IteratedDataSnapshot extends DataSnapshot {\r\n    key: string; // key of the location of this snapshot.\r\n  }\r\n\r\n  /**\r\n   * The Firebase Database service interface.\r\n   *\r\n   * Do not call this constructor directly. Instead, use\r\n   * {@link firebase.database `firebase.database()`}.\r\n   *\r\n   * See\r\n   * {@link\r\n   *   https://firebase.google.com/docs/database/web/start/\r\n   *   Installation &amp; Setup in JavaScript}\r\n   * for a full guide on how to use the Firebase Database service.\r\n   */\r\n  interface Database {\r\n    /**\r\n     * The {@link firebase.app.App app} associated with the `Database` service\r\n     * instance.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var app = database.app;\r\n     * ```\r\n     */\r\n    app: firebase.app.App;\r\n    /**\r\n     * Additional methods for debugging and special cases.\r\n     *\r\n     */\r\n    INTERNAL: {\r\n      /**\r\n       * Force the use of WebSockets instead of long polling.\r\n       */\r\n      forceWebSockets: () => void;\r\n      /**\r\n       * Force the use of long polling instead of WebSockets. This will be ignored if the WebSocket protocol is used in `databaseURL`.\r\n       */\r\n      forceLongPolling: () => void;\r\n    };\r\n    /**\r\n     * Modify this instance to communicate with the Realtime Database emulator.\r\n     *\r\n     * <p>Note: This method must be called before performing any other operation.\r\n     *\r\n     * @param host the emulator host (ex: localhost)\r\n     * @param port the emulator port (ex: 8080)\r\n     * @param options.mockUserToken the mock auth token to use for unit testing Security Rules\r\n     */\r\n    useEmulator(\r\n      host: string,\r\n      port: number,\r\n      options?: {\r\n        mockUserToken?: EmulatorMockTokenOptions | string;\r\n      },\r\n    ): void;\r\n    /**\r\n     * Disconnects from the server (all Database operations will be completed\r\n     * offline).\r\n     *\r\n     * The client automatically maintains a persistent connection to the Database\r\n     * server, which will remain active indefinitely and reconnect when\r\n     * disconnected. However, the `goOffline()` and `goOnline()` methods may be used\r\n     * to control the client connection in cases where a persistent connection is\r\n     * undesirable.\r\n     *\r\n     * While offline, the client will no longer receive data updates from the\r\n     * Database. However, all Database operations performed locally will continue to\r\n     * immediately fire events, allowing your application to continue behaving\r\n     * normally. Additionally, each operation performed locally will automatically\r\n     * be queued and retried upon reconnection to the Database server.\r\n     *\r\n     * To reconnect to the Database and begin receiving remote events, see\r\n     * `goOnline()`.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * firebase.database().goOffline();\r\n     * ```\r\n     */\r\n    goOffline(): any;\r\n    /**\r\n     * Reconnects to the server and synchronizes the offline Database state\r\n     * with the server state.\r\n     *\r\n     * This method should be used after disabling the active connection with\r\n     * `goOffline()`. Once reconnected, the client will transmit the proper data\r\n     * and fire the appropriate events so that your client \"catches up\"\r\n     * automatically.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * firebase.database().goOnline();\r\n     * ```\r\n     */\r\n    goOnline(): any;\r\n    /**\r\n     * Returns a `Reference` representing the location in the Database\r\n     * corresponding to the provided path. If no path is provided, the `Reference`\r\n     * will point to the root of the Database.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Get a reference to the root of the Database\r\n     * var rootRef = firebase.database().ref();\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Get a reference to the /users/ada node\r\n     * var adaRef = firebase.database().ref(\"users/ada\");\r\n     * // The above is shorthand for the following operations:\r\n     * //var rootRef = firebase.database().ref();\r\n     * //var adaRef = rootRef.child(\"users/ada\");\r\n     * ```\r\n     *\r\n     * @param path Optional path representing the location the returned\r\n     *   `Reference` will point. If not provided, the returned `Reference` will\r\n     *   point to the root of the Database.\r\n     * @return If a path is provided, a `Reference`\r\n     *   pointing to the provided path. Otherwise, a `Reference` pointing to the\r\n     *   root of the Database.\r\n     */\r\n    ref(path?: string): firebase.database.Reference;\r\n    /**\r\n     * Returns a `Reference` representing the location in the Database\r\n     * corresponding to the provided Firebase URL.\r\n     *\r\n     * An exception is thrown if the URL is not a valid Firebase Database URL or it\r\n     * has a different domain than the current `Database` instance.\r\n     *\r\n     * Note that all query parameters (`orderBy`, `limitToLast`, etc.) are ignored\r\n     * and are not applied to the returned `Reference`.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Get a reference to the root of the Database\r\n     * var rootRef = firebase.database().ref(\"https://<DATABASE_NAME>.firebaseio.com\");\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Get a reference to the /users/ada node\r\n     * var adaRef = firebase.database().ref(\"https://<DATABASE_NAME>.firebaseio.com/users/ada\");\r\n     * ```\r\n     *\r\n     * @param url The Firebase URL at which the returned `Reference` will\r\n     *   point.\r\n     * @return A `Reference` pointing to the provided\r\n     *   Firebase URL.\r\n     */\r\n    refFromURL(url: string): firebase.database.Reference;\r\n  }\r\n\r\n  /**\r\n   * The `onDisconnect` class allows you to write or clear data when your client\r\n   * disconnects from the Database server. These updates occur whether your\r\n   * client disconnects cleanly or not, so you can rely on them to clean up data\r\n   * even if a connection is dropped or a client crashes.\r\n   *\r\n   * The `onDisconnect` class is most commonly used to manage presence in\r\n   * applications where it is useful to detect how many clients are connected and\r\n   * when other clients disconnect. See\r\n   * {@link\r\n   *   https://firebase.google.com/docs/database/web/offline-capabilities\r\n   *   Enabling Offline Capabilities in JavaScript} for more information.\r\n   *\r\n   * To avoid problems when a connection is dropped before the requests can be\r\n   * transferred to the Database server, these functions should be called before\r\n   * writing any data.\r\n   *\r\n   * Note that `onDisconnect` operations are only triggered once. If you want an\r\n   * operation to occur each time a disconnect occurs, you'll need to re-establish\r\n   * the `onDisconnect` operations each time you reconnect.\r\n   */\r\n  interface OnDisconnect {\r\n    /**\r\n     * Cancels all previously queued `onDisconnect()` set or update events for this\r\n     * location and all children.\r\n     *\r\n     * If a write has been queued for this location via a `set()` or `update()` at a\r\n     * parent location, the write at this location will be canceled, though writes\r\n     * to sibling locations will still occur.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var ref = firebase.database().ref(\"onlineState\");\r\n     * ref.onDisconnect().set(false);\r\n     * // ... sometime later\r\n     * ref.onDisconnect().cancel();\r\n     * ```\r\n     *\r\n     * @param onComplete An optional callback function that will\r\n     *   be called when synchronization to the server has completed. The callback\r\n     *   will be passed a single parameter: null for success, or an Error object\r\n     *   indicating a failure.\r\n     * @return Resolves when synchronization to the server\r\n     *   is complete.\r\n     */\r\n    cancel(onComplete?: (a: Error | null) => any): Promise<any>;\r\n    /**\r\n     * Ensures the data at this location is deleted when the client is disconnected\r\n     * (due to closing the browser, navigating to a new page, or network issues).\r\n     *\r\n     * @param onComplete An optional callback function that will\r\n     *   be called when synchronization to the server has completed. The callback\r\n     *   will be passed a single parameter: null for success, or an Error object\r\n     *   indicating a failure.\r\n     * @return Resolves when synchronization to the server\r\n     *   is complete.\r\n     */\r\n    remove(onComplete?: (a: Error | null) => any): Promise<any>;\r\n    /**\r\n     * Ensures the data at this location is set to the specified value when the\r\n     * client is disconnected (due to closing the browser, navigating to a new page,\r\n     * or network issues).\r\n     *\r\n     * `set()` is especially useful for implementing \"presence\" systems, where a\r\n     * value should be changed or cleared when a user disconnects so that they\r\n     * appear \"offline\" to other users. See\r\n     * {@link\r\n     *   https://firebase.google.com/docs/database/web/offline-capabilities\r\n     *   Enabling Offline Capabilities in JavaScript} for more information.\r\n     *\r\n     * Note that `onDisconnect` operations are only triggered once. If you want an\r\n     * operation to occur each time a disconnect occurs, you'll need to re-establish\r\n     * the `onDisconnect` operations each time.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var ref = firebase.database().ref(\"users/ada/status\");\r\n     * ref.onDisconnect().set(\"I disconnected!\");\r\n     * ```\r\n     *\r\n     * @param value The value to be written to this location on\r\n     *   disconnect (can be an object, array, string, number, boolean, or null).\r\n     * @param onComplete An optional callback function that\r\n     *   will be called when synchronization to the Database server has completed.\r\n     *   The callback will be passed a single parameter: null for success, or an\r\n     *   `Error` object indicating a failure.\r\n     * @return Resolves when synchronization to the\r\n     *   Database is complete.\r\n     */\r\n    set(value: any, onComplete?: (a: Error | null) => any): Promise<any>;\r\n    /**\r\n     * Ensures the data at this location is set to the specified value and priority\r\n     * when the client is disconnected (due to closing the browser, navigating to a\r\n     * new page, or network issues).\r\n     */\r\n    setWithPriority(\r\n      value: any,\r\n      priority: number | string | null,\r\n      onComplete?: (a: Error | null) => any,\r\n    ): Promise<any>;\r\n    /**\r\n     * Writes multiple values at this location when the client is disconnected (due\r\n     * to closing the browser, navigating to a new page, or network issues).\r\n     *\r\n     * The `values` argument contains multiple property-value pairs that will be\r\n     * written to the Database together. Each child property can either be a simple\r\n     * property (for example, \"name\") or a relative path (for example, \"name/first\")\r\n     * from the current location to the data to update.\r\n     *\r\n     * As opposed to the `set()` method, `update()` can be use to selectively update\r\n     * only the referenced properties at the current location (instead of replacing\r\n     * all the child properties at the current location).\r\n     *\r\n     * See more examples using the connected version of\r\n     * {@link firebase.database.Reference.update `update()`}.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var ref = firebase.database().ref(\"users/ada\");\r\n     * ref.update({\r\n     *    onlineState: true,\r\n     *    status: \"I'm online.\"\r\n     * });\r\n     * ref.onDisconnect().update({\r\n     *   onlineState: false,\r\n     *   status: \"I'm offline.\"\r\n     * });\r\n     * ```\r\n     *\r\n     * @param values Object containing multiple values.\r\n     * @param onComplete An optional callback function that will\r\n     *   be called when synchronization to the server has completed. The\r\n     *   callback will be passed a single parameter: null for success, or an Error\r\n     *   object indicating a failure.\r\n     * @return Resolves when synchronization to the\r\n     *   Database is complete.\r\n     */\r\n    update(values: Object, onComplete?: (a: Error | null) => any): Promise<any>;\r\n  }\r\n\r\n  type EventType =\r\n    | \"value\"\r\n    | \"child_added\"\r\n    | \"child_changed\"\r\n    | \"child_moved\"\r\n    | \"child_removed\";\r\n\r\n  /**\r\n   * A `Query` sorts and filters the data at a Database location so only a subset\r\n   * of the child data is included. This can be used to order a collection of\r\n   * data by some attribute (for example, height of dinosaurs) as well as to\r\n   * restrict a large list of items (for example, chat messages) down to a number\r\n   * suitable for synchronizing to the client. Queries are created by chaining\r\n   * together one or more of the filter methods defined here.\r\n   *\r\n   * Just as with a `Reference`, you can receive data from a `Query` by using the\r\n   * `on()` method. You will only receive events and `DataSnapshot`s for the\r\n   * subset of the data that matches your query.\r\n   *\r\n   * Read our documentation on\r\n   * {@link\r\n   *  https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data\r\n   *  Sorting and filtering data} for more information.\r\n   */\r\n  interface Query {\r\n    /**\r\n     * Creates a `Query` with the specified ending point.\r\n     *\r\n     * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n     * allows you to choose arbitrary starting and ending points for your queries.\r\n     *\r\n     * The ending point is inclusive, so children with exactly the specified value\r\n     * will be included in the query. The optional key argument can be used to\r\n     * further limit the range of the query. If it is specified, then children that\r\n     * have exactly the specified value must also have a key name less than or equal\r\n     * to the specified key.\r\n     *\r\n     * You can read more about `endAt()` in\r\n     * {@link\r\n     *  https://firebase.google.com/docs/database/web/lists-of-data#filtering_data\r\n     *  Filtering data}.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Find all dinosaurs whose names come before Pterodactyl lexicographically.\r\n     * // Include Pterodactyl in the result.\r\n     * var ref = firebase.database().ref(\"dinosaurs\");\r\n     * ref.orderByKey().endAt(\"pterodactyl\").on(\"child_added\", function(snapshot) {\r\n     *   console.log(snapshot.key);\r\n     * });\r\n     * ```\r\n     *\r\n     * @param value The value to end at. The argument\r\n     *   type depends on which `orderBy*()` function was used in this query.\r\n     *   Specify a value that matches the `orderBy*()` type. When used in\r\n     *   combination with `orderByKey()`, the value must be a string.\r\n     * @param key The child key to end at, among the children with the\r\n     *   previously specified priority. This argument is only allowed if ordering by\r\n     *   child, value, or priority.\r\n     */\r\n    endAt(\r\n      value: number | string | boolean | null,\r\n      key?: string,\r\n    ): firebase.database.Query;\r\n    /**\r\n     * Creates a `Query` with the specified ending point (exclusive).\r\n     *\r\n     * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n     * allows you to choose arbitrary starting and ending points for your queries.\r\n     *\r\n     * The ending point is exclusive. If only a value is provided, children\r\n     * with a value less than the specified value will be included in the query.\r\n     * If a key is specified, then children must have a value less than or equal\r\n     * to the specified value and a a key name less than the specified key.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Find all dinosaurs whose names come before Pterodactyl lexicographically.\r\n     * // Do not include Pterodactyl in the result.\r\n     * var ref = firebase.database().ref(\"dinosaurs\");\r\n     * ref.orderByKey().endBefore(\"pterodactyl\").on(\"child_added\", function(snapshot) {\r\n     *   console.log(snapshot.key);\r\n     * });\r\n     *\r\n     * @param value The value to end before. The argument\r\n     *   type depends on which `orderBy*()` function was used in this query.\r\n     *   Specify a value that matches the `orderBy*()` type. When used in\r\n     *   combination with `orderByKey()`, the value must be a string.\r\n     * @param key The child key to end before, among the children with the\r\n     *   previously specified priority. This argument is only allowed if ordering by\r\n     *   child, value, or priority.\r\n     */\r\n    endBefore(\r\n      value: number | string | boolean | null,\r\n      key?: string,\r\n    ): firebase.database.Query;\r\n    /**\r\n     * Creates a `Query` that includes children that match the specified value.\r\n     *\r\n     * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n     * allows you to choose arbitrary starting and ending points for your queries.\r\n     *\r\n     * The optional key argument can be used to further limit the range of the\r\n     * query. If it is specified, then children that have exactly the specified\r\n     * value must also have exactly the specified key as their key name. This can be\r\n     * used to filter result sets with many matches for the same value.\r\n     *\r\n     * You can read more about `equalTo()` in\r\n     * {@link\r\n     *  https://firebase.google.com/docs/database/web/lists-of-data#filtering_data\r\n     *  Filtering data}.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Find all dinosaurs whose height is exactly 25 meters.\r\n     * var ref = firebase.database().ref(\"dinosaurs\");\r\n     * ref.orderByChild(\"height\").equalTo(25).on(\"child_added\", function(snapshot) {\r\n     *   console.log(snapshot.key);\r\n     * });\r\n     * ```\r\n     *\r\n     * @param value The value to match for. The\r\n     *   argument type depends on which `orderBy*()` function was used in this\r\n     *   query. Specify a value that matches the `orderBy*()` type. When used in\r\n     *   combination with `orderByKey()`, the value must be a string.\r\n     * @param key The child key to start at, among the children with the\r\n     *   previously specified priority. This argument is only allowed if ordering by\r\n     *   child, value, or priority.\r\n     */\r\n    equalTo(\r\n      value: number | string | boolean | null,\r\n      key?: string,\r\n    ): firebase.database.Query;\r\n    /**\r\n     * Returns whether or not the current and provided queries represent the same\r\n     * location, have the same query parameters, and are from the same instance of\r\n     * `firebase.app.App`.\r\n     *\r\n     * Two `Reference` objects are equivalent if they represent the same location\r\n     * and are from the same instance of `firebase.app.App`.\r\n     *\r\n     * Two `Query` objects are equivalent if they represent the same location, have\r\n     * the same query parameters, and are from the same instance of\r\n     * `firebase.app.App`. Equivalent queries share the same sort order, limits, and\r\n     * starting and ending points.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var rootRef = firebase.database.ref();\r\n     * var usersRef = rootRef.child(\"users\");\r\n     *\r\n     * usersRef.isEqual(rootRef);  // false\r\n     * usersRef.isEqual(rootRef.child(\"users\"));  // true\r\n     * usersRef.parent.isEqual(rootRef);  // true\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var rootRef = firebase.database.ref();\r\n     * var usersRef = rootRef.child(\"users\");\r\n     * var usersQuery = usersRef.limitToLast(10);\r\n     *\r\n     * usersQuery.isEqual(usersRef);  // false\r\n     * usersQuery.isEqual(usersRef.limitToLast(10));  // true\r\n     * usersQuery.isEqual(rootRef.limitToLast(10));  // false\r\n     * usersQuery.isEqual(usersRef.orderByKey().limitToLast(10));  // false\r\n     * ```\r\n     *\r\n     * @param other The query to compare against.\r\n     * @return Whether or not the current and provided queries are\r\n     *   equivalent.\r\n     */\r\n    isEqual(other: firebase.database.Query | null): boolean;\r\n    /**\r\n     * Generates a new `Query` limited to the first specific number of children.\r\n     *\r\n     * The `limitToFirst()` method is used to set a maximum number of children to be\r\n     * synced for a given callback. If we set a limit of 100, we will initially only\r\n     * receive up to 100 `child_added` events. If we have fewer than 100 messages\r\n     * stored in our Database, a `child_added` event will fire for each message.\r\n     * However, if we have over 100 messages, we will only receive a `child_added`\r\n     * event for the first 100 ordered messages. As items change, we will receive\r\n     * `child_removed` events for each item that drops out of the active list so\r\n     * that the total number stays at 100.\r\n     *\r\n     * You can read more about `limitToFirst()` in\r\n     * {@link\r\n     *  https://firebase.google.com/docs/database/web/lists-of-data#filtering_data\r\n     *  Filtering data}.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Find the two shortest dinosaurs.\r\n     * var ref = firebase.database().ref(\"dinosaurs\");\r\n     * ref.orderByChild(\"height\").limitToFirst(2).on(\"child_added\", function(snapshot) {\r\n     *   // This will be called exactly two times (unless there are less than two\r\n     *   // dinosaurs in the Database).\r\n     *\r\n     *   // It will also get fired again if one of the first two dinosaurs is\r\n     *   // removed from the data set, as a new dinosaur will now be the second\r\n     *   // shortest.\r\n     *   console.log(snapshot.key);\r\n     * });\r\n     * ```\r\n     *\r\n     * @param limit The maximum number of nodes to include in this query.\r\n     */\r\n    limitToFirst(limit: number): firebase.database.Query;\r\n    /**\r\n     * Generates a new `Query` object limited to the last specific number of\r\n     * children.\r\n     *\r\n     * The `limitToLast()` method is used to set a maximum number of children to be\r\n     * synced for a given callback. If we set a limit of 100, we will initially only\r\n     * receive up to 100 `child_added` events. If we have fewer than 100 messages\r\n     * stored in our Database, a `child_added` event will fire for each message.\r\n     * However, if we have over 100 messages, we will only receive a `child_added`\r\n     * event for the last 100 ordered messages. As items change, we will receive\r\n     * `child_removed` events for each item that drops out of the active list so\r\n     * that the total number stays at 100.\r\n     *\r\n     * You can read more about `limitToLast()` in\r\n     * {@link\r\n     *  https://firebase.google.com/docs/database/web/lists-of-data#filtering_data\r\n     *  Filtering data}.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Find the two heaviest dinosaurs.\r\n     * var ref = firebase.database().ref(\"dinosaurs\");\r\n     * ref.orderByChild(\"weight\").limitToLast(2).on(\"child_added\", function(snapshot) {\r\n     *   // This callback will be triggered exactly two times, unless there are\r\n     *   // fewer than two dinosaurs stored in the Database. It will also get fired\r\n     *   // for every new, heavier dinosaur that gets added to the data set.\r\n     *   console.log(snapshot.key);\r\n     * });\r\n     * ```\r\n     *\r\n     * @param limit The maximum number of nodes to include in this query.\r\n     */\r\n    limitToLast(limit: number): firebase.database.Query;\r\n    /**\r\n     * Detaches a callback previously attached with `on()`.\r\n     *\r\n     * Detach a callback previously attached with `on()`. Note that if `on()` was\r\n     * called multiple times with the same eventType and callback, the callback\r\n     * will be called multiple times for each event, and `off()` must be called\r\n     * multiple times to remove the callback. Calling `off()` on a parent listener\r\n     * will not automatically remove listeners registered on child nodes, `off()`\r\n     * must also be called on any child listeners to remove the callback.\r\n     *\r\n     * If a callback is not specified, all callbacks for the specified eventType\r\n     * will be removed. Similarly, if no eventType is specified, all callbacks\r\n     * for the `Reference` will be removed.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var onValueChange = function(dataSnapshot) {  ... };\r\n     * ref.on('value', onValueChange);\r\n     * ref.child('meta-data').on('child_added', onChildAdded);\r\n     * // Sometime later...\r\n     * ref.off('value', onValueChange);\r\n     *\r\n     * // You must also call off() for any child listeners on ref\r\n     * // to cancel those callbacks\r\n     * ref.child('meta-data').off('child_added', onValueAdded);\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Or you can save a line of code by using an inline function\r\n     * // and on()'s return value.\r\n     * var onValueChange = ref.on('value', function(dataSnapshot) { ... });\r\n     * // Sometime later...\r\n     * ref.off('value', onValueChange);\r\n     * ```\r\n     *\r\n     * @param eventType One of the following strings: \"value\",\r\n     *   \"child_added\", \"child_changed\", \"child_removed\", or \"child_moved.\" If\r\n     *   omitted, all callbacks for the `Reference` will be removed.\r\n     * @param callback The callback function that was passed to `on()` or\r\n     *   `undefined` to remove all callbacks.\r\n     * @param context The context that was passed to `on()`.\r\n     */\r\n    off(\r\n      eventType?: EventType,\r\n      callback?: (a: firebase.database.DataSnapshot, b?: string | null) => any,\r\n      context?: Object | null,\r\n    ): void;\r\n\r\n    /**\r\n     * Gets the most up-to-date result for this query.\r\n     *\r\n     * @return A promise which resolves to the resulting DataSnapshot if\r\n     * a value is available, or rejects if the client is unable to return\r\n     * a value (e.g., if the server is unreachable and there is nothing\r\n     * cached).\r\n     */\r\n    get(): Promise<DataSnapshot>;\r\n\r\n    /**\r\n     * Listens for data changes at a particular location.\r\n     *\r\n     * This is the primary way to read data from a Database. Your callback\r\n     * will be triggered for the initial data and again whenever the data changes.\r\n     * Use `off( )` to stop receiving updates. See\r\n     * {@link https://firebase.google.com/docs/database/web/retrieve-data\r\n     *   Retrieve Data on the Web}\r\n     * for more details.\r\n     *\r\n     * <h4>value event</h4>\r\n     *\r\n     * This event will trigger once with the initial data stored at this location,\r\n     * and then trigger again each time the data changes. The `DataSnapshot` passed\r\n     * to the callback will be for the location at which `on()` was called. It\r\n     * won't trigger until the entire contents has been synchronized. If the\r\n     * location has no data, it will be triggered with an empty `DataSnapshot`\r\n     * (`val()` will return `null`).\r\n     *\r\n     * <h4>child_added event</h4>\r\n     *\r\n     * This event will be triggered once for each initial child at this location,\r\n     * and it will be triggered again every time a new child is added. The\r\n     * `DataSnapshot` passed into the callback will reflect the data for the\r\n     * relevant child. For ordering purposes, it is passed a second argument which\r\n     * is a string containing the key of the previous sibling child by sort order,\r\n     * or `null` if it is the first child.\r\n     *\r\n     * <h4>child_removed event</h4>\r\n     *\r\n     * This event will be triggered once every time a child is removed. The\r\n     * `DataSnapshot` passed into the callback will be the old data for the child\r\n     * that was removed. A child will get removed when either:\r\n     *\r\n     * - a client explicitly calls `remove()` on that child or one of its ancestors\r\n     * - a client calls `set(null)` on that child or one of its ancestors\r\n     * - that child has all of its children removed\r\n     * - there is a query in effect which now filters out the child (because it's\r\n     *   sort order changed or the max limit was hit)\r\n     *\r\n     * <h4>child_changed event</h4>\r\n     *\r\n     * This event will be triggered when the data stored in a child (or any of its\r\n     * descendants) changes. Note that a single `child_changed` event may represent\r\n     * multiple changes to the child. The `DataSnapshot` passed to the callback will\r\n     * contain the new child contents. For ordering purposes, the callback is also\r\n     * passed a second argument which is a string containing the key of the previous\r\n     * sibling child by sort order, or `null` if it is the first child.\r\n     *\r\n     * <h4>child_moved event</h4>\r\n     *\r\n     * This event will be triggered when a child's sort order changes such that its\r\n     * position relative to its siblings changes. The `DataSnapshot` passed to the\r\n     * callback will be for the data of the child that has moved. It is also passed\r\n     * a second argument which is a string containing the key of the previous\r\n     * sibling child by sort order, or `null` if it is the first child.\r\n     *\r\n     * @example **Handle a new value:**\r\n     * ```javascript\r\n     * ref.on('value', function(dataSnapshot) {\r\n     *   ...\r\n     * });\r\n     * ```\r\n     *\r\n     * @example **Handle a new child:**\r\n     * ```javascript\r\n     * ref.on('child_added', function(childSnapshot, prevChildKey) {\r\n     *   ...\r\n     * });\r\n     * ```\r\n     *\r\n     * @example **Handle child removal:**\r\n     * ```javascript\r\n     * ref.on('child_removed', function(oldChildSnapshot) {\r\n     *   ...\r\n     * });\r\n     * ```\r\n     *\r\n     * @example **Handle child data changes:**\r\n     * ```javascript\r\n     * ref.on('child_changed', function(childSnapshot, prevChildKey) {\r\n     *   ...\r\n     * });\r\n     * ```\r\n     *\r\n     * @example **Handle child ordering changes:**\r\n     * ```javascript\r\n     * ref.on('child_moved', function(childSnapshot, prevChildKey) {\r\n     *   ...\r\n     * });\r\n     * ```\r\n     *\r\n     * @param eventType One of the following strings: \"value\",\r\n     *   \"child_added\", \"child_changed\", \"child_removed\", or \"child_moved.\"\r\n     * @param callback A\r\n     *   callback that fires when the specified event occurs. The callback will be\r\n     *   passed a DataSnapshot. For ordering purposes, \"child_added\",\r\n     *   \"child_changed\", and \"child_moved\" will also be passed a string containing\r\n     *   the key of the previous child, by sort order, or `null` if it is the\r\n     *   first child.\r\n     * @param cancelCallbackOrContext An optional\r\n     *   callback that will be notified if your event subscription is ever canceled\r\n     *   because your client does not have permission to read this data (or it had\r\n     *   permission but has now lost it). This callback will be passed an `Error`\r\n     *   object indicating why the failure occurred.\r\n     * @param context If provided, this object will be used as `this`\r\n     *   when calling your callback(s).\r\n     * @return The provided\r\n     *   callback function is returned unmodified. This is just for convenience if\r\n     *   you want to pass an inline function to `on()` but store the callback\r\n     *   function for later passing to `off()`.\r\n     */\r\n    on(\r\n      eventType: EventType,\r\n      callback: (a: firebase.database.DataSnapshot, b?: string | null) => any,\r\n      cancelCallbackOrContext?: ((a: Error) => any) | Object | null,\r\n      context?: Object | null,\r\n    ): (a: firebase.database.DataSnapshot | null, b?: string | null) => any;\r\n\r\n    /**\r\n     * Listens for exactly one event of the specified event type, and then stops\r\n     * listening.\r\n     *\r\n     * This is equivalent to calling {@link firebase.database.Query.on `on()`}, and\r\n     * then calling {@link firebase.database.Query.off `off()`} inside the callback\r\n     * function. See {@link firebase.database.Query.on `on()`} for details on the\r\n     * event types.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Basic usage of .once() to read the data located at ref.\r\n     * ref.once('value')\r\n     *   .then(function(dataSnapshot) {\r\n     *     // handle read data.\r\n     *   });\r\n     * ```\r\n     *\r\n     * @param eventType One of the following strings: \"value\",\r\n     *   \"child_added\", \"child_changed\", \"child_removed\", or \"child_moved.\"\r\n     * @param successCallback A\r\n     *   callback that fires when the specified event occurs. The callback will be\r\n     *   passed a DataSnapshot. For ordering purposes, \"child_added\",\r\n     *   \"child_changed\", and \"child_moved\" will also be passed a string containing\r\n     *   the key of the previous child by sort order, or `null` if it is the\r\n     *   first child.\r\n     * @param failureCallbackOrContext An optional\r\n     *   callback that will be notified if your client does not have permission to\r\n     *   read the data. This callback will be passed an `Error` object indicating\r\n     *   why the failure occurred.\r\n     * @param context If provided, this object will be used as `this`\r\n     *   when calling your callback(s).\r\n     */\r\n    once(\r\n      eventType: EventType,\r\n      successCallback?: (\r\n        a: firebase.database.DataSnapshot,\r\n        b?: string | null,\r\n      ) => any,\r\n      failureCallbackOrContext?: ((a: Error) => void) | Object | null,\r\n      context?: Object | null,\r\n    ): Promise<firebase.database.DataSnapshot>;\r\n    /**\r\n     * Generates a new `Query` object ordered by the specified child key.\r\n     *\r\n     * Queries can only order by one key at a time. Calling `orderByChild()`\r\n     * multiple times on the same query is an error.\r\n     *\r\n     * Firebase queries allow you to order your data by any child key on the fly.\r\n     * However, if you know in advance what your indexes will be, you can define\r\n     * them via the .indexOn rule in your Security Rules for better performance. See\r\n     * the {@link https://firebase.google.com/docs/database/security/indexing-data\r\n     * .indexOn} rule for more information.\r\n     *\r\n     * You can read more about `orderByChild()` in\r\n     * {@link\r\n     *  https://firebase.google.com/docs/database/web/lists-of-data#sort_data\r\n     *  Sort data}.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var ref = firebase.database().ref(\"dinosaurs\");\r\n     * ref.orderByChild(\"height\").on(\"child_added\", function(snapshot) {\r\n     *   console.log(snapshot.key + \" was \" + snapshot.val().height + \" m tall\");\r\n     * });\r\n     * ```\r\n     */\r\n    orderByChild(path: string): firebase.database.Query;\r\n    /**\r\n     * Generates a new `Query` object ordered by key.\r\n     *\r\n     * Sorts the results of a query by their (ascending) key values.\r\n     *\r\n     * You can read more about `orderByKey()` in\r\n     * {@link\r\n     *  https://firebase.google.com/docs/database/web/lists-of-data#sort_data\r\n     *  Sort data}.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var ref = firebase.database().ref(\"dinosaurs\");\r\n     * ref.orderByKey().on(\"child_added\", function(snapshot) {\r\n     *   console.log(snapshot.key);\r\n     * });\r\n     * ```\r\n     */\r\n    orderByKey(): firebase.database.Query;\r\n    /**\r\n     * Generates a new `Query` object ordered by priority.\r\n     *\r\n     * Applications need not use priority but can order collections by\r\n     * ordinary properties (see\r\n     * {@link\r\n     *  https://firebase.google.com/docs/database/web/lists-of-data#sort_data\r\n     *  Sort data} for alternatives to priority.\r\n     */\r\n    orderByPriority(): firebase.database.Query;\r\n    /**\r\n     * Generates a new `Query` object ordered by value.\r\n     *\r\n     * If the children of a query are all scalar values (string, number, or\r\n     * boolean), you can order the results by their (ascending) values.\r\n     *\r\n     * You can read more about `orderByValue()` in\r\n     * {@link\r\n     *  https://firebase.google.com/docs/database/web/lists-of-data#sort_data\r\n     *  Sort data}.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var scoresRef = firebase.database().ref(\"scores\");\r\n     * scoresRef.orderByValue().limitToLast(3).on(\"value\", function(snapshot) {\r\n     *   snapshot.forEach(function(data) {\r\n     *     console.log(\"The \" + data.key + \" score is \" + data.val());\r\n     *   });\r\n     * });\r\n     * ```\r\n     */\r\n    orderByValue(): firebase.database.Query;\r\n    /**\r\n     * Returns a `Reference` to the `Query`'s location.\r\n     */\r\n    ref: firebase.database.Reference;\r\n    /**\r\n     * Creates a `Query` with the specified starting point.\r\n     *\r\n     * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n     * allows you to choose arbitrary starting and ending points for your queries.\r\n     *\r\n     * The starting point is inclusive, so children with exactly the specified value\r\n     * will be included in the query. The optional key argument can be used to\r\n     * further limit the range of the query. If it is specified, then children that\r\n     * have exactly the specified value must also have a key name greater than or\r\n     * equal to the specified key.\r\n     *\r\n     * You can read more about `startAt()` in\r\n     * {@link\r\n     *  https://firebase.google.com/docs/database/web/lists-of-data#filtering_data\r\n     *  Filtering data}.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Find all dinosaurs that are at least three meters tall.\r\n     * var ref = firebase.database().ref(\"dinosaurs\");\r\n     * ref.orderByChild(\"height\").startAt(3).on(\"child_added\", function(snapshot) {\r\n     *   console.log(snapshot.key)\r\n     * });\r\n     * ```\r\n     *\r\n     * @param value The value to start at. The argument\r\n     *   type depends on which `orderBy*()` function was used in this query.\r\n     *   Specify a value that matches the `orderBy*()` type. When used in\r\n     *   combination with `orderByKey()`, the value must be a string.\r\n     * @param key The child key to start at. This argument is only allowed\r\n     *   if ordering by child, value, or priority.\r\n     */\r\n    startAt(\r\n      value: number | string | boolean | null,\r\n      key?: string,\r\n    ): firebase.database.Query;\r\n    /**\r\n     * Creates a `Query` with the specified starting point (exclusive).\r\n     *\r\n     * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n     * allows you to choose arbitrary starting and ending points for your queries.\r\n     *\r\n     * The starting point is exclusive. If only a value is provided, children\r\n     * with a value greater than the specified value will be included in the query.\r\n     * If a key is specified, then children must have a value greater than or equal\r\n     * to the specified value and a a key name greater than the specified key.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Find all dinosaurs that are more than three meters tall.\r\n     * var ref = firebase.database().ref(\"dinosaurs\");\r\n     * ref.orderByChild(\"height\").startAfter(3).on(\"child_added\", function(snapshot) {\r\n     *   console.log(snapshot.key)\r\n     * });\r\n     * ```\r\n     *\r\n     * @param value The value to start after. The argument\r\n     *   type depends on which `orderBy*()` function was used in this query.\r\n     *   Specify a value that matches the `orderBy*()` type. When used in\r\n     *   combination with `orderByKey()`, the value must be a string.\r\n     * @param key The child key to start after. This argument is only allowed\r\n     *   if ordering by child, value, or priority.\r\n     */\r\n    startAfter(\r\n      value: number | string | boolean | null,\r\n      key?: string,\r\n    ): firebase.database.Query;\r\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     *\r\n     * @return A JSON-serializable representation of this object.\r\n     */\r\n    toJSON(): Object;\r\n    /**\r\n     * Gets the absolute URL for this location.\r\n     *\r\n     * The `toString()` method returns a URL that is ready to be put into a browser,\r\n     * curl command, or a `firebase.database().refFromURL()` call. Since all of\r\n     * those expect the URL to be url-encoded, `toString()` returns an encoded URL.\r\n     *\r\n     * Append '.json' to the returned URL when typed into a browser to download\r\n     * JSON-formatted data. If the location is secured (that is, not publicly\r\n     * readable), you will get a permission-denied error.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Calling toString() on a root Firebase reference returns the URL where its\r\n     * // data is stored within the Database:\r\n     * var rootRef = firebase.database().ref();\r\n     * var rootUrl = rootRef.toString();\r\n     * // rootUrl === \"https://sample-app.firebaseio.com/\".\r\n     *\r\n     * // Calling toString() at a deeper Firebase reference returns the URL of that\r\n     * // deep path within the Database:\r\n     * var adaRef = rootRef.child('users/ada');\r\n     * var adaURL = adaRef.toString();\r\n     * // adaURL === \"https://sample-app.firebaseio.com/users/ada\".\r\n     * ```\r\n     *\r\n     * @return The absolute URL for this location.\r\n     */\r\n    toString(): string;\r\n  }\r\n\r\n  /**\r\n   * A `Reference` represents a specific location in your Database and can be used\r\n   * for reading or writing data to that Database location.\r\n   *\r\n   * You can reference the root or child location in your Database by calling\r\n   * `firebase.database().ref()` or `firebase.database().ref(\"child/path\")`.\r\n   *\r\n   * Writing is done with the `set()` method and reading can be done with the\r\n   * `on()` method. See\r\n   * {@link\r\n   *   https://firebase.google.com/docs/database/web/read-and-write\r\n   *   Read and Write Data on the Web}\r\n   */\r\n  interface Reference extends firebase.database.Query {\r\n    /**\r\n     * Gets a `Reference` for the location at the specified relative path.\r\n     *\r\n     * The relative path can either be a simple child name (for example, \"ada\") or\r\n     * a deeper slash-separated path (for example, \"ada/name/first\").\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var usersRef = firebase.database().ref('users');\r\n     * var adaRef = usersRef.child('ada');\r\n     * var adaFirstNameRef = adaRef.child('name/first');\r\n     * var path = adaFirstNameRef.toString();\r\n     * // path is now 'https://sample-app.firebaseio.com/users/ada/name/first'\r\n     * ```\r\n     *\r\n     * @param path A relative path from this location to the desired child\r\n     *   location.\r\n     * @return The specified child location.\r\n     */\r\n    child(path: string): firebase.database.Reference;\r\n    /**\r\n     * The last part of the `Reference`'s path.\r\n     *\r\n     * For example, `\"ada\"` is the key for\r\n     * `https://<DATABASE_NAME>.firebaseio.com/users/ada`.\r\n     *\r\n     * The key of a root `Reference` is `null`.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // The key of a root reference is null\r\n     * var rootRef = firebase.database().ref();\r\n     * var key = rootRef.key;  // key === null\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // The key of any non-root reference is the last token in the path\r\n     * var adaRef = firebase.database().ref(\"users/ada\");\r\n     * var key = adaRef.key;  // key === \"ada\"\r\n     * key = adaRef.child(\"name/last\").key;  // key === \"last\"\r\n     * ```\r\n     */\r\n    key: string | null;\r\n    /**\r\n     * Returns an `OnDisconnect` object - see\r\n     * {@link\r\n     *   https://firebase.google.com/docs/database/web/offline-capabilities\r\n     *   Enabling Offline Capabilities in JavaScript} for more information on how\r\n     * to use it.\r\n     */\r\n    onDisconnect(): firebase.database.OnDisconnect;\r\n    /**\r\n     * The parent location of a `Reference`.\r\n     *\r\n     * The parent of a root `Reference` is `null`.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // The parent of a root reference is null\r\n     * var rootRef = firebase.database().ref();\r\n     * parent = rootRef.parent;  // parent === null\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // The parent of any non-root reference is the parent location\r\n     * var usersRef = firebase.database().ref(\"users\");\r\n     * var adaRef = firebase.database().ref(\"users/ada\");\r\n     * // usersRef and adaRef.parent represent the same location\r\n     * ```\r\n     */\r\n    parent: firebase.database.Reference | null;\r\n    /**\r\n     * Generates a new child location using a unique key and returns its\r\n     * `Reference`.\r\n     *\r\n     * This is the most common pattern for adding data to a collection of items.\r\n     *\r\n     * If you provide a value to `push()`, the value is written to the\r\n     * generated location. If you don't pass a value, nothing is written to the\r\n     * database and the child remains empty (but you can use the `Reference`\r\n     * elsewhere).\r\n     *\r\n     * The unique keys generated by `push()` are ordered by the current time, so the\r\n     * resulting list of items is chronologically sorted. The keys are also\r\n     * designed to be unguessable (they contain 72 random bits of entropy).\r\n     *\r\n     *\r\n     * See\r\n     * {@link\r\n     *  https://firebase.google.com/docs/database/web/lists-of-data#append_to_a_list_of_data\r\n     *  Append to a list of data}\r\n     * </br>See\r\n     * {@link\r\n     *  https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html\r\n     *  The 2^120 Ways to Ensure Unique Identifiers}\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var messageListRef = firebase.database().ref('message_list');\r\n     * var newMessageRef = messageListRef.push();\r\n     * newMessageRef.set({\r\n     *   'user_id': 'ada',\r\n     *   'text': 'The Analytical Engine weaves algebraical patterns just as the Jacquard loom weaves flowers and leaves.'\r\n     * });\r\n     * // We've appended a new message to the message_list location.\r\n     * var path = newMessageRef.toString();\r\n     * // path will be something like\r\n     * // 'https://sample-app.firebaseio.com/message_list/-IKo28nwJLH0Nc5XeFmj'\r\n     * ```\r\n     *\r\n     * @param value Optional value to be written at the generated location.\r\n     * @param onComplete Callback called when write to server is\r\n     *   complete.\r\n     * @return Combined `Promise` and `Reference`; resolves when write is complete, but can be\r\n     *   used immediately as the `Reference` to the child location.\r\n     */\r\n    push(\r\n      value?: any,\r\n      onComplete?: (a: Error | null) => any,\r\n    ): firebase.database.ThenableReference;\r\n    /**\r\n     * Removes the data at this Database location.\r\n     *\r\n     * Any data at child locations will also be deleted.\r\n     *\r\n     * The effect of the remove will be visible immediately and the corresponding\r\n     * event 'value' will be triggered. Synchronization of the remove to the\r\n     * Firebase servers will also be started, and the returned Promise will resolve\r\n     * when complete. If provided, the onComplete callback will be called\r\n     * asynchronously after synchronization has finished.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var adaRef = firebase.database().ref('users/ada');\r\n     * adaRef.remove()\r\n     *   .then(function() {\r\n     *     console.log(\"Remove succeeded.\")\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.log(\"Remove failed: \" + error.message)\r\n     *   });\r\n     * ```\r\n     *\r\n     * @param onComplete Callback called when write to server is\r\n     *   complete.\r\n     * @return Resolves when remove on server is complete.\r\n     */\r\n    remove(onComplete?: (a: Error | null) => void): Promise<void>;\r\n    /**\r\n     * The root `Reference` of the Database.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // The root of a root reference is itself\r\n     * var rootRef = firebase.database().ref();\r\n     * // rootRef and rootRef.root represent the same location\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // The root of any non-root reference is the root location\r\n     * var adaRef = firebase.database().ref(\"users/ada\");\r\n     * // rootRef and adaRef.root represent the same location\r\n     * ```\r\n     */\r\n    root: firebase.database.Reference;\r\n    /**\r\n     * Writes data to this Database location.\r\n     *\r\n     * This will overwrite any data at this location and all child locations.\r\n     *\r\n     * The effect of the write will be visible immediately, and the corresponding\r\n     * events (\"value\", \"child_added\", etc.) will be triggered. Synchronization of\r\n     * the data to the Firebase servers will also be started, and the returned\r\n     * Promise will resolve when complete. If provided, the `onComplete` callback\r\n     * will be called asynchronously after synchronization has finished.\r\n     *\r\n     * Passing `null` for the new value is equivalent to calling `remove()`; namely,\r\n     * all data at this location and all child locations will be deleted.\r\n     *\r\n     * `set()` will remove any priority stored at this location, so if priority is\r\n     * meant to be preserved, you need to use `setWithPriority()` instead.\r\n     *\r\n     * Note that modifying data with `set()` will cancel any pending transactions\r\n     * at that location, so extreme care should be taken if mixing `set()` and\r\n     * `transaction()` to modify the same data.\r\n     *\r\n     * A single `set()` will generate a single \"value\" event at the location where\r\n     * the `set()` was performed.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var adaNameRef = firebase.database().ref('users/ada/name');\r\n     * adaNameRef.child('first').set('Ada');\r\n     * adaNameRef.child('last').set('Lovelace');\r\n     * // We've written 'Ada' to the Database location storing Ada's first name,\r\n     * // and 'Lovelace' to the location storing her last name.\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * adaNameRef.set({ first: 'Ada', last: 'Lovelace' });\r\n     * // Exact same effect as the previous example, except we've written\r\n     * // Ada's first and last name simultaneously.\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * adaNameRef.set({ first: 'Ada', last: 'Lovelace' })\r\n     *   .then(function() {\r\n     *     console.log('Synchronization succeeded');\r\n     *   })\r\n     *   .catch(function(error) {\r\n     *     console.log('Synchronization failed');\r\n     *   });\r\n     * // Same as the previous example, except we will also log a message\r\n     * // when the data has finished synchronizing.\r\n     * ```\r\n     *\r\n     * @param value The value to be written (string, number, boolean, object,\r\n     *   array, or null).\r\n     * @param onComplete Callback called when write to server is\r\n     *   complete.\r\n     * @return Resolves when write to server is complete.\r\n     */\r\n    set(value: any, onComplete?: (a: Error | null) => void): Promise<void>;\r\n    /**\r\n     * Sets a priority for the data at this Database location.\r\n     *\r\n     * Applications need not use priority but can order collections by\r\n     * ordinary properties (see\r\n     * {@link\r\n     *  https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data\r\n     *  Sorting and filtering data}).\r\n     */\r\n    setPriority(\r\n      priority: string | number | null,\r\n      onComplete: (a: Error | null) => void,\r\n    ): Promise<void>;\r\n    /**\r\n     * Writes data the Database location. Like `set()` but also specifies the\r\n     * priority for that data.\r\n     *\r\n     * Applications need not use priority but can order collections by\r\n     * ordinary properties (see\r\n     * {@link\r\n     *  https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data\r\n     *  Sorting and filtering data}).\r\n     */\r\n    setWithPriority(\r\n      newVal: any,\r\n      newPriority: string | number | null,\r\n      onComplete?: (a: Error | null) => void,\r\n    ): Promise<void>;\r\n    /**\r\n     * Atomically modifies the data at this location.\r\n     *\r\n     * Atomically modify the data at this location. Unlike a normal `set()`, which\r\n     * just overwrites the data regardless of its previous value, `transaction()` is\r\n     * used to modify the existing value to a new value, ensuring there are no\r\n     * conflicts with other clients writing to the same location at the same time.\r\n     *\r\n     * To accomplish this, you pass `transaction()` an update function which is used\r\n     * to transform the current value into a new value. If another client writes to\r\n     * the location before your new value is successfully written, your update\r\n     * function will be called again with the new current value, and the write will\r\n     * be retried. This will happen repeatedly until your write succeeds without\r\n     * conflict or you abort the transaction by not returning a value from your\r\n     * update function.\r\n     *\r\n     * Note: Modifying data with `set()` will cancel any pending transactions at\r\n     * that location, so extreme care should be taken if mixing `set()` and\r\n     * `transaction()` to update the same data.\r\n     *\r\n     * Note: When using transactions with Security and Firebase Rules in place, be\r\n     * aware that a client needs `.read` access in addition to `.write` access in\r\n     * order to perform a transaction. This is because the client-side nature of\r\n     * transactions requires the client to read the data in order to transactionally\r\n     * update it.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Increment Ada's rank by 1.\r\n     * var adaRankRef = firebase.database().ref('users/ada/rank');\r\n     * adaRankRef.transaction(function(currentRank) {\r\n     *   // If users/ada/rank has never been set, currentRank will be `null`.\r\n     *   return currentRank + 1;\r\n     * });\r\n     * ```\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * // Try to create a user for ada, but only if the user id 'ada' isn't\r\n     * // already taken\r\n     * var adaRef = firebase.database().ref('users/ada');\r\n     * adaRef.transaction(function(currentData) {\r\n     *   if (currentData === null) {\r\n     *     return { name: { first: 'Ada', last: 'Lovelace' } };\r\n     *   } else {\r\n     *     console.log('User ada already exists.');\r\n     *     return; // Abort the transaction.\r\n     *   }\r\n     * }, function(error, committed, snapshot) {\r\n     *   if (error) {\r\n     *     console.log('Transaction failed abnormally!', error);\r\n     *   } else if (!committed) {\r\n     *     console.log('We aborted the transaction (because ada already exists).');\r\n     *   } else {\r\n     *     console.log('User ada added!');\r\n     *   }\r\n     *   console.log(\"Ada's data: \", snapshot.val());\r\n     * });\r\n     * ```\r\n     *\r\n     * @param transactionUpdate A developer-supplied function which\r\n     *   will be passed the current data stored at this location (as a JavaScript\r\n     *   object). The function should return the new value it would like written (as\r\n     *   a JavaScript object). If `undefined` is returned (i.e. you return with no\r\n     *   arguments) the transaction will be aborted and the data at this location\r\n     *   will not be modified.\r\n     * @param onComplete A callback\r\n     *   function that will be called when the transaction completes. The callback\r\n     *   is passed three arguments: a possibly-null `Error`, a `boolean` indicating\r\n     *   whether the transaction was committed, and a `DataSnapshot` indicating the\r\n     *   final result. If the transaction failed abnormally, the first argument will\r\n     *   be an `Error` object indicating the failure cause. If the transaction\r\n     *   finished normally, but no data was committed because no data was returned\r\n     *   from `transactionUpdate`, then second argument will be false. If the\r\n     *   transaction completed and committed data to Firebase, the second argument\r\n     *   will be true. Regardless, the third argument will be a `DataSnapshot`\r\n     *   containing the resulting data in this location.\r\n     * @param applyLocally By default, events are raised each time the\r\n     *   transaction update function runs. So if it is run multiple times, you may\r\n     *   see intermediate states. You can set this to false to suppress these\r\n     *   intermediate states and instead wait until the transaction has completed\r\n     *   before events are raised.\r\n     * @return Returns a Promise that can optionally be used instead of the onComplete\r\n     *   callback to handle success and failure.\r\n     */\r\n    transaction(\r\n      transactionUpdate: (a: any) => any,\r\n      onComplete?: (\r\n        a: Error | null,\r\n        b: boolean,\r\n        c: firebase.database.DataSnapshot | null,\r\n      ) => void,\r\n      applyLocally?: boolean,\r\n    ): Promise<TransactionResult>;\r\n    /**\r\n     * Writes multiple values to the Database at once.\r\n     *\r\n     * The `values` argument contains multiple property-value pairs that will be\r\n     * written to the Database together. Each child property can either be a simple\r\n     * property (for example, \"name\") or a relative path (for example,\r\n     * \"name/first\") from the current location to the data to update.\r\n     *\r\n     * As opposed to the `set()` method, `update()` can be use to selectively update\r\n     * only the referenced properties at the current location (instead of replacing\r\n     * all the child properties at the current location).\r\n     *\r\n     * The effect of the write will be visible immediately, and the corresponding\r\n     * events ('value', 'child_added', etc.) will be triggered. Synchronization of\r\n     * the data to the Firebase servers will also be started, and the returned\r\n     * Promise will resolve when complete. If provided, the `onComplete` callback\r\n     * will be called asynchronously after synchronization has finished.\r\n     *\r\n     * A single `update()` will generate a single \"value\" event at the location\r\n     * where the `update()` was performed, regardless of how many children were\r\n     * modified.\r\n     *\r\n     * Note that modifying data with `update()` will cancel any pending\r\n     * transactions at that location, so extreme care should be taken if mixing\r\n     * `update()` and `transaction()` to modify the same data.\r\n     *\r\n     * Passing `null` to `update()` will remove the data at this location.\r\n     *\r\n     * See\r\n     * {@link\r\n     *  https://firebase.googleblog.com/2015/09/introducing-multi-location-updates-and_86.html\r\n     *  Introducing multi-location updates and more}.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var adaNameRef = firebase.database().ref('users/ada/name');\r\n     * // Modify the 'first' and 'last' properties, but leave other data at\r\n     * // adaNameRef unchanged.\r\n     * adaNameRef.update({ first: 'Ada', last: 'Lovelace' });\r\n     * ```\r\n     *\r\n     * @param values Object containing multiple values.\r\n     * @param onComplete Callback called when write to server is\r\n     *   complete.\r\n     * @return Resolves when update on server is complete.\r\n     */\r\n    update(\r\n      values: Object,\r\n      onComplete?: (a: Error | null) => void,\r\n    ): Promise<void>;\r\n  }\r\n\r\n  interface TransactionResult {\r\n    /**\r\n     * Whether the transaction was successfully committed.\r\n     */\r\n    committed: boolean;\r\n    /**\r\n     * The resulting data snapshot.\r\n     */\r\n    snapshot: DataSnapshot;\r\n  }\r\n\r\n  interface ThenableReference\r\n    extends firebase.database.Reference,\r\n      Pick<Promise<Reference>, \"then\" | \"catch\"> {\r\n    key: string;\r\n    parent: Reference;\r\n  }\r\n\r\n  /**\r\n   * Logs debugging information to the console.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Enable logging\r\n   * firebase.database.enableLogging(true);\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Disable logging\r\n   * firebase.database.enableLogging(false);\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Enable logging across page refreshes\r\n   * firebase.database.enableLogging(true, true);\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * // Provide custom logger which prefixes log statements with \"[FIREBASE]\"\r\n   * firebase.database.enableLogging(function(message) {\r\n   *   console.log(\"[FIREBASE]\", message);\r\n   * });\r\n   * ```\r\n   *\r\n   * @param logger Enables logging if `true`;\r\n   *   disables logging if `false`. You can also provide a custom logger function\r\n   *   to control how things get logged.\r\n   * @param persistent Remembers the logging state between page\r\n   *   refreshes if `true`.\r\n   */\r\n  function enableLogging(\r\n    logger?: boolean | ((a: string) => any),\r\n    persistent?: boolean,\r\n  ): any;\r\n\r\n  export type EmulatorMockTokenOptions = firebase.EmulatorMockTokenOptions;\r\n}\r\n\r\ndeclare namespace firebase.database.ServerValue {\r\n  /**\r\n   * A placeholder value for auto-populating the current timestamp (time\r\n   * since the Unix epoch, in milliseconds) as determined by the Firebase\r\n   * servers.\r\n   *\r\n   * @example\r\n   * ```javascript\r\n   * var sessionsRef = firebase.database().ref(\"sessions\");\r\n   * sessionsRef.push({\r\n   *   startedAt: firebase.database.ServerValue.TIMESTAMP\r\n   * });\r\n   * ```\r\n   */\r\n  var TIMESTAMP: Object;\r\n\r\n  /**\r\n   * Returns a placeholder value that can be used to atomically increment the\r\n   * current database value by the provided delta.\r\n   *\r\n   * @param delta the amount to modify the current value atomically.\r\n   * @return a placeholder value for modifying data atomically server-side.\r\n   */\r\n  function increment(delta: number): Object;\r\n}\r\n\r\n/**\r\n * The Messaging SDK does not work in a Node.js environment.\r\n */\r\ndeclare namespace firebase.messaging {\r\n  /**\r\n   * The Firebase Messaging service interface.\r\n   *\r\n   * Do not call this constructor directly. Instead, use\r\n   * {@link firebase.messaging `firebase.messaging()`}.\r\n   *\r\n   * See {@link https://firebase.google.com/docs/cloud-messaging/js/client\r\n   * Set Up a JavaScript Firebase Cloud Messaging Client App} for a full guide on how to use the\r\n   * Firebase Messaging service.\r\n   *\r\n   */\r\n  interface Messaging {\r\n    /**\r\n     * Deletes the registration token associated with this messaging instance and unsubscribes the\r\n     * messaging instance from the push subscription.\r\n     *\r\n     * @return The promise resolves when the token has been successfully deleted.\r\n     */\r\n    deleteToken(): Promise<boolean>;\r\n\r\n    /**\r\n     * Subscribes the messaging instance to push notifications. Returns an FCM registration token\r\n     * that can be used to send push messages to that messaging instance.\r\n     *\r\n     * If a notification permission isn't already granted, this method asks the user for permission.\r\n     * The returned promise rejects if the user does not allow the app to show notifications.\r\n     *\r\n     * @param options.vapidKey The public server key provided to push services. It is used to\r\n     * authenticate the push subscribers to receive push messages only from sending servers that\r\n     * hold the corresponding private key. If it is not provided, a default VAPID key is used. Note\r\n     * that some push services (Chrome Push Service) require a non-default VAPID key. Therefore, it\r\n     * is recommended to generate and import a VAPID key for your project with\r\n     * {@link https://firebase.google.com/docs/cloud-messaging/js/client#configure_web_credentials_with_fcm Configure Web Credentials with FCM}.\r\n     * See\r\n     * {@link https://developers.google.com/web/fundamentals/push-notifications/web-push-protocol The Web Push Protocol}\r\n     * for details on web push services.}\r\n     *\r\n     * @param options.serviceWorkerRegistration The service worker registration for receiving push\r\n     * messaging. If the registration is not provided explicitly, you need to have a\r\n     * `firebase-messaging-sw.js` at your root location. See\r\n     * {@link https://firebase.google.com/docs/cloud-messaging/js/client#access_the_registration_token | Access the registration token}\r\n     * for more details.\r\n     *\r\n     * @return The promise resolves with an FCM registration token.\r\n     *\r\n     */\r\n    getToken(options?: {\r\n      vapidKey?: string;\r\n      serviceWorkerRegistration?: ServiceWorkerRegistration;\r\n    }): Promise<string>;\r\n\r\n    /**\r\n     * When a push message is received and the user is currently on a page for your origin, the\r\n     * message is passed to the page and an `onMessage()` event is dispatched with the payload of\r\n     * the push message.\r\n     *\r\n     * @param\r\n     *     nextOrObserver This function, or observer object with `next` defined,\r\n     *     is called when a message is received and the user is currently viewing your page.\r\n     * @return To stop listening for messages execute this returned function.\r\n     */\r\n    onMessage(\r\n      nextOrObserver: firebase.NextFn<any> | firebase.Observer<any>,\r\n    ): firebase.Unsubscribe;\r\n\r\n    /**\r\n     * Called when a message is received while the app is in the background. An app is considered to\r\n     * be in the background if no active window is displayed.\r\n     *\r\n     * @param\r\n     *     nextOrObserver This function, or observer object with `next` defined,\r\n     *     is called when a message is received and the app is currently in the background.\r\n     *\r\n     * @return To stop listening for messages execute this returned function\r\n     */\r\n    onBackgroundMessage(\r\n      nextOrObserver:\r\n        | firebase.NextFn<MessagePayload>\r\n        | firebase.Observer<MessagePayload>,\r\n    ): firebase.Unsubscribe;\r\n  }\r\n\r\n  /**\r\n   * Message payload that contains the notification payload that is represented with\r\n   * {@link firebase.messaging.NotificationPayload} and the data payload that contains an arbitrary\r\n   * number of key-value pairs sent by developers through the\r\n   * {@link https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#notification Send API}\r\n   */\r\n  export interface MessagePayload {\r\n    /**\r\n     * See {@link firebase.messaging.NotificationPayload}.\r\n     */\r\n    notification?: NotificationPayload;\r\n\r\n    /**\r\n     * Arbitrary key/value pairs.\r\n     */\r\n    data?: { [key: string]: string };\r\n\r\n    /**\r\n     * See {@link firebase.messaging.FcmOptions}.\r\n     */\r\n    fcmOptions?: FcmOptions;\r\n\r\n    /**\r\n     * The sender of this message.\r\n     */\r\n    from: string;\r\n\r\n    /**\r\n     * The collapse key of this message. See\r\n     * {@link https://firebase.google.com/docs/cloud-messaging/concept-options#collapsible_and_non-collapsible_messages\r\n     * Collapsible and non-collapsible messages}.\r\n     */\r\n    collapseKey: string;\r\n  }\r\n\r\n  /**\r\n   * Options for features provided by the FCM SDK for Web. See\r\n   * {@link https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#webpushfcmoptions\r\n   * WebpushFcmOptions}.\r\n   */\r\n  export interface FcmOptions {\r\n    /**\r\n     * The link to open when the user clicks on the notification. For all URL values, HTTPS is\r\n     * required. For example, by setting this value to your app's URL, a notification click event\r\n     * will put your app in focus for the user.\r\n     */\r\n    link?: string;\r\n\r\n    /**\r\n     * Label associated with the message's analytics data. See\r\n     * {@link https://firebase.google.com/docs/cloud-messaging/understand-delivery#adding-analytics-labels-to-messages\r\n     * Adding analytics labels}.\r\n     */\r\n    analyticsLabel?: string;\r\n  }\r\n\r\n  /**\r\n   * Parameters that define how a push notification is displayed to users.\r\n   */\r\n  export interface NotificationPayload {\r\n    /**\r\n     * The title of a notification.\r\n     */\r\n    title?: string;\r\n\r\n    /**\r\n     * The body of a notification.\r\n     */\r\n    body?: string;\r\n\r\n    /**\r\n     * The URL of the image that is shown with the notification. See\r\n     * {@link https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#notification\r\n     * `notification.image`} for supported image format.\r\n     */\r\n    image?: string;\r\n  }\r\n\r\n  function isSupported(): boolean;\r\n}\r\n\r\ndeclare namespace firebase.storage {\r\n  /**\r\n   * The full set of object metadata, including read-only properties.\r\n   */\r\n  interface FullMetadata extends firebase.storage.UploadMetadata {\r\n    /**\r\n     * The bucket this object is contained in.\r\n     */\r\n    bucket: string;\r\n    /**\r\n     * The full path of this object.\r\n     */\r\n    fullPath: string;\r\n    /**\r\n     * The object's generation.\r\n     * @see {@link https://cloud.google.com/storage/docs/generations-preconditions}\r\n     */\r\n    generation: string;\r\n    /**\r\n     * The object's metageneration.\r\n     * @see {@link https://cloud.google.com/storage/docs/generations-preconditions}\r\n     */\r\n    metageneration: string;\r\n    /**\r\n     * The short name of this object, which is the last component of the full path.\r\n     * For example, if fullPath is 'full/path/image.png', name is 'image.png'.\r\n     */\r\n    name: string;\r\n    /**\r\n     * The size of this object, in bytes.\r\n     */\r\n    size: number;\r\n    /**\r\n     * A date string representing when this object was created.\r\n     */\r\n    timeCreated: string;\r\n    /**\r\n     * A date string representing when this object was last updated.\r\n     */\r\n    updated: string;\r\n  }\r\n\r\n  /**\r\n   * Represents a reference to a Google Cloud Storage object. Developers can\r\n   * upload, download, and delete objects, as well as get/set object metadata.\r\n   */\r\n  interface Reference {\r\n    /**\r\n     * The name of the bucket containing this reference's object.\r\n     */\r\n    bucket: string;\r\n    /**\r\n     * Returns a reference to a relative path from this reference.\r\n     * @param path The relative path from this reference.\r\n     *     Leading, trailing, and consecutive slashes are removed.\r\n     * @return The reference to the given path.\r\n     */\r\n    child(path: string): firebase.storage.Reference;\r\n    /**\r\n     * Deletes the object at this reference's location.\r\n     * @return A Promise that resolves if the deletion\r\n     *     succeeded and rejects if it failed, including if the object didn't exist.\r\n     */\r\n    delete(): Promise<void>;\r\n    /**\r\n     * The full path of this object.\r\n     */\r\n    fullPath: string;\r\n    /**\r\n     * Fetches a long lived download URL for this object.\r\n     * @return A Promise that resolves with the download\r\n     *     URL or rejects if the fetch failed, including if the object did not\r\n     *     exist.\r\n     */\r\n    getDownloadURL(): Promise<string>;\r\n    /**\r\n     * Fetches metadata for the object at this location, if one exists.\r\n     * @return A Promise that\r\n     *     resolves with the metadata, or rejects if the fetch failed, including if\r\n     *     the object did not exist.\r\n     */\r\n    getMetadata(): Promise<FullMetadata>;\r\n    /**\r\n     * The short name of this object, which is the last component of the full path.\r\n     * For example, if fullPath is 'full/path/image.png', name is 'image.png'.\r\n     */\r\n    name: string;\r\n    /**\r\n     * A reference pointing to the parent location of this reference, or null if\r\n     * this reference is the root.\r\n     */\r\n    parent: firebase.storage.Reference | null;\r\n    /**\r\n     * Uploads data to this reference's location.\r\n     * @param data The data to upload.\r\n     * @param metadata Metadata for the newly\r\n     *     uploaded object.\r\n     * @return An object that can be used to monitor\r\n     *     and manage the upload.\r\n     */\r\n    put(\r\n      data: Blob | Uint8Array | ArrayBuffer,\r\n      metadata?: firebase.storage.UploadMetadata,\r\n    ): firebase.storage.UploadTask;\r\n    /**\r\n     * Uploads string data to this reference's location.\r\n     * @param data The string to upload.\r\n     * @param format The format of the string to\r\n     *     upload.\r\n     * @param metadata Metadata for the newly\r\n     *     uploaded object.\r\n     * @throws If the format is not an allowed format, or if the given string\r\n     *     doesn't conform to the specified format.\r\n     */\r\n    putString(\r\n      data: string,\r\n      format?: firebase.storage.StringFormat,\r\n      metadata?: firebase.storage.UploadMetadata,\r\n    ): firebase.storage.UploadTask;\r\n    /**\r\n     * A reference to the root of this reference's bucket.\r\n     */\r\n    root: firebase.storage.Reference;\r\n    /**\r\n     * The storage service associated with this reference.\r\n     */\r\n    storage: firebase.storage.Storage;\r\n    /**\r\n     * Returns a gs:// URL for this object in the form\r\n     *   `gs://<bucket>/<path>/<to>/<object>`\r\n     * @return The gs:// URL.\r\n     */\r\n    toString(): string;\r\n    /**\r\n     * Updates the metadata for the object at this location, if one exists.\r\n     * @param metadata The new metadata.\r\n     *     Setting a property to 'null' removes it on the server, while leaving\r\n     *     a property as 'undefined' has no effect.\r\n     * @return A Promise that\r\n     *     resolves with the full updated metadata or rejects if the updated failed,\r\n     *     including if the object did not exist.\r\n     */\r\n    updateMetadata(\r\n      metadata: firebase.storage.SettableMetadata,\r\n    ): Promise<FullMetadata>;\r\n    /**\r\n     * List all items (files) and prefixes (folders) under this storage reference.\r\n     *\r\n     * This is a helper method for calling `list()` repeatedly until there are\r\n     * no more results. The default pagination size is 1000.\r\n     *\r\n     * Note: The results may not be consistent if objects are changed while this\r\n     * operation is running.\r\n     *\r\n     * Warning: `listAll` may potentially consume too many resources if there are\r\n     * too many results.\r\n     *\r\n     * @return A Promise that resolves with all the items and prefixes under\r\n     *      the current storage reference. `prefixes` contains references to\r\n     *      sub-directories and `items` contains references to objects in this\r\n     *      folder. `nextPageToken` is never returned.\r\n     */\r\n    listAll(): Promise<ListResult>;\r\n    /**\r\n     * List items (files) and prefixes (folders) under this storage reference.\r\n     *\r\n     * List API is only available for Firebase Rules Version 2.\r\n     *\r\n     * GCS is a key-blob store. Firebase Storage imposes the semantic of '/'\r\n     * delimited folder structure.\r\n     * Refer to GCS's List API if you want to learn more.\r\n     *\r\n     * To adhere to Firebase Rules's Semantics, Firebase Storage does not\r\n     * support objects whose paths end with \"/\" or contain two consecutive\r\n     * \"/\"s. Firebase Storage List API will filter these unsupported objects.\r\n     * `list()` may fail if there are too many unsupported objects in the bucket.\r\n     *\r\n     * @param options See `ListOptions` for details.\r\n     * @return A Promise that resolves with the items and prefixes.\r\n     *      `prefixes` contains references to sub-folders and `items`\r\n     *      contains references to objects in this folder. `nextPageToken`\r\n     *      can be used to get the rest of the results.\r\n     */\r\n    list(options?: ListOptions): Promise<ListResult>;\r\n  }\r\n\r\n  /**\r\n   * Result returned by list().\r\n   */\r\n  interface ListResult {\r\n    /**\r\n     * References to prefixes (sub-folders). You can call list() on them to\r\n     * get its contents.\r\n     *\r\n     * Folders are implicit based on '/' in the object paths.\r\n     * For example, if a bucket has two objects '/a/b/1' and '/a/b/2', list('/a')\r\n     * will return '/a/b' as a prefix.\r\n     */\r\n    prefixes: Reference[];\r\n    /**\r\n     * Objects in this directory.\r\n     * You can call getMetadata() and getDownloadUrl() on them.\r\n     */\r\n    items: Reference[];\r\n    /**\r\n     * If set, there might be more results for this list. Use this token to resume the list.\r\n     */\r\n    nextPageToken: string | null;\r\n  }\r\n\r\n  /**\r\n   * The options `list()` accepts.\r\n   */\r\n  interface ListOptions {\r\n    /**\r\n     * If set, limits the total number of `prefixes` and `items` to return.\r\n     * The default and maximum maxResults is 1000.\r\n     */\r\n    maxResults?: number | null;\r\n    /**\r\n     * The `nextPageToken` from a previous call to `list()`. If provided,\r\n     * listing is resumed from the previous position.\r\n     */\r\n    pageToken?: string | null;\r\n  }\r\n\r\n  /**\r\n   * Object metadata that can be set at any time.\r\n   */\r\n  interface SettableMetadata {\r\n    /**\r\n     * Served as the 'Cache-Control' header on object download.\r\n     */\r\n    cacheControl?: string | null;\r\n    contentDisposition?: string | null;\r\n    /**\r\n     * Served as the 'Content-Encoding' header on object download.\r\n     */\r\n    contentEncoding?: string | null;\r\n    /**\r\n     * Served as the 'Content-Language' header on object download.\r\n     */\r\n    contentLanguage?: string | null;\r\n    /**\r\n     * Served as the 'Content-Type' header on object download.\r\n     */\r\n    contentType?: string | null;\r\n    /**\r\n     * Additional user-defined custom metadata.\r\n     */\r\n    customMetadata?: {\r\n      [/* warning: coerced from ? */ key: string]: string;\r\n    } | null;\r\n  }\r\n\r\n  /**\r\n   * The Firebase Storage service interface.\r\n   *\r\n   * Do not call this constructor directly. Instead, use\r\n   * {@link firebase.storage `firebase.storage()`}.\r\n   *\r\n   * See\r\n   * {@link\r\n   *   https://firebase.google.com/docs/storage/web/start/\r\n   *   Get Started on Web}\r\n   * for a full guide on how to use the Firebase Storage service.\r\n   */\r\n  interface Storage {\r\n    /**\r\n     * The {@link firebase.app.App app} associated with the `Storage` service\r\n     * instance.\r\n     *\r\n     * @example\r\n     * ```javascript\r\n     * var app = storage.app;\r\n     * ```\r\n     */\r\n    app: firebase.app.App;\r\n    /**\r\n     * The maximum time to retry operations other than uploads or downloads in\r\n     * milliseconds.\r\n     */\r\n    maxOperationRetryTime: number;\r\n    /**\r\n     * The maximum time to retry uploads in milliseconds.\r\n     */\r\n    maxUploadRetryTime: number;\r\n    /**\r\n     * Returns a reference for the given path in the default bucket.\r\n     * @param path A relative path to initialize the reference with,\r\n     *     for example `path/to/image.jpg`. If not passed, the returned reference\r\n     *     points to the bucket root.\r\n     * @return A reference for the given path.\r\n     */\r\n    ref(path?: string): firebase.storage.Reference;\r\n    /**\r\n     * Returns a reference for the given absolute URL.\r\n     * @param url A URL in the form: <br />\r\n     *     1) a gs:// URL, for example `gs://bucket/files/image.png` <br />\r\n     *     2) a download URL taken from object metadata. <br />\r\n     * @return A reference for the given URL.\r\n     */\r\n    refFromURL(url: string): firebase.storage.Reference;\r\n    /**\r\n     * @param time The new maximum operation retry time in milliseconds.\r\n     * @see {@link firebase.storage.Storage.maxOperationRetryTime}\r\n     */\r\n    setMaxOperationRetryTime(time: number): any;\r\n    /**\r\n     * @param time The new maximum upload retry time in milliseconds.\r\n     * @see {@link firebase.storage.Storage.maxUploadRetryTime}\r\n     */\r\n    setMaxUploadRetryTime(time: number): any;\r\n    /**\r\n     * Modify this `Storage` instance to communicate with the Cloud Storage emulator.\r\n     *\r\n     * @param host - The emulator host (ex: localhost)\r\n     * @param port - The emulator port (ex: 5001)\r\n     * @param options.mockUserToken the mock auth token to use for unit testing Security Rules\r\n     */\r\n    useEmulator(\r\n      host: string,\r\n      port: number,\r\n      options?: {\r\n        mockUserToken?: EmulatorMockTokenOptions | string;\r\n      },\r\n    ): void;\r\n  }\r\n\r\n  /**\r\n   * @enum {string}\r\n   * An enumeration of the possible string formats for upload.\r\n   */\r\n  type StringFormat = string;\r\n  var StringFormat: {\r\n    /**\r\n     * Indicates the string should be interpreted as base64-encoded data.\r\n     * Padding characters (trailing '='s) are optional.\r\n     * Example: The string 'rWmO++E6t7/rlw==' becomes the byte sequence\r\n     * ad 69 8e fb e1 3a b7 bf eb 97\r\n     */\r\n    BASE64: StringFormat;\r\n    /**\r\n     * Indicates the string should be interpreted as base64url-encoded data.\r\n     * Padding characters (trailing '='s) are optional.\r\n     * Example: The string 'rWmO--E6t7_rlw==' becomes the byte sequence\r\n     * ad 69 8e fb e1 3a b7 bf eb 97\r\n     */\r\n    BASE64URL: StringFormat;\r\n    /**\r\n     * Indicates the string is a data URL, such as one obtained from\r\n     * canvas.toDataURL().\r\n     * Example: the string 'data:application/octet-stream;base64,aaaa'\r\n     * becomes the byte sequence\r\n     * 69 a6 9a\r\n     * (the content-type \"application/octet-stream\" is also applied, but can\r\n     * be overridden in the metadata object).\r\n     */\r\n    DATA_URL: StringFormat;\r\n    /**\r\n     * Indicates the string should be interpreted \"raw\", that is, as normal text.\r\n     * The string will be interpreted as UTF-16, then uploaded as a UTF-8 byte\r\n     * sequence.\r\n     * Example: The string 'Hello! \\ud83d\\ude0a' becomes the byte sequence\r\n     * 48 65 6c 6c 6f 21 20 f0 9f 98 8a\r\n     */\r\n    RAW: StringFormat;\r\n  };\r\n\r\n  /**\r\n   * An event that is triggered on a task.\r\n   * @enum {string}\r\n   * @see {@link firebase.storage.UploadTask.on}\r\n   */\r\n  type TaskEvent = string;\r\n  var TaskEvent: {\r\n    /**\r\n     * For this event,\r\n     * <ul>\r\n     *   <li>The `next` function is triggered on progress updates and when the\r\n     *       task is paused/resumed with a\r\n     *       {@link firebase.storage.UploadTaskSnapshot} as the first\r\n     *       argument.</li>\r\n     *   <li>The `error` function is triggered if the upload is canceled or fails\r\n     *       for another reason.</li>\r\n     *   <li>The `complete` function is triggered if the upload completes\r\n     *       successfully.</li>\r\n     * </ul>\r\n     */\r\n    STATE_CHANGED: TaskEvent;\r\n  };\r\n\r\n  /**\r\n   * Represents the current state of a running upload.\r\n   * @enum {string}\r\n   */\r\n  type TaskState = string;\r\n  var TaskState: {\r\n    CANCELED: TaskState;\r\n    ERROR: TaskState;\r\n    PAUSED: TaskState;\r\n    RUNNING: TaskState;\r\n    SUCCESS: TaskState;\r\n  };\r\n\r\n  /**\r\n   * Object metadata that can be set at upload.\r\n   */\r\n  interface UploadMetadata extends firebase.storage.SettableMetadata {\r\n    /**\r\n     * A Base64-encoded MD5 hash of the object being uploaded.\r\n     */\r\n    md5Hash?: string | null;\r\n  }\r\n\r\n  /**\r\n   * Error codes that can be attached to `StorageError` objects.\r\n   */\r\n  export enum StorageErrorCode {\r\n    UNKNOWN = \"unknown\",\r\n    OBJECT_NOT_FOUND = \"object-not-found\",\r\n    BUCKET_NOT_FOUND = \"bucket-not-found\",\r\n    PROJECT_NOT_FOUND = \"project-not-found\",\r\n    QUOTA_EXCEEDED = \"quota-exceeded\",\r\n    UNAUTHENTICATED = \"unauthenticated\",\r\n    UNAUTHORIZED = \"unauthorized\",\r\n    UNAUTHORIZED_APP = \"unauthorized-app\",\r\n    RETRY_LIMIT_EXCEEDED = \"retry-limit-exceeded\",\r\n    INVALID_CHECKSUM = \"invalid-checksum\",\r\n    CANCELED = \"canceled\",\r\n    INVALID_EVENT_NAME = \"invalid-event-name\",\r\n    INVALID_URL = \"invalid-url\",\r\n    INVALID_DEFAULT_BUCKET = \"invalid-default-bucket\",\r\n    NO_DEFAULT_BUCKET = \"no-default-bucket\",\r\n    CANNOT_SLICE_BLOB = \"cannot-slice-blob\",\r\n    SERVER_FILE_WRONG_SIZE = \"server-file-wrong-size\",\r\n    NO_DOWNLOAD_URL = \"no-download-url\",\r\n    INVALID_ARGUMENT = \"invalid-argument\",\r\n    INVALID_ARGUMENT_COUNT = \"invalid-argument-count\",\r\n    APP_DELETED = \"app-deleted\",\r\n    INVALID_ROOT_OPERATION = \"invalid-root-operation\",\r\n    INVALID_FORMAT = \"invalid-format\",\r\n    INTERNAL_ERROR = \"internal-error\",\r\n    UNSUPPORTED_ENVIRONMENT = \"unsupported-environment\",\r\n  }\r\n\r\n  interface StorageObserver<T> {\r\n    next?: NextFn<T> | null;\r\n    error?: (error: FirebaseStorageError) => void | null;\r\n    complete?: CompleteFn | null;\r\n  }\r\n\r\n  /**\r\n   * Represents the process of uploading an object. Allows you to monitor and\r\n   * manage the upload.\r\n   */\r\n  interface UploadTask {\r\n    /**\r\n     * Cancels a running task. Has no effect on a complete or failed task.\r\n     * @return True if the cancel had an effect.\r\n     */\r\n    cancel(): boolean;\r\n    /**\r\n     * Equivalent to calling `then(null, onRejected)`.\r\n     */\r\n    catch(onRejected: (error: FirebaseStorageError) => any): Promise<any>;\r\n    /**\r\n     * Listens for events on this task.\r\n     *\r\n     * Events have three callback functions (referred to as `next`, `error`, and\r\n     * `complete`).\r\n     *\r\n     * If only the event is passed, a function that can be used to register the\r\n     * callbacks is returned. Otherwise, the callbacks are passed after the event.\r\n     *\r\n     * Callbacks can be passed either as three separate arguments <em>or</em> as the\r\n     * `next`, `error`, and `complete` properties of an object. Any of the three\r\n     * callbacks is optional, as long as at least one is specified. In addition,\r\n     * when you add your callbacks, you get a function back. You can call this\r\n     * function to unregister the associated callbacks.\r\n     *\r\n     * @example **Pass callbacks separately or in an object.**\r\n     * ```javascript\r\n     * var next = function(snapshot) {};\r\n     * var error = function(error) {};\r\n     * var complete = function() {};\r\n     *\r\n     * // The first example.\r\n     * uploadTask.on(\r\n     *     firebase.storage.TaskEvent.STATE_CHANGED,\r\n     *     next,\r\n     *     error,\r\n     *     complete);\r\n     *\r\n     * // This is equivalent to the first example.\r\n     * uploadTask.on(firebase.storage.TaskEvent.STATE_CHANGED, {\r\n     *   'next': next,\r\n     *   'error': error,\r\n     *   'complete': complete\r\n     * });\r\n     *\r\n     * // This is equivalent to the first example.\r\n     * var subscribe = uploadTask.on(firebase.storage.TaskEvent.STATE_CHANGED);\r\n     * subscribe(next, error, complete);\r\n     *\r\n     * // This is equivalent to the first example.\r\n     * var subscribe = uploadTask.on(firebase.storage.TaskEvent.STATE_CHANGED);\r\n     * subscribe({\r\n     *   'next': next,\r\n     *   'error': error,\r\n     *   'complete': complete\r\n     * });\r\n     * ```\r\n     *\r\n     * @example **Any callback is optional.**\r\n     * ```javascript\r\n     * // Just listening for completion, this is legal.\r\n     * uploadTask.on(\r\n     *     firebase.storage.TaskEvent.STATE_CHANGED,\r\n     *     null,\r\n     *     null,\r\n     *     function() {\r\n     *       console.log('upload complete!');\r\n     *     });\r\n     *\r\n     * // Just listening for progress/state changes, this is legal.\r\n     * uploadTask.on(firebase.storage.TaskEvent.STATE_CHANGED, function(snapshot) {\r\n     *   var percent = snapshot.bytesTransferred / snapshot.totalBytes * 100;\r\n     *   console.log(percent + \"% done\");\r\n     * });\r\n     *\r\n     * // This is also legal.\r\n     * uploadTask.on(firebase.storage.TaskEvent.STATE_CHANGED, {\r\n     *   'complete': function() {\r\n     *     console.log('upload complete!');\r\n     *   }\r\n     * });\r\n     * ```\r\n     *\r\n     * @example **Use the returned function to remove callbacks.**\r\n     * ```javascript\r\n     * var unsubscribe = uploadTask.on(\r\n     *     firebase.storage.TaskEvent.STATE_CHANGED,\r\n     *     function(snapshot) {\r\n     *       var percent = snapshot.bytesTransferred / snapshot.totalBytes * 100;\r\n     *       console.log(percent + \"% done\");\r\n     *       // Stop after receiving one update.\r\n     *       unsubscribe();\r\n     *     });\r\n     *\r\n     * // This code is equivalent to the above.\r\n     * var handle = uploadTask.on(firebase.storage.TaskEvent.STATE_CHANGED);\r\n     * unsubscribe = handle(function(snapshot) {\r\n     *   var percent = snapshot.bytesTransferred / snapshot.totalBytes * 100;\r\n     *   console.log(percent + \"% done\");\r\n     *   // Stop after receiving one update.\r\n     *   unsubscribe();\r\n     * });\r\n     * ```\r\n     *\r\n     * @param event The event to listen for.\r\n     * @param nextOrObserver\r\n     *     The `next` function, which gets called for each item in\r\n     *     the event stream, or an observer object with some or all of these three\r\n     *     properties (`next`, `error`, `complete`).\r\n     * @param error A function that gets called with a `FirebaseStorageError`\r\n     *     if the event stream ends due to an error.\r\n     * @param complete A function that gets called if the\r\n     *     event stream ends normally.\r\n     * @return\r\n     *     If only the event argument is passed, returns a function you can use to\r\n     *     add callbacks (see the examples above). If more than just the event\r\n     *     argument is passed, returns a function you can call to unregister the\r\n     *     callbacks.\r\n     */\r\n    on(\r\n      event: firebase.storage.TaskEvent,\r\n      nextOrObserver?:\r\n        | StorageObserver<UploadTaskSnapshot>\r\n        | null\r\n        | ((snapshot: UploadTaskSnapshot) => any),\r\n      error?: ((error: FirebaseStorageError) => any) | null,\r\n      complete?: firebase.Unsubscribe | null,\r\n    ): Function;\r\n    /**\r\n     * Pauses a running task. Has no effect on a paused or failed task.\r\n     * @return True if the pause had an effect.\r\n     */\r\n    pause(): boolean;\r\n    /**\r\n     * Resumes a paused task. Has no effect on a running or failed task.\r\n     * @return True if the resume had an effect.\r\n     */\r\n    resume(): boolean;\r\n    /**\r\n     * A snapshot of the current task state.\r\n     */\r\n    snapshot: firebase.storage.UploadTaskSnapshot;\r\n    /**\r\n     * This object behaves like a Promise, and resolves with its snapshot data when\r\n     * the upload completes.\r\n     * @param onFulfilled\r\n     *     The fulfillment callback. Promise chaining works as normal.\r\n     * @param onRejected The rejection callback.\r\n     */\r\n    then(\r\n      onFulfilled?:\r\n        | ((snapshot: firebase.storage.UploadTaskSnapshot) => any)\r\n        | null,\r\n      onRejected?: ((error: FirebaseStorageError) => any) | null,\r\n    ): Promise<any>;\r\n  }\r\n\r\n  /**\r\n   * Holds data about the current state of the upload task.\r\n   */\r\n  interface UploadTaskSnapshot {\r\n    /**\r\n     * The number of bytes that have been successfully uploaded so far.\r\n     */\r\n    bytesTransferred: number;\r\n    /**\r\n     * Before the upload completes, contains the metadata sent to the server.\r\n     * After the upload completes, contains the metadata sent back from the server.\r\n     */\r\n    metadata: firebase.storage.FullMetadata;\r\n    /**\r\n     * The reference that spawned this snapshot's upload task.\r\n     */\r\n    ref: firebase.storage.Reference;\r\n    /**\r\n     * The current state of the task.\r\n     */\r\n    state: firebase.storage.TaskState;\r\n    /**\r\n     * The task of which this is a snapshot.\r\n     */\r\n    task: firebase.storage.UploadTask;\r\n    /**\r\n     * The total number of bytes to be uploaded.\r\n     */\r\n    totalBytes: number;\r\n  }\r\n\r\n  /**\r\n   * An error returned by the Firebase Storage SDK.\r\n   */\r\n  export interface FirebaseStorageError extends FirebaseError {\r\n    /**\r\n     * Stores custom error data unique to the `StorageError`.\r\n     */\r\n    customData: {\r\n      serverResponse: string | null;\r\n    };\r\n\r\n    get status(): number;\r\n    set status(status: number);\r\n    /**\r\n     * Compares a `StorageErrorCode` against this error's code, filtering out the prefix.\r\n     */\r\n    _codeEquals(code: StorageErrorCode): boolean;\r\n    /**\r\n     * Optional response message that was added by the server.\r\n     */\r\n    get serverResponse(): null | string;\r\n    set serverResponse(serverResponse: string | null);\r\n  }\r\n}\r\n\r\ndeclare namespace firebase.firestore {\r\n  /**\r\n   * Document data (for use with `DocumentReference.set()`) consists of fields\r\n   * mapped to values.\r\n   */\r\n  export type DocumentData = { [field: string]: any };\r\n\r\n  /**\r\n   * Update data (for use with `DocumentReference.update()`) consists of field\r\n   * paths (e.g. 'foo' or 'foo.baz') mapped to values. Fields that contain dots\r\n   * reference nested fields within the document.\r\n   */\r\n  export type UpdateData = { [fieldPath: string]: any };\r\n\r\n  /**\r\n   * Constant used to indicate the LRU garbage collection should be disabled.\r\n   * Set this value as the `cacheSizeBytes` on the settings passed to the\r\n   * `Firestore` instance.\r\n   */\r\n  export const CACHE_SIZE_UNLIMITED: number;\r\n\r\n  /**\r\n   * Specifies custom configurations for your Cloud Firestore instance.\r\n   * You must set these before invoking any other methods.\r\n   */\r\n  export interface Settings {\r\n    /** The hostname to connect to. */\r\n    host?: string;\r\n    /** Whether to use SSL when connecting. */\r\n    ssl?: boolean;\r\n\r\n    /**\r\n     * An approximate cache size threshold for the on-disk data. If the cache grows beyond this\r\n     * size, Firestore will start removing data that hasn't been recently used. The size is not a\r\n     * guarantee that the cache will stay below that size, only that if the cache exceeds the given\r\n     * size, cleanup will be attempted.\r\n     *\r\n     * The default value is 40 MB. The threshold must be set to at least 1 MB, and can be set to\r\n     * CACHE_SIZE_UNLIMITED to disable garbage collection.\r\n     */\r\n    cacheSizeBytes?: number;\r\n\r\n    /**\r\n     * Forces the SDK’s underlying network transport (WebChannel) to use\r\n     * long-polling. Each response from the backend will be closed immediately\r\n     * after the backend sends data (by default responses are kept open in\r\n     * case the backend has more data to send). This avoids incompatibility\r\n     * issues with certain proxies, antivirus software, etc. that incorrectly\r\n     * buffer traffic indefinitely. Use of this option will cause some\r\n     * performance degradation though.\r\n     *\r\n     * This setting cannot be used with `experimentalAutoDetectLongPolling` and\r\n     * may be removed in a future release. If you find yourself using it to\r\n     * work around a specific network reliability issue, please tell us about\r\n     * it in https://github.com/firebase/firebase-js-sdk/issues/1674.\r\n     *\r\n     * This setting does not work in a Node.js environment.\r\n     */\r\n    experimentalForceLongPolling?: boolean;\r\n\r\n    /**\r\n     * Configures the SDK's underlying transport (WebChannel) to automatically detect if\r\n     * long-polling should be used. This is very similar to `experimentalForceLongPolling`,\r\n     * but only uses long-polling if required.\r\n     *\r\n     * This setting will likely be enabled by default in future releases and cannot be\r\n     * combined with `experimentalForceLongPolling`.\r\n     *\r\n     * This setting does not work in a Node.js environment.\r\n     */\r\n    experimentalAutoDetectLongPolling?: boolean;\r\n\r\n    /**\r\n     * Whether to skip nested properties that are set to `undefined` during\r\n     * object serialization. If set to `true`, these properties are skipped\r\n     * and not written to Firestore. If set to `false` or omitted, the SDK\r\n     * throws an exception when it encounters properties of type `undefined`.\r\n     */\r\n    ignoreUndefinedProperties?: boolean;\r\n\r\n    /**\r\n     * Whether to merge the provided settings with the existing settings. If\r\n     * set to `true`, the settings are merged with existing settings. If\r\n     * set to `false` or left unset, the settings replace the existing\r\n     * settings.\r\n     */\r\n    merge?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Settings that can be passed to Firestore.enablePersistence() to configure\r\n   * Firestore persistence.\r\n   */\r\n  export interface PersistenceSettings {\r\n    /**\r\n     * Whether to synchronize the in-memory state of multiple tabs. Setting this\r\n     * to `true` in all open tabs enables shared access to local persistence,\r\n     * shared execution of queries and latency-compensated local document updates\r\n     * across all connected instances.\r\n     *\r\n     * To enable this mode, `synchronizeTabs:true` needs to be set globally in all\r\n     * active tabs. If omitted or set to 'false', `enablePersistence()` will fail\r\n     * in all but the first tab.\r\n     */\r\n    synchronizeTabs?: boolean;\r\n\r\n    /**\r\n     * Whether to force enable persistence for the client. This cannot be used\r\n     * with `synchronizeTabs:true` and is primarily intended for use with Web\r\n     * Workers. Setting this to `true` will enable persistence, but cause other\r\n     * tabs using persistence to fail.\r\n     *\r\n     * This setting may be removed in a future release. If you find yourself\r\n     * using it for a specific use case or run into any issues, please tell us\r\n     * about it in\r\n     * https://github.com/firebase/firebase-js-sdk/issues/983.\r\n     */\r\n    experimentalForceOwningTab?: boolean;\r\n  }\r\n\r\n  export type LogLevel = \"debug\" | \"error\" | \"silent\";\r\n\r\n  /**\r\n   * Sets the verbosity of Cloud Firestore logs (debug, error, or silent).\r\n   *\r\n   * @param logLevel\r\n   *   The verbosity you set for activity and error logging. Can be any of\r\n   *   the following values:\r\n   *\r\n   *   <ul>\r\n   *     <li><code>debug</code> for the most verbose logging level, primarily for\r\n   *     debugging.</li>\r\n   *     <li><code>error</code> to log errors only.</li>\r\n   *     <li><code>silent</code> to turn off logging.</li>\r\n   *   </ul>\r\n   */\r\n  export function setLogLevel(logLevel: LogLevel): void;\r\n\r\n  /**\r\n   * Converter used by `withConverter()` to transform user objects of type T\r\n   * into Firestore data.\r\n   *\r\n   * Using the converter allows you to specify generic type arguments when\r\n   * storing and retrieving objects from Firestore.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * class Post {\r\n   *   constructor(readonly title: string, readonly author: string) {}\r\n   *\r\n   *   toString(): string {\r\n   *     return this.title + ', by ' + this.author;\r\n   *   }\r\n   * }\r\n   *\r\n   * const postConverter = {\r\n   *   toFirestore(post: Post): firebase.firestore.DocumentData {\r\n   *     return {title: post.title, author: post.author};\r\n   *   },\r\n   *   fromFirestore(\r\n   *     snapshot: firebase.firestore.QueryDocumentSnapshot,\r\n   *     options: firebase.firestore.SnapshotOptions\r\n   *   ): Post {\r\n   *     const data = snapshot.data(options)!;\r\n   *     return new Post(data.title, data.author);\r\n   *   }\r\n   * };\r\n   *\r\n   * const postSnap = await firebase.firestore()\r\n   *   .collection('posts')\r\n   *   .withConverter(postConverter)\r\n   *   .doc().get();\r\n   * const post = postSnap.data();\r\n   * if (post !== undefined) {\r\n   *   post.title; // string\r\n   *   post.toString(); // Should be defined\r\n   *   post.someNonExistentProperty; // TS error\r\n   * }\r\n   * ```\r\n   */\r\n  export interface FirestoreDataConverter<T> {\r\n    /**\r\n     * Called by the Firestore SDK to convert a custom model object of type T\r\n     * into a plain JavaScript object (suitable for writing directly to the\r\n     * Firestore database). To use `set()` with `merge` and `mergeFields`,\r\n     * `toFirestore()` must be defined with `Partial<T>`.\r\n     */\r\n    toFirestore(modelObject: T): DocumentData;\r\n    toFirestore(modelObject: Partial<T>, options: SetOptions): DocumentData;\r\n\r\n    /**\r\n     * Called by the Firestore SDK to convert Firestore data into an object of\r\n     * type T. You can access your data by calling: `snapshot.data(options)`.\r\n     *\r\n     * @param snapshot A QueryDocumentSnapshot containing your data and metadata.\r\n     * @param options The SnapshotOptions from the initial call to `data()`.\r\n     */\r\n    fromFirestore(snapshot: QueryDocumentSnapshot, options: SnapshotOptions): T;\r\n  }\r\n\r\n  /**\r\n   * The Cloud Firestore service interface.\r\n   *\r\n   * Do not call this constructor directly. Instead, use\r\n   * {@link firebase.firestore `firebase.firestore()`}.\r\n   */\r\n  export class Firestore {\r\n    private constructor();\r\n    /**\r\n     * Specifies custom settings to be used to configure the `Firestore`\r\n     * instance. Must be set before invoking any other methods.\r\n     *\r\n     * @param settings The settings to use.\r\n     */\r\n    settings(settings: Settings): void;\r\n\r\n    /**\r\n     * Modify this instance to communicate with the Cloud Firestore emulator.\r\n     *\r\n     * <p>Note: this must be called before this instance has been used to do any operations.\r\n     *\r\n     * @param host the emulator host (ex: localhost).\r\n     * @param port the emulator port (ex: 9000).\r\n     * @param options.mockUserToken - the mock auth token to use for unit\r\n     * testing Security Rules.\r\n     */\r\n    useEmulator(\r\n      host: string,\r\n      port: number,\r\n      options?: {\r\n        mockUserToken?: EmulatorMockTokenOptions | string;\r\n      },\r\n    ): void;\r\n\r\n    /**\r\n     * Attempts to enable persistent storage, if possible.\r\n     *\r\n     * Must be called before any other methods (other than settings() and\r\n     * clearPersistence()).\r\n     *\r\n     * If this fails, enablePersistence() will reject the promise it returns.\r\n     * Note that even after this failure, the firestore instance will remain\r\n     * usable, however offline persistence will be disabled.\r\n     *\r\n     * There are several reasons why this can fail, which can be identified by\r\n     * the `code` on the error.\r\n     *\r\n     *   * failed-precondition: The app is already open in another browser tab.\r\n     *   * unimplemented: The browser is incompatible with the offline\r\n     *     persistence implementation.\r\n     *\r\n     * @param settings Optional settings object to configure persistence.\r\n     * @return A promise that represents successfully enabling persistent\r\n     * storage.\r\n     */\r\n    enablePersistence(settings?: PersistenceSettings): Promise<void>;\r\n\r\n    /**\r\n     * Gets a `CollectionReference` instance that refers to the collection at\r\n     * the specified path.\r\n     *\r\n     * @param collectionPath A slash-separated path to a collection.\r\n     * @return The `CollectionReference` instance.\r\n     */\r\n    collection(collectionPath: string): CollectionReference<DocumentData>;\r\n\r\n    /**\r\n     * Gets a `DocumentReference` instance that refers to the document at the\r\n     * specified path.\r\n     *\r\n     * @param documentPath A slash-separated path to a document.\r\n     * @return The `DocumentReference` instance.\r\n     */\r\n    doc(documentPath: string): DocumentReference<DocumentData>;\r\n\r\n    /**\r\n     * Creates and returns a new Query that includes all documents in the\r\n     * database that are contained in a collection or subcollection with the\r\n     * given collectionId.\r\n     *\r\n     * @param collectionId Identifies the collections to query over. Every\r\n     * collection or subcollection with this ID as the last segment of its path\r\n     * will be included. Cannot contain a slash.\r\n     * @return The created Query.\r\n     */\r\n    collectionGroup(collectionId: string): Query<DocumentData>;\r\n\r\n    /**\r\n     * Executes the given `updateFunction` and then attempts to commit the changes\r\n     * applied within the transaction. If any document read within the transaction\r\n     * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\r\n     * commit after 5 attempts, the transaction fails.\r\n     *\r\n     * The maximum number of writes allowed in a single transaction is 500, but\r\n     * note that each usage of `FieldValue.serverTimestamp()`,\r\n     * `FieldValue.arrayUnion()`, `FieldValue.arrayRemove()`, or\r\n     * `FieldValue.increment()` inside a transaction counts as an additional write.\r\n     *\r\n     * @param updateFunction\r\n     *   The function to execute within the transaction context.\r\n     *\r\n     * @return\r\n     *   If the transaction completed successfully or was explicitly aborted\r\n     *   (the `updateFunction` returned a failed promise),\r\n     *   the promise returned by the updateFunction is returned here. Else, if the\r\n     *   transaction failed, a rejected promise with the corresponding failure\r\n     *   error will be returned.\r\n     */\r\n    runTransaction<T>(\r\n      updateFunction: (transaction: Transaction) => Promise<T>,\r\n    ): Promise<T>;\r\n\r\n    /**\r\n     * Creates a write batch, used for performing multiple writes as a single\r\n     * atomic operation. The maximum number of writes allowed in a single WriteBatch\r\n     * is 500, but note that each usage of `FieldValue.serverTimestamp()`,\r\n     * `FieldValue.arrayUnion()`, `FieldValue.arrayRemove()`, or\r\n     * `FieldValue.increment()` inside a WriteBatch counts as an additional write.\r\n     *\r\n     * @return\r\n     *   A `WriteBatch` that can be used to atomically execute multiple writes.\r\n     */\r\n    batch(): WriteBatch;\r\n\r\n    /**\r\n     * The {@link firebase.app.App app} associated with this `Firestore` service\r\n     * instance.\r\n     */\r\n    app: firebase.app.App;\r\n\r\n    /**\r\n     * Clears the persistent storage. This includes pending writes and cached\r\n     * documents.\r\n     *\r\n     * Must be called while the firestore instance is not started (after the app\r\n     * is shutdown or when the app is first initialized). On startup, this\r\n     * method must be called before other methods (other than settings()). If\r\n     * the firestore instance is still running, the promise will be rejected\r\n     * with the error code of `failed-precondition`.\r\n     *\r\n     * Note: clearPersistence() is primarily intended to help write reliable\r\n     * tests that use Cloud Firestore. It uses an efficient mechanism for\r\n     * dropping existing data but does not attempt to securely overwrite or\r\n     * otherwise make cached data unrecoverable. For applications that are\r\n     * sensitive to the disclosure of cached data in between user sessions, we\r\n     * strongly recommend not enabling persistence at all.\r\n     *\r\n     * @return A promise that is resolved when the persistent storage is\r\n     * cleared. Otherwise, the promise is rejected with an error.\r\n     */\r\n    clearPersistence(): Promise<void>;\r\n\r\n    /**\r\n     * Re-enables use of the network for this Firestore instance after a prior\r\n     * call to {@link firebase.firestore.Firestore.disableNetwork\r\n     * `disableNetwork()`}.\r\n     *\r\n     * @return A promise that is resolved once the network has been\r\n     *   enabled.\r\n     */\r\n    enableNetwork(): Promise<void>;\r\n\r\n    /**\r\n     * Disables network usage for this instance. It can be re-enabled via\r\n     * {@link firebase.firestore.Firestore.enableNetwork `enableNetwork()`}. While\r\n     * the network is disabled, any snapshot listeners or get() calls will return\r\n     * results from cache, and any write operations will be queued until the network\r\n     * is restored.\r\n     *\r\n     * @return A promise that is resolved once the network has been\r\n     *   disabled.\r\n     */\r\n    disableNetwork(): Promise<void>;\r\n\r\n    /**\r\n     * Waits until all currently pending writes for the active user have been acknowledged by the\r\n     * backend.\r\n     *\r\n     * The returned Promise resolves immediately if there are no outstanding writes. Otherwise, the\r\n     * Promise waits for all previously issued writes (including those written in a previous app\r\n     * session), but it does not wait for writes that were added after the method is called. If you\r\n     * want to wait for additional writes, call `waitForPendingWrites()` again.\r\n     *\r\n     * Any outstanding `waitForPendingWrites()` Promises are rejected during user changes.\r\n     *\r\n     * @return A Promise which resolves when all currently pending writes have been\r\n     * acknowledged by the backend.\r\n     */\r\n    waitForPendingWrites(): Promise<void>;\r\n\r\n    /**\r\n     * Attaches a listener for a snapshots-in-sync event. The snapshots-in-sync\r\n     * event indicates that all listeners affected by a given change have fired,\r\n     * even if a single server-generated change affects multiple listeners.\r\n     *\r\n     * NOTE: The snapshots-in-sync event only indicates that listeners are in sync\r\n     * with each other, but does not relate to whether those snapshots are in sync\r\n     * with the server. Use SnapshotMetadata in the individual listeners to\r\n     * determine if a snapshot is from the cache or the server.\r\n     *\r\n     * @param observer A single object containing `next` and `error` callbacks.\r\n     * @return An unsubscribe function that can be called to cancel the snapshot\r\n     * listener.\r\n     */\r\n    onSnapshotsInSync(observer: {\r\n      next?: (value: void) => void;\r\n      error?: (error: FirestoreError) => void;\r\n      complete?: () => void;\r\n    }): () => void;\r\n\r\n    /**\r\n     * Attaches a listener for a snapshots-in-sync event. The snapshots-in-sync\r\n     * event indicates that all listeners affected by a given change have fired,\r\n     * even if a single server-generated change affects multiple listeners.\r\n     *\r\n     * NOTE: The snapshots-in-sync event only indicates that listeners are in sync\r\n     * with each other, but does not relate to whether those snapshots are in sync\r\n     * with the server. Use SnapshotMetadata in the individual listeners to\r\n     * determine if a snapshot is from the cache or the server.\r\n     *\r\n     * @param onSync A callback to be called every time all snapshot listeners are\r\n     * in sync with each other.\r\n     * @return An unsubscribe function that can be called to cancel the snapshot\r\n     * listener.\r\n     */\r\n    onSnapshotsInSync(onSync: () => void): () => void;\r\n\r\n    /**\r\n     * Terminates this Firestore instance.\r\n     *\r\n     * After calling `terminate()` only the `clearPersistence()` method may be used. Any other method\r\n     * will throw a `FirestoreError`.\r\n     *\r\n     * To restart after termination, create a new instance of FirebaseFirestore with\r\n     * `firebase.firestore()`.\r\n     *\r\n     * Termination does not cancel any pending writes, and any promises that are awaiting a response\r\n     * from the server will not be resolved. If you have persistence enabled, the next time you\r\n     * start this instance, it will resume sending these writes to the server.\r\n     *\r\n     * Note: Under normal circumstances, calling `terminate()` is not required. This\r\n     * method is useful only when you want to force this instance to release all of its resources or\r\n     * in combination with `clearPersistence()` to ensure that all local state is destroyed\r\n     * between test runs.\r\n     *\r\n     * @return A promise that is resolved when the instance has been successfully terminated.\r\n     */\r\n    terminate(): Promise<void>;\r\n\r\n    /**\r\n     * Loads a Firestore bundle into the local cache.\r\n     *\r\n     * @param bundleData\r\n     *   An object representing the bundle to be loaded. Valid objects are `ArrayBuffer`,\r\n     *   `ReadableStream<Uint8Array>` or `string`.\r\n     *\r\n     * @return\r\n     *   A `LoadBundleTask` object, which notifies callers with progress updates, and completion\r\n     *   or error events. It can be used as a `Promise<LoadBundleTaskProgress>`.\r\n     */\r\n    loadBundle(\r\n      bundleData: ArrayBuffer | ReadableStream<Uint8Array> | string,\r\n    ): LoadBundleTask;\r\n\r\n    /**\r\n     * Reads a Firestore `Query` from local cache, identified by the given name.\r\n     *\r\n     * The named queries are packaged  into bundles on the server side (along\r\n     * with resulting documents), and loaded to local cache using `loadBundle`. Once in local\r\n     * cache, use this method to extract a `Query` by name.\r\n     */\r\n    namedQuery(name: string): Promise<Query<DocumentData> | null>;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    INTERNAL: { delete: () => Promise<void> };\r\n  }\r\n\r\n  /**\r\n   * Represents the task of loading a Firestore bundle. It provides progress of bundle\r\n   * loading, as well as task completion and error events.\r\n   *\r\n   * The API is compatible with `Promise<LoadBundleTaskProgress>`.\r\n   */\r\n  export interface LoadBundleTask extends PromiseLike<LoadBundleTaskProgress> {\r\n    /**\r\n     * Registers functions to listen to bundle loading progress events.\r\n     * @param next\r\n     *   Called when there is a progress update from bundle loading. Typically `next` calls occur\r\n     *   each time a Firestore document is loaded from the bundle.\r\n     * @param error\r\n     *   Called when an error occurs during bundle loading. The task aborts after reporting the\r\n     *   error, and there should be no more updates after this.\r\n     * @param complete\r\n     *   Called when the loading task is complete.\r\n     */\r\n    onProgress(\r\n      next?: (progress: LoadBundleTaskProgress) => any,\r\n      error?: (error: Error) => any,\r\n      complete?: () => void,\r\n    ): void;\r\n\r\n    /**\r\n     * Implements the `Promise<LoadBundleTaskProgress>.then` interface.\r\n     *\r\n     * @param onFulfilled\r\n     *   Called on the completion of the loading task with a final `LoadBundleTaskProgress` update.\r\n     *   The update will always have its `taskState` set to `\"Success\"`.\r\n     * @param onRejected\r\n     *   Called when an error occurs during bundle loading.\r\n     */\r\n    then<T, R>(\r\n      onFulfilled?: (a: LoadBundleTaskProgress) => T | PromiseLike<T>,\r\n      onRejected?: (a: Error) => R | PromiseLike<R>,\r\n    ): Promise<T | R>;\r\n\r\n    /**\r\n     * Implements the `Promise<LoadBundleTaskProgress>.catch` interface.\r\n     *\r\n     * @param onRejected\r\n     *   Called when an error occurs during bundle loading.\r\n     */\r\n    catch<R>(\r\n      onRejected: (a: Error) => R | PromiseLike<R>,\r\n    ): Promise<R | LoadBundleTaskProgress>;\r\n  }\r\n\r\n  /**\r\n   * Represents a progress update or a final state from loading bundles.\r\n   */\r\n  export interface LoadBundleTaskProgress {\r\n    /** How many documents have been loaded. */\r\n    documentsLoaded: number;\r\n    /** How many documents are in the bundle being loaded. */\r\n    totalDocuments: number;\r\n    /** How many bytes have been loaded. */\r\n    bytesLoaded: number;\r\n    /** How many bytes are in the bundle being loaded. */\r\n    totalBytes: number;\r\n    /** Current task state. */\r\n    taskState: TaskState;\r\n  }\r\n\r\n  /**\r\n   * Represents the state of bundle loading tasks.\r\n   *\r\n   * Both 'Error' and 'Success' are sinking state: task will abort or complete and there will\r\n   * be no more updates after they are reported.\r\n   */\r\n  export type TaskState = \"Error\" | \"Running\" | \"Success\";\r\n\r\n  /**\r\n   * An immutable object representing a geo point in Firestore. The geo point\r\n   * is represented as latitude/longitude pair.\r\n   *\r\n   * Latitude values are in the range of [-90, 90].\r\n   * Longitude values are in the range of [-180, 180].\r\n   */\r\n  export class GeoPoint {\r\n    /**\r\n     * Creates a new immutable GeoPoint object with the provided latitude and\r\n     * longitude values.\r\n     * @param latitude The latitude as number between -90 and 90.\r\n     * @param longitude The longitude as number between -180 and 180.\r\n     */\r\n    constructor(latitude: number, longitude: number);\r\n\r\n    /**\r\n     * The latitude of this GeoPoint instance.\r\n     */\r\n    readonly latitude: number;\r\n    /**\r\n     * The longitude of this GeoPoint instance.\r\n     */\r\n    readonly longitude: number;\r\n\r\n    /**\r\n     * Returns true if this `GeoPoint` is equal to the provided one.\r\n     *\r\n     * @param other The `GeoPoint` to compare against.\r\n     * @return true if this `GeoPoint` is equal to the provided one.\r\n     */\r\n    isEqual(other: GeoPoint): boolean;\r\n  }\r\n\r\n  /**\r\n   * A Timestamp represents a point in time independent of any time zone or\r\n   * calendar, represented as seconds and fractions of seconds at nanosecond\r\n   * resolution in UTC Epoch time.\r\n   *\r\n   * It is encoded using the Proleptic Gregorian\r\n   * Calendar which extends the Gregorian calendar backwards to year one. It is\r\n   * encoded assuming all minutes are 60 seconds long, i.e. leap seconds are\r\n   * \"smeared\" so that no leap second table is needed for interpretation. Range is\r\n   * from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z.\r\n   *\r\n   * @see https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto\r\n   */\r\n  export class Timestamp {\r\n    /**\r\n     * Creates a new timestamp.\r\n     *\r\n     * @param seconds The number of seconds of UTC time since Unix epoch\r\n     *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\r\n     *     9999-12-31T23:59:59Z inclusive.\r\n     * @param nanoseconds The non-negative fractions of a second at nanosecond\r\n     *     resolution. Negative second values with fractions must still have\r\n     *     non-negative nanoseconds values that count forward in time. Must be\r\n     *     from 0 to 999,999,999 inclusive.\r\n     */\r\n    constructor(seconds: number, nanoseconds: number);\r\n\r\n    /**\r\n     * Creates a new timestamp with the current date, with millisecond precision.\r\n     *\r\n     * @return a new timestamp representing the current date.\r\n     */\r\n    static now(): Timestamp;\r\n\r\n    /**\r\n     * Creates a new timestamp from the given date.\r\n     *\r\n     * @param date The date to initialize the `Timestamp` from.\r\n     * @return A new `Timestamp` representing the same point in time as the given\r\n     *     date.\r\n     */\r\n    static fromDate(date: Date): Timestamp;\r\n\r\n    /**\r\n     * Creates a new timestamp from the given number of milliseconds.\r\n     *\r\n     * @param milliseconds Number of milliseconds since Unix epoch\r\n     *     1970-01-01T00:00:00Z.\r\n     * @return A new `Timestamp` representing the same point in time as the given\r\n     *     number of milliseconds.\r\n     */\r\n    static fromMillis(milliseconds: number): Timestamp;\r\n\r\n    readonly seconds: number;\r\n    readonly nanoseconds: number;\r\n\r\n    /**\r\n     * Convert a Timestamp to a JavaScript `Date` object. This conversion causes\r\n     * a loss of precision since `Date` objects only support millisecond precision.\r\n     *\r\n     * @return JavaScript `Date` object representing the same point in time as\r\n     *     this `Timestamp`, with millisecond precision.\r\n     */\r\n    toDate(): Date;\r\n\r\n    /**\r\n     * Convert a timestamp to a numeric timestamp (in milliseconds since epoch).\r\n     * This operation causes a loss of precision.\r\n     *\r\n     * @return The point in time corresponding to this timestamp, represented as\r\n     *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\r\n     */\r\n    toMillis(): number;\r\n\r\n    /**\r\n     * Returns true if this `Timestamp` is equal to the provided one.\r\n     *\r\n     * @param other The `Timestamp` to compare against.\r\n     * @return true if this `Timestamp` is equal to the provided one.\r\n     */\r\n    isEqual(other: Timestamp): boolean;\r\n\r\n    /**\r\n     * Converts this object to a primitive string, which allows Timestamp objects to be compared\r\n     * using the `>`, `<=`, `>=` and `>` operators.\r\n     */\r\n    valueOf(): string;\r\n  }\r\n\r\n  /**\r\n   * An immutable object representing an array of bytes.\r\n   */\r\n  export class Blob {\r\n    private constructor();\r\n\r\n    /**\r\n     * Creates a new Blob from the given Base64 string, converting it to\r\n     * bytes.\r\n     *\r\n     * @param base64\r\n     *   The Base64 string used to create the Blob object.\r\n     */\r\n    static fromBase64String(base64: string): Blob;\r\n\r\n    /**\r\n     * Creates a new Blob from the given Uint8Array.\r\n     *\r\n     * @param array\r\n     *   The Uint8Array used to create the Blob object.\r\n     */\r\n    static fromUint8Array(array: Uint8Array): Blob;\r\n\r\n    /**\r\n     * Returns the bytes of a Blob as a Base64-encoded string.\r\n     *\r\n     * @return\r\n     *   The Base64-encoded string created from the Blob object.\r\n     */\r\n    public toBase64(): string;\r\n\r\n    /**\r\n     * Returns the bytes of a Blob in a new Uint8Array.\r\n     *\r\n     * @return\r\n     *   The Uint8Array created from the Blob object.\r\n     */\r\n    public toUint8Array(): Uint8Array;\r\n\r\n    /**\r\n     * Returns true if this `Blob` is equal to the provided one.\r\n     *\r\n     * @param other The `Blob` to compare against.\r\n     * @return true if this `Blob` is equal to the provided one.\r\n     */\r\n    isEqual(other: Blob): boolean;\r\n  }\r\n\r\n  /**\r\n   * A reference to a transaction.\r\n   * The `Transaction` object passed to a transaction's updateFunction provides\r\n   * the methods to read and write data within the transaction context. See\r\n   * `Firestore.runTransaction()`.\r\n   */\r\n  export class Transaction {\r\n    private constructor();\r\n\r\n    /**\r\n     * Reads the document referenced by the provided `DocumentReference.`\r\n     *\r\n     * @param documentRef A reference to the document to be read.\r\n     * @return A DocumentSnapshot for the read data.\r\n     */\r\n    get<T>(documentRef: DocumentReference<T>): Promise<DocumentSnapshot<T>>;\r\n\r\n    /**\r\n     * Writes to the document referred to by the provided `DocumentReference`.\r\n     * If the document does not exist yet, it will be created. If you pass\r\n     * `SetOptions`, the provided data can be merged into the existing document.\r\n     *\r\n     * @param documentRef A reference to the document to be set.\r\n     * @param data An object of the fields and values for the document.\r\n     * @param options An object to configure the set behavior.\r\n     * @return This `Transaction` instance. Used for chaining method calls.\r\n     */\r\n    set<T>(\r\n      documentRef: DocumentReference<T>,\r\n      data: Partial<T>,\r\n      options: SetOptions,\r\n    ): Transaction;\r\n\r\n    /**\r\n     * Writes to the document referred to by the provided `DocumentReference`.\r\n     * If the document does not exist yet, it will be created. If you pass\r\n     * `SetOptions`, the provided data can be merged into the existing document.\r\n     *\r\n     * @param documentRef A reference to the document to be set.\r\n     * @param data An object of the fields and values for the document.\r\n     * @return This `Transaction` instance. Used for chaining method calls.\r\n     */\r\n    set<T>(documentRef: DocumentReference<T>, data: T): Transaction;\r\n\r\n    /**\r\n     * Updates fields in the document referred to by the provided\r\n     * `DocumentReference`. The update will fail if applied to a document that\r\n     * does not exist.\r\n     *\r\n     * @param documentRef A reference to the document to be updated.\r\n     * @param data An object containing the fields and values with which to\r\n     * update the document. Fields can contain dots to reference nested fields\r\n     * within the document.\r\n     * @return This `Transaction` instance. Used for chaining method calls.\r\n     */\r\n    update(documentRef: DocumentReference<any>, data: UpdateData): Transaction;\r\n\r\n    /**\r\n     * Updates fields in the document referred to by the provided\r\n     * `DocumentReference`. The update will fail if applied to a document that\r\n     * does not exist.\r\n     *\r\n     * Nested fields can be updated by providing dot-separated field path\r\n     * strings or by providing FieldPath objects.\r\n     *\r\n     * @param documentRef A reference to the document to be updated.\r\n     * @param field The first field to update.\r\n     * @param value The first value.\r\n     * @param moreFieldsAndValues Additional key/value pairs.\r\n     * @return A Promise resolved once the data has been successfully written\r\n     * to the backend (Note that it won't resolve while you're offline).\r\n     */\r\n    update(\r\n      documentRef: DocumentReference<any>,\r\n      field: string | FieldPath,\r\n      value: any,\r\n      ...moreFieldsAndValues: any[]\r\n    ): Transaction;\r\n\r\n    /**\r\n     * Deletes the document referred to by the provided `DocumentReference`.\r\n     *\r\n     * @param documentRef A reference to the document to be deleted.\r\n     * @return This `Transaction` instance. Used for chaining method calls.\r\n     */\r\n    delete(documentRef: DocumentReference<any>): Transaction;\r\n  }\r\n\r\n  /**\r\n   * A write batch, used to perform multiple writes as a single atomic unit.\r\n   *\r\n   * A `WriteBatch` object can be acquired by calling `Firestore.batch()`. It\r\n   * provides methods for adding writes to the write batch. None of the\r\n   * writes will be committed (or visible locally) until `WriteBatch.commit()`\r\n   * is called.\r\n   *\r\n   * Unlike transactions, write batches are persisted offline and therefore are\r\n   * preferable when you don't need to condition your writes on read data.\r\n   */\r\n  export class WriteBatch {\r\n    private constructor();\r\n\r\n    /**\r\n     * Writes to the document referred to by the provided `DocumentReference`.\r\n     * If the document does not exist yet, it will be created. If you pass\r\n     * `SetOptions`, the provided data can be merged into the existing document.\r\n     *\r\n     * @param documentRef A reference to the document to be set.\r\n     * @param data An object of the fields and values for the document.\r\n     * @param options An object to configure the set behavior.\r\n     * @return This `WriteBatch` instance. Used for chaining method calls.\r\n     */\r\n    set<T>(\r\n      documentRef: DocumentReference<T>,\r\n      data: Partial<T>,\r\n      options: SetOptions,\r\n    ): WriteBatch;\r\n\r\n    /**\r\n     * Writes to the document referred to by the provided `DocumentReference`.\r\n     * If the document does not exist yet, it will be created. If you pass\r\n     * `SetOptions`, the provided data can be merged into the existing document.\r\n     *\r\n     * @param documentRef A reference to the document to be set.\r\n     * @param data An object of the fields and values for the document.\r\n     * @return This `WriteBatch` instance. Used for chaining method calls.\r\n     */\r\n    set<T>(documentRef: DocumentReference<T>, data: T): WriteBatch;\r\n\r\n    /**\r\n     * Updates fields in the document referred to by the provided\r\n     * `DocumentReference`. The update will fail if applied to a document that\r\n     * does not exist.\r\n     *\r\n     * @param documentRef A reference to the document to be updated.\r\n     * @param data An object containing the fields and values with which to\r\n     * update the document. Fields can contain dots to reference nested fields\r\n     * within the document.\r\n     * @return This `WriteBatch` instance. Used for chaining method calls.\r\n     */\r\n    update(documentRef: DocumentReference<any>, data: UpdateData): WriteBatch;\r\n\r\n    /**\r\n     * Updates fields in the document referred to by this `DocumentReference`.\r\n     * The update will fail if applied to a document that does not exist.\r\n     *\r\n     * Nested fields can be update by providing dot-separated field path strings\r\n     * or by providing FieldPath objects.\r\n     *\r\n     * @param documentRef A reference to the document to be updated.\r\n     * @param field The first field to update.\r\n     * @param value The first value.\r\n     * @param moreFieldsAndValues Additional key value pairs.\r\n     * @return A Promise resolved once the data has been successfully written\r\n     * to the backend (Note that it won't resolve while you're offline).\r\n     */\r\n    update(\r\n      documentRef: DocumentReference<any>,\r\n      field: string | FieldPath,\r\n      value: any,\r\n      ...moreFieldsAndValues: any[]\r\n    ): WriteBatch;\r\n\r\n    /**\r\n     * Deletes the document referred to by the provided `DocumentReference`.\r\n     *\r\n     * @param documentRef A reference to the document to be deleted.\r\n     * @return This `WriteBatch` instance. Used for chaining method calls.\r\n     */\r\n    delete(documentRef: DocumentReference<any>): WriteBatch;\r\n\r\n    /**\r\n     * Commits all of the writes in this write batch as a single atomic unit.\r\n     *\r\n     * @return A Promise resolved once all of the writes in the batch have been\r\n     * successfully written to the backend as an atomic unit. Note that it won't\r\n     * resolve while you're offline.\r\n     */\r\n    commit(): Promise<void>;\r\n  }\r\n\r\n  /**\r\n   * An options object that can be passed to `DocumentReference.onSnapshot()`,\r\n   * `Query.onSnapshot()` and `QuerySnapshot.docChanges()` to control which\r\n   * types of changes to include in the result set.\r\n   */\r\n  export interface SnapshotListenOptions {\r\n    /**\r\n     * Include a change even if only the metadata of the query or of a document\r\n     * changed. Default is false.\r\n     */\r\n    readonly includeMetadataChanges?: boolean;\r\n  }\r\n\r\n  /**\r\n   * An options object that configures the behavior of `set()` calls in\r\n   * {@link firebase.firestore.DocumentReference.set DocumentReference}, {@link\r\n   * firebase.firestore.WriteBatch.set WriteBatch} and {@link\r\n   * firebase.firestore.Transaction.set Transaction}. These calls can be\r\n   * configured to perform granular merges instead of overwriting the target\r\n   * documents in their entirety by providing a `SetOptions` with `merge: true`.\r\n   */\r\n  export interface SetOptions {\r\n    /**\r\n     * Changes the behavior of a set() call to only replace the values specified\r\n     * in its data argument. Fields omitted from the set() call remain\r\n     * untouched.\r\n     */\r\n    readonly merge?: boolean;\r\n\r\n    /**\r\n     * Changes the behavior of set() calls to only replace the specified field\r\n     * paths. Any field path that is not specified is ignored and remains\r\n     * untouched.\r\n     */\r\n    readonly mergeFields?: (string | FieldPath)[];\r\n  }\r\n\r\n  /**\r\n   * An options object that configures the behavior of `get()` calls on\r\n   * `DocumentReference` and `Query`. By providing a `GetOptions` object, these\r\n   * methods can be configured to fetch results only from the server, only from\r\n   * the local cache or attempt to fetch results from the server and fall back to\r\n   * the cache (which is the default).\r\n   */\r\n  export interface GetOptions {\r\n    /**\r\n     * Describes whether we should get from server or cache.\r\n     *\r\n     * Setting to `default` (or not setting at all), causes Firestore to try to\r\n     * retrieve an up-to-date (server-retrieved) snapshot, but fall back to\r\n     * returning cached data if the server can't be reached.\r\n     *\r\n     * Setting to `server` causes Firestore to avoid the cache, generating an\r\n     * error if the server cannot be reached. Note that the cache will still be\r\n     * updated if the server request succeeds. Also note that latency-compensation\r\n     * still takes effect, so any pending write operations will be visible in the\r\n     * returned data (merged into the server-provided data).\r\n     *\r\n     * Setting to `cache` causes Firestore to immediately return a value from the\r\n     * cache, ignoring the server completely (implying that the returned value\r\n     * may be stale with respect to the value on the server.) If there is no data\r\n     * in the cache to satisfy the `get()` call, `DocumentReference.get()` will\r\n     * return an error and `QuerySnapshot.get()` will return an empty\r\n     * `QuerySnapshot` with no documents.\r\n     */\r\n    readonly source?: \"default\" | \"server\" | \"cache\";\r\n  }\r\n\r\n  /**\r\n   * A `DocumentReference` refers to a document location in a Firestore database\r\n   * and can be used to write, read, or listen to the location. The document at\r\n   * the referenced location may or may not exist. A `DocumentReference` can\r\n   * also be used to create a `CollectionReference` to a subcollection.\r\n   */\r\n  export class DocumentReference<T = DocumentData> {\r\n    private constructor();\r\n\r\n    /**\r\n     * The document's identifier within its collection.\r\n     */\r\n    readonly id: string;\r\n\r\n    /**\r\n     * The {@link firebase.firestore.Firestore} the document is in.\r\n     * This is useful for performing transactions, for example.\r\n     */\r\n    readonly firestore: Firestore;\r\n\r\n    /**\r\n     * The Collection this `DocumentReference` belongs to.\r\n     */\r\n    readonly parent: CollectionReference<T>;\r\n\r\n    /**\r\n     * A string representing the path of the referenced document (relative\r\n     * to the root of the database).\r\n     */\r\n    readonly path: string;\r\n\r\n    /**\r\n     * Gets a `CollectionReference` instance that refers to the collection at\r\n     * the specified path.\r\n     *\r\n     * @param collectionPath A slash-separated path to a collection.\r\n     * @return The `CollectionReference` instance.\r\n     */\r\n    collection(collectionPath: string): CollectionReference<DocumentData>;\r\n\r\n    /**\r\n     * Returns true if this `DocumentReference` is equal to the provided one.\r\n     *\r\n     * @param other The `DocumentReference` to compare against.\r\n     * @return true if this `DocumentReference` is equal to the provided one.\r\n     */\r\n    isEqual(other: DocumentReference<T>): boolean;\r\n\r\n    /**\r\n     * Writes to the document referred to by this `DocumentReference`. If the\r\n     * document does not yet exist, it will be created. If you pass\r\n     * `SetOptions`, the provided data can be merged into an existing document.\r\n     *\r\n     * @param data A map of the fields and values for the document.\r\n     * @param options An object to configure the set behavior.\r\n     * @return A Promise resolved once the data has been successfully written\r\n     * to the backend (Note that it won't resolve while you're offline).\r\n     */\r\n    set(data: Partial<T>, options: SetOptions): Promise<void>;\r\n\r\n    /**\r\n     * Writes to the document referred to by this `DocumentReference`. If the\r\n     * document does not yet exist, it will be created. If you pass\r\n     * `SetOptions`, the provided data can be merged into an existing document.\r\n     *\r\n     * @param data A map of the fields and values for the document.\r\n     * @return A Promise resolved once the data has been successfully written\r\n     * to the backend (Note that it won't resolve while you're offline).\r\n     */\r\n    set(data: T): Promise<void>;\r\n\r\n    /**\r\n     * Updates fields in the document referred to by this `DocumentReference`.\r\n     * The update will fail if applied to a document that does not exist.\r\n     *\r\n     * @param data An object containing the fields and values with which to\r\n     * update the document. Fields can contain dots to reference nested fields\r\n     * within the document.\r\n     * @return A Promise resolved once the data has been successfully written\r\n     * to the backend (Note that it won't resolve while you're offline).\r\n     */\r\n    update(data: UpdateData): Promise<void>;\r\n\r\n    /**\r\n     * Updates fields in the document referred to by this `DocumentReference`.\r\n     * The update will fail if applied to a document that does not exist.\r\n     *\r\n     * Nested fields can be updated by providing dot-separated field path\r\n     * strings or by providing FieldPath objects.\r\n     *\r\n     * @param field The first field to update.\r\n     * @param value The first value.\r\n     * @param moreFieldsAndValues Additional key value pairs.\r\n     * @return A Promise resolved once the data has been successfully written\r\n     * to the backend (Note that it won't resolve while you're offline).\r\n     */\r\n    update(\r\n      field: string | FieldPath,\r\n      value: any,\r\n      ...moreFieldsAndValues: any[]\r\n    ): Promise<void>;\r\n\r\n    /**\r\n     * Deletes the document referred to by this `DocumentReference`.\r\n     *\r\n     * @return A Promise resolved once the document has been successfully\r\n     * deleted from the backend (Note that it won't resolve while you're\r\n     * offline).\r\n     */\r\n    delete(): Promise<void>;\r\n\r\n    /**\r\n     * Reads the document referred to by this `DocumentReference`.\r\n     *\r\n     * Note: By default, get() attempts to provide up-to-date data when possible\r\n     * by waiting for data from the server, but it may return cached data or fail\r\n     * if you are offline and the server cannot be reached. This behavior can be\r\n     * altered via the `GetOptions` parameter.\r\n     *\r\n     * @param options An object to configure the get behavior.\r\n     * @return A Promise resolved with a DocumentSnapshot containing the\r\n     * current document contents.\r\n     */\r\n    get(options?: GetOptions): Promise<DocumentSnapshot<T>>;\r\n\r\n    /**\r\n     * Attaches a listener for DocumentSnapshot events. You may either pass\r\n     * individual `onNext` and `onError` callbacks or pass a single observer\r\n     * object with `next` and `error` callbacks.\r\n     *\r\n     * NOTE: Although an `onCompletion` callback can be provided, it will\r\n     * never be called because the snapshot stream is never-ending.\r\n     *\r\n     * @param observer A single object containing `next` and `error` callbacks.\r\n     * @return An unsubscribe function that can be called to cancel\r\n     * the snapshot listener.\r\n     */\r\n    onSnapshot(observer: {\r\n      next?: (snapshot: DocumentSnapshot<T>) => void;\r\n      error?: (error: FirestoreError) => void;\r\n      complete?: () => void;\r\n    }): () => void;\r\n    /**\r\n     * Attaches a listener for DocumentSnapshot events. You may either pass\r\n     * individual `onNext` and `onError` callbacks or pass a single observer\r\n     * object with `next` and `error` callbacks.\r\n     *\r\n     * NOTE: Although an `onCompletion` callback can be provided, it will\r\n     * never be called because the snapshot stream is never-ending.\r\n     *\r\n     * @param options Options controlling the listen behavior.\r\n     * @param observer A single object containing `next` and `error` callbacks.\r\n     * @return An unsubscribe function that can be called to cancel\r\n     * the snapshot listener.\r\n     */\r\n    onSnapshot(\r\n      options: SnapshotListenOptions,\r\n      observer: {\r\n        next?: (snapshot: DocumentSnapshot<T>) => void;\r\n        error?: (error: FirestoreError) => void;\r\n        complete?: () => void;\r\n      },\r\n    ): () => void;\r\n    /**\r\n     * Attaches a listener for DocumentSnapshot events. You may either pass\r\n     * individual `onNext` and `onError` callbacks or pass a single observer\r\n     * object with `next` and `error` callbacks.\r\n     *\r\n     * NOTE: Although an `onCompletion` callback can be provided, it will\r\n     * never be called because the snapshot stream is never-ending.\r\n     *\r\n     * @param onNext A callback to be called every time a new `DocumentSnapshot`\r\n     * is available.\r\n     * @param onError A callback to be called if the listen fails or is\r\n     * cancelled. No further callbacks will occur.\r\n     * @return An unsubscribe function that can be called to cancel\r\n     * the snapshot listener.\r\n     */\r\n    onSnapshot(\r\n      onNext: (snapshot: DocumentSnapshot<T>) => void,\r\n      onError?: (error: FirestoreError) => void,\r\n      onCompletion?: () => void,\r\n    ): () => void;\r\n    /**\r\n     * Attaches a listener for DocumentSnapshot events. You may either pass\r\n     * individual `onNext` and `onError` callbacks or pass a single observer\r\n     * object with `next` and `error` callbacks.\r\n     *\r\n     * NOTE: Although an `onCompletion` callback can be provided, it will\r\n     * never be called because the snapshot stream is never-ending.\r\n     *\r\n     * @param options Options controlling the listen behavior.\r\n     * @param onNext A callback to be called every time a new `DocumentSnapshot`\r\n     * is available.\r\n     * @param onError A callback to be called if the listen fails or is\r\n     * cancelled. No further callbacks will occur.\r\n     * @return An unsubscribe function that can be called to cancel\r\n     * the snapshot listener.\r\n     */\r\n    onSnapshot(\r\n      options: SnapshotListenOptions,\r\n      onNext: (snapshot: DocumentSnapshot<T>) => void,\r\n      onError?: (error: FirestoreError) => void,\r\n      onCompletion?: () => void,\r\n    ): () => void;\r\n\r\n    /**\r\n     * Applies a custom data converter to this DocumentReference, allowing you\r\n     * to use your own custom model objects with Firestore. When you call\r\n     * set(), get(), etc. on the returned DocumentReference instance, the\r\n     * provided converter will convert between Firestore data and your custom\r\n     * type U.\r\n     *\r\n     * Passing in `null` as the converter parameter removes the current\r\n     * converter.\r\n     *\r\n     * @param converter Converts objects to and from Firestore. Passing in\r\n     * `null` removes the current converter.\r\n     * @return A DocumentReference<U> that uses the provided converter.\r\n     */\r\n    withConverter(converter: null): DocumentReference<DocumentData>;\r\n    /**\r\n     * Applies a custom data converter to this DocumentReference, allowing you\r\n     * to use your own custom model objects with Firestore. When you call\r\n     * set(), get(), etc. on the returned DocumentReference instance, the\r\n     * provided converter will convert between Firestore data and your custom\r\n     * type U.\r\n     *\r\n     * Passing in `null` as the converter parameter removes the current\r\n     * converter.\r\n     *\r\n     * @param converter Converts objects to and from Firestore. Passing in\r\n     * `null` removes the current converter.\r\n     * @return A DocumentReference<U> that uses the provided converter.\r\n     */\r\n    withConverter<U>(\r\n      converter: FirestoreDataConverter<U>,\r\n    ): DocumentReference<U>;\r\n  }\r\n\r\n  /**\r\n   * Options that configure how data is retrieved from a `DocumentSnapshot`\r\n   * (e.g. the desired behavior for server timestamps that have not yet been set\r\n   * to their final value).\r\n   */\r\n  export interface SnapshotOptions {\r\n    /**\r\n     * If set, controls the return value for server timestamps that have not yet\r\n     * been set to their final value.\r\n     *\r\n     * By specifying 'estimate', pending server timestamps return an estimate\r\n     * based on the local clock. This estimate will differ from the final value\r\n     * and cause these values to change once the server result becomes available.\r\n     *\r\n     * By specifying 'previous', pending timestamps will be ignored and return\r\n     * their previous value instead.\r\n     *\r\n     * If omitted or set to 'none', `null` will be returned by default until the\r\n     * server value becomes available.\r\n     */\r\n    readonly serverTimestamps?: \"estimate\" | \"previous\" | \"none\";\r\n  }\r\n\r\n  /**\r\n   * Metadata about a snapshot, describing the state of the snapshot.\r\n   */\r\n  export interface SnapshotMetadata {\r\n    /**\r\n     * True if the snapshot contains the result of local writes (e.g. set() or\r\n     * update() calls) that have not yet been committed to the backend.\r\n     * If your listener has opted into metadata updates (via\r\n     * `SnapshotListenOptions`) you will receive another\r\n     * snapshot with `hasPendingWrites` equal to false once the writes have been\r\n     * committed to the backend.\r\n     */\r\n    readonly hasPendingWrites: boolean;\r\n\r\n    /**\r\n     * True if the snapshot was created from cached data rather than guaranteed\r\n     * up-to-date server data. If your listener has opted into metadata updates\r\n     * (via `SnapshotListenOptions`)\r\n     * you will receive another snapshot with `fromCache` set to false once\r\n     * the client has received up-to-date data from the backend.\r\n     */\r\n    readonly fromCache: boolean;\r\n\r\n    /**\r\n     * Returns true if this `SnapshotMetadata` is equal to the provided one.\r\n     *\r\n     * @param other The `SnapshotMetadata` to compare against.\r\n     * @return true if this `SnapshotMetadata` is equal to the provided one.\r\n     */\r\n    isEqual(other: SnapshotMetadata): boolean;\r\n  }\r\n\r\n  /**\r\n   * A `DocumentSnapshot` contains data read from a document in your Firestore\r\n   * database. The data can be extracted with `.data()` or `.get(<field>)` to\r\n   * get a specific field.\r\n   *\r\n   * For a `DocumentSnapshot` that points to a non-existing document, any data\r\n   * access will return 'undefined'. You can use the `exists` property to\r\n   * explicitly verify a document's existence.\r\n   */\r\n  export class DocumentSnapshot<T = DocumentData> {\r\n    protected constructor();\r\n\r\n    /**\r\n     * Property of the `DocumentSnapshot` that signals whether or not the data\r\n     * exists. True if the document exists.\r\n     */\r\n    readonly exists: boolean;\r\n    /**\r\n     * The `DocumentReference` for the document included in the `DocumentSnapshot`.\r\n     */\r\n    readonly ref: DocumentReference<T>;\r\n    /**\r\n     * Property of the `DocumentSnapshot` that provides the document's ID.\r\n     */\r\n    readonly id: string;\r\n    /**\r\n     *  Metadata about the `DocumentSnapshot`, including information about its\r\n     *  source and local modifications.\r\n     */\r\n    readonly metadata: SnapshotMetadata;\r\n\r\n    /**\r\n     * Retrieves all fields in the document as an Object. Returns 'undefined' if\r\n     * the document doesn't exist.\r\n     *\r\n     * By default, `FieldValue.serverTimestamp()` values that have not yet been\r\n     * set to their final value will be returned as `null`. You can override\r\n     * this by passing an options object.\r\n     *\r\n     * @param options An options object to configure how data is retrieved from\r\n     * the snapshot (e.g. the desired behavior for server timestamps that have\r\n     * not yet been set to their final value).\r\n     * @return An Object containing all fields in the document or 'undefined' if\r\n     * the document doesn't exist.\r\n     */\r\n    data(options?: SnapshotOptions): T | undefined;\r\n\r\n    /**\r\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\r\n     * document or field doesn't exist.\r\n     *\r\n     * By default, a `FieldValue.serverTimestamp()` that has not yet been set to\r\n     * its final value will be returned as `null`. You can override this by\r\n     * passing an options object.\r\n     *\r\n     * @param fieldPath The path (e.g. 'foo' or 'foo.bar') to a specific field.\r\n     * @param options An options object to configure how the field is retrieved\r\n     * from the snapshot (e.g. the desired behavior for server timestamps that have\r\n     * not yet been set to their final value).\r\n     * @return The data at the specified field location or undefined if no such\r\n     * field exists in the document.\r\n     */\r\n    get(fieldPath: string | FieldPath, options?: SnapshotOptions): any;\r\n\r\n    /**\r\n     * Returns true if this `DocumentSnapshot` is equal to the provided one.\r\n     *\r\n     * @param other The `DocumentSnapshot` to compare against.\r\n     * @return true if this `DocumentSnapshot` is equal to the provided one.\r\n     */\r\n    isEqual(other: DocumentSnapshot<T>): boolean;\r\n  }\r\n\r\n  /**\r\n   * A `QueryDocumentSnapshot` contains data read from a document in your\r\n   * Firestore database as part of a query. The document is guaranteed to exist\r\n   * and its data can be extracted with `.data()` or `.get(<field>)` to get a\r\n   * specific field.\r\n   *\r\n   * A `QueryDocumentSnapshot` offers the same API surface as a\r\n   * `DocumentSnapshot`. Since query results contain only existing documents, the\r\n   * `exists` property will always be true and `data()` will never return\r\n   * 'undefined'.\r\n   */\r\n  export class QueryDocumentSnapshot<\r\n    T = DocumentData,\r\n  > extends DocumentSnapshot<T> {\r\n    private constructor();\r\n\r\n    /**\r\n     * Retrieves all fields in the document as an Object.\r\n     *\r\n     * By default, `FieldValue.serverTimestamp()` values that have not yet been\r\n     * set to their final value will be returned as `null`. You can override\r\n     * this by passing an options object.\r\n     *\r\n     * @override\r\n     * @param options An options object to configure how data is retrieved from\r\n     * the snapshot (e.g. the desired behavior for server timestamps that have\r\n     * not yet been set to their final value).\r\n     * @return An Object containing all fields in the document.\r\n     */\r\n    data(options?: SnapshotOptions): T;\r\n  }\r\n\r\n  /**\r\n   * The direction of a `Query.orderBy()` clause is specified as 'desc' or 'asc'\r\n   * (descending or ascending).\r\n   */\r\n  export type OrderByDirection = \"desc\" | \"asc\";\r\n\r\n  /**\r\n   * Filter conditions in a `Query.where()` clause are specified using the\r\n   * strings '<', '<=', '==', '!=', '>=', '>', 'array-contains', 'in',\r\n   * 'array-contains-any', and 'not-in'.\r\n   */\r\n  export type WhereFilterOp =\r\n    | \"<\"\r\n    | \"<=\"\r\n    | \"==\"\r\n    | \"!=\"\r\n    | \">=\"\r\n    | \">\"\r\n    | \"array-contains\"\r\n    | \"in\"\r\n    | \"array-contains-any\"\r\n    | \"not-in\";\r\n\r\n  /**\r\n   * A `Query` refers to a Query which you can read or listen to. You can also\r\n   * construct refined `Query` objects by adding filters and ordering.\r\n   */\r\n  export class Query<T = DocumentData> {\r\n    protected constructor();\r\n\r\n    /**\r\n     * The `Firestore` for the Firestore database (useful for performing\r\n     * transactions, etc.).\r\n     */\r\n    readonly firestore: Firestore;\r\n\r\n    /**\r\n     * Creates and returns a new Query with the additional filter that documents\r\n     * must contain the specified field and the value should satisfy the\r\n     * relation constraint provided.\r\n     *\r\n     * @param fieldPath The path to compare\r\n     * @param opStr The operation string (e.g \"<\", \"<=\", \"==\", \">\", \">=\").\r\n     * @param value The value for comparison\r\n     * @return The created Query.\r\n     */\r\n    where(\r\n      fieldPath: string | FieldPath,\r\n      opStr: WhereFilterOp,\r\n      value: any,\r\n    ): Query<T>;\r\n\r\n    /**\r\n     * Creates and returns a new Query that's additionally sorted by the\r\n     * specified field, optionally in descending order instead of ascending.\r\n     *\r\n     * @param fieldPath The field to sort by.\r\n     * @param directionStr Optional direction to sort by (`asc` or `desc`). If\r\n     * not specified, order will be ascending.\r\n     * @return The created Query.\r\n     */\r\n    orderBy(\r\n      fieldPath: string | FieldPath,\r\n      directionStr?: OrderByDirection,\r\n    ): Query<T>;\r\n\r\n    /**\r\n     * Creates and returns a new Query that only returns the first matching\r\n     * documents.\r\n     *\r\n     * @param limit The maximum number of items to return.\r\n     * @return The created Query.\r\n     */\r\n    limit(limit: number): Query<T>;\r\n\r\n    /**\r\n     * Creates and returns a new Query that only returns the last matching\r\n     * documents.\r\n     *\r\n     * You must specify at least one `orderBy` clause for `limitToLast` queries,\r\n     * otherwise an exception will be thrown during execution.\r\n     *\r\n     * @param limit The maximum number of items to return.\r\n     * @return The created Query.\r\n     */\r\n    limitToLast(limit: number): Query<T>;\r\n\r\n    /**\r\n     * Creates and returns a new Query that starts at the provided document\r\n     * (inclusive). The starting position is relative to the order of the query.\r\n     * The document must contain all of the fields provided in the `orderBy` of\r\n     * this query.\r\n     *\r\n     * @param snapshot The snapshot of the document to start at.\r\n     * @return The created Query.\r\n     */\r\n    startAt(snapshot: DocumentSnapshot<any>): Query<T>;\r\n\r\n    /**\r\n     * Creates and returns a new Query that starts at the provided fields\r\n     * relative to the order of the query. The order of the field values\r\n     * must match the order of the order by clauses of the query.\r\n     *\r\n     * @param fieldValues The field values to start this query at, in order\r\n     * of the query's order by.\r\n     * @return The created Query.\r\n     */\r\n    startAt(...fieldValues: any[]): Query<T>;\r\n\r\n    /**\r\n     * Creates and returns a new Query that starts after the provided document\r\n     * (exclusive). The starting position is relative to the order of the query.\r\n     * The document must contain all of the fields provided in the orderBy of\r\n     * this query.\r\n     *\r\n     * @param snapshot The snapshot of the document to start after.\r\n     * @return The created Query.\r\n     */\r\n    startAfter(snapshot: DocumentSnapshot<any>): Query<T>;\r\n\r\n    /**\r\n     * Creates and returns a new Query that starts after the provided fields\r\n     * relative to the order of the query. The order of the field values\r\n     * must match the order of the order by clauses of the query.\r\n     *\r\n     * @param fieldValues The field values to start this query after, in order\r\n     * of the query's order by.\r\n     * @return The created Query.\r\n     */\r\n    startAfter(...fieldValues: any[]): Query<T>;\r\n\r\n    /**\r\n     * Creates and returns a new Query that ends before the provided document\r\n     * (exclusive). The end position is relative to the order of the query. The\r\n     * document must contain all of the fields provided in the orderBy of this\r\n     * query.\r\n     *\r\n     * @param snapshot The snapshot of the document to end before.\r\n     * @return The created Query.\r\n     */\r\n    endBefore(snapshot: DocumentSnapshot<any>): Query<T>;\r\n\r\n    /**\r\n     * Creates and returns a new Query that ends before the provided fields\r\n     * relative to the order of the query. The order of the field values\r\n     * must match the order of the order by clauses of the query.\r\n     *\r\n     * @param fieldValues The field values to end this query before, in order\r\n     * of the query's order by.\r\n     * @return The created Query.\r\n     */\r\n    endBefore(...fieldValues: any[]): Query<T>;\r\n\r\n    /**\r\n     * Creates and returns a new Query that ends at the provided document\r\n     * (inclusive). The end position is relative to the order of the query. The\r\n     * document must contain all of the fields provided in the orderBy of this\r\n     * query.\r\n     *\r\n     * @param snapshot The snapshot of the document to end at.\r\n     * @return The created Query.\r\n     */\r\n    endAt(snapshot: DocumentSnapshot<any>): Query<T>;\r\n\r\n    /**\r\n     * Creates and returns a new Query that ends at the provided fields\r\n     * relative to the order of the query. The order of the field values\r\n     * must match the order of the order by clauses of the query.\r\n     *\r\n     * @param fieldValues The field values to end this query at, in order\r\n     * of the query's order by.\r\n     * @return The created Query.\r\n     */\r\n    endAt(...fieldValues: any[]): Query<T>;\r\n\r\n    /**\r\n     * Returns true if this `Query` is equal to the provided one.\r\n     *\r\n     * @param other The `Query` to compare against.\r\n     * @return true if this `Query` is equal to the provided one.\r\n     */\r\n    isEqual(other: Query<T>): boolean;\r\n\r\n    /**\r\n     * Executes the query and returns the results as a `QuerySnapshot`.\r\n     *\r\n     * Note: By default, get() attempts to provide up-to-date data when possible\r\n     * by waiting for data from the server, but it may return cached data or fail\r\n     * if you are offline and the server cannot be reached. This behavior can be\r\n     * altered via the `GetOptions` parameter.\r\n     *\r\n     * @param options An object to configure the get behavior.\r\n     * @return A Promise that will be resolved with the results of the Query.\r\n     */\r\n    get(options?: GetOptions): Promise<QuerySnapshot<T>>;\r\n\r\n    /**\r\n     * Attaches a listener for QuerySnapshot events. You may either pass\r\n     * individual `onNext` and `onError` callbacks or pass a single observer\r\n     * object with `next` and `error` callbacks. The listener can be cancelled by\r\n     * calling the function that is returned when `onSnapshot` is called.\r\n     *\r\n     * NOTE: Although an `onCompletion` callback can be provided, it will\r\n     * never be called because the snapshot stream is never-ending.\r\n     *\r\n     * @param observer A single object containing `next` and `error` callbacks.\r\n     * @return An unsubscribe function that can be called to cancel\r\n     * the snapshot listener.\r\n     */\r\n    onSnapshot(observer: {\r\n      next?: (snapshot: QuerySnapshot<T>) => void;\r\n      error?: (error: FirestoreError) => void;\r\n      complete?: () => void;\r\n    }): () => void;\r\n    /**\r\n     * Attaches a listener for QuerySnapshot events. You may either pass\r\n     * individual `onNext` and `onError` callbacks or pass a single observer\r\n     * object with `next` and `error` callbacks. The listener can be cancelled by\r\n     * calling the function that is returned when `onSnapshot` is called.\r\n     *\r\n     * NOTE: Although an `onCompletion` callback can be provided, it will\r\n     * never be called because the snapshot stream is never-ending.\r\n     *\r\n     * @param options Options controlling the listen behavior.\r\n     * @param observer A single object containing `next` and `error` callbacks.\r\n     * @return An unsubscribe function that can be called to cancel\r\n     * the snapshot listener.\r\n     */\r\n    onSnapshot(\r\n      options: SnapshotListenOptions,\r\n      observer: {\r\n        next?: (snapshot: QuerySnapshot<T>) => void;\r\n        error?: (error: FirestoreError) => void;\r\n        complete?: () => void;\r\n      },\r\n    ): () => void;\r\n    /**\r\n     * Attaches a listener for QuerySnapshot events. You may either pass\r\n     * individual `onNext` and `onError` callbacks or pass a single observer\r\n     * object with `next` and `error` callbacks. The listener can be cancelled by\r\n     * calling the function that is returned when `onSnapshot` is called.\r\n     *\r\n     * NOTE: Although an `onCompletion` callback can be provided, it will\r\n     * never be called because the snapshot stream is never-ending.\r\n     *\r\n     * @param onNext A callback to be called every time a new `QuerySnapshot`\r\n     * is available.\r\n     * @param onError A callback to be called if the listen fails or is\r\n     * cancelled. No further callbacks will occur.\r\n     * @return An unsubscribe function that can be called to cancel\r\n     * the snapshot listener.\r\n     */\r\n    onSnapshot(\r\n      onNext: (snapshot: QuerySnapshot<T>) => void,\r\n      onError?: (error: FirestoreError) => void,\r\n      onCompletion?: () => void,\r\n    ): () => void;\r\n    /**\r\n     * Attaches a listener for QuerySnapshot events. You may either pass\r\n     * individual `onNext` and `onError` callbacks or pass a single observer\r\n     * object with `next` and `error` callbacks. The listener can be cancelled by\r\n     * calling the function that is returned when `onSnapshot` is called.\r\n     *\r\n     * NOTE: Although an `onCompletion` callback can be provided, it will\r\n     * never be called because the snapshot stream is never-ending.\r\n     *\r\n     * @param options Options controlling the listen behavior.\r\n     * @param onNext A callback to be called every time a new `QuerySnapshot`\r\n     * is available.\r\n     * @param onError A callback to be called if the listen fails or is\r\n     * cancelled. No further callbacks will occur.\r\n     * @return An unsubscribe function that can be called to cancel\r\n     * the snapshot listener.\r\n     */\r\n    onSnapshot(\r\n      options: SnapshotListenOptions,\r\n      onNext: (snapshot: QuerySnapshot<T>) => void,\r\n      onError?: (error: FirestoreError) => void,\r\n      onCompletion?: () => void,\r\n    ): () => void;\r\n\r\n    /**\r\n     * Applies a custom data converter to this Query, allowing you to use your\r\n     * own custom model objects with Firestore. When you call get() on the\r\n     * returned Query, the provided converter will convert between Firestore\r\n     * data and your custom type U.\r\n     *\r\n     * Passing in `null` as the converter parameter removes the current\r\n     * converter.\r\n     *\r\n     * @param converter Converts objects to and from Firestore. Passing in\r\n     * `null` removes the current converter.\r\n     * @return A Query<U> that uses the provided converter.\r\n     */\r\n    withConverter(converter: null): Query<DocumentData>;\r\n    /**\r\n     * Applies a custom data converter to this Query, allowing you to use your\r\n     * own custom model objects with Firestore. When you call get() on the\r\n     * returned Query, the provided converter will convert between Firestore\r\n     * data and your custom type U.\r\n     *\r\n     * Passing in `null` as the converter parameter removes the current\r\n     * converter.\r\n     *\r\n     * @param converter Converts objects to and from Firestore. Passing in\r\n     * `null` removes the current converter.\r\n     * @return A Query<U> that uses the provided converter.\r\n     */\r\n    withConverter<U>(converter: FirestoreDataConverter<U>): Query<U>;\r\n  }\r\n\r\n  /**\r\n   * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\r\n   * representing the results of a query. The documents can be accessed as an\r\n   * array via the `docs` property or enumerated using the `forEach` method. The\r\n   * number of documents can be determined via the `empty` and `size`\r\n   * properties.\r\n   */\r\n  export class QuerySnapshot<T = DocumentData> {\r\n    private constructor();\r\n\r\n    /**\r\n     * The query on which you called `get` or `onSnapshot` in order to get this\r\n     * `QuerySnapshot`.\r\n     */\r\n    readonly query: Query<T>;\r\n    /**\r\n     * Metadata about this snapshot, concerning its source and if it has local\r\n     * modifications.\r\n     */\r\n    readonly metadata: SnapshotMetadata;\r\n\r\n    /** An array of all the documents in the `QuerySnapshot`. */\r\n    readonly docs: Array<QueryDocumentSnapshot<T>>;\r\n\r\n    /** The number of documents in the `QuerySnapshot`. */\r\n    readonly size: number;\r\n\r\n    /** True if there are no documents in the `QuerySnapshot`. */\r\n    readonly empty: boolean;\r\n\r\n    /**\r\n     * Returns an array of the documents changes since the last snapshot. If this\r\n     * is the first snapshot, all documents will be in the list as added changes.\r\n     *\r\n     * @param options `SnapshotListenOptions` that control whether metadata-only\r\n     * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger\r\n     * snapshot events.\r\n     */\r\n    docChanges(options?: SnapshotListenOptions): Array<DocumentChange<T>>;\r\n\r\n    /**\r\n     * Enumerates all of the documents in the `QuerySnapshot`.\r\n     *\r\n     * @param callback A callback to be called with a `QueryDocumentSnapshot` for\r\n     * each document in the snapshot.\r\n     * @param thisArg The `this` binding for the callback.\r\n     */\r\n    forEach(\r\n      callback: (result: QueryDocumentSnapshot<T>) => void,\r\n      thisArg?: any,\r\n    ): void;\r\n\r\n    /**\r\n     * Returns true if this `QuerySnapshot` is equal to the provided one.\r\n     *\r\n     * @param other The `QuerySnapshot` to compare against.\r\n     * @return true if this `QuerySnapshot` is equal to the provided one.\r\n     */\r\n    isEqual(other: QuerySnapshot<T>): boolean;\r\n  }\r\n\r\n  /**\r\n   * The type of a `DocumentChange` may be 'added', 'removed', or 'modified'.\r\n   */\r\n  export type DocumentChangeType = \"added\" | \"removed\" | \"modified\";\r\n\r\n  /**\r\n   * A `DocumentChange` represents a change to the documents matching a query.\r\n   * It contains the document affected and the type of change that occurred.\r\n   */\r\n  export interface DocumentChange<T = DocumentData> {\r\n    /** The type of change ('added', 'modified', or 'removed'). */\r\n    readonly type: DocumentChangeType;\r\n\r\n    /** The document affected by this change. */\r\n    readonly doc: QueryDocumentSnapshot<T>;\r\n\r\n    /**\r\n     * The index of the changed document in the result set immediately prior to\r\n     * this `DocumentChange` (i.e. supposing that all prior `DocumentChange` objects\r\n     * have been applied). Is -1 for 'added' events.\r\n     */\r\n    readonly oldIndex: number;\r\n\r\n    /**\r\n     * The index of the changed document in the result set immediately after\r\n     * this `DocumentChange` (i.e. supposing that all prior `DocumentChange`\r\n     * objects and the current `DocumentChange` object have been applied).\r\n     * Is -1 for 'removed' events.\r\n     */\r\n    readonly newIndex: number;\r\n  }\r\n\r\n  /**\r\n   * A `CollectionReference` object can be used for adding documents, getting\r\n   * document references, and querying for documents (using the methods\r\n   * inherited from `Query`).\r\n   */\r\n  export class CollectionReference<T = DocumentData> extends Query<T> {\r\n    private constructor();\r\n\r\n    /** The collection's identifier. */\r\n    readonly id: string;\r\n\r\n    /**\r\n     * A reference to the containing `DocumentReference` if this is a subcollection.\r\n     * If this isn't a subcollection, the reference is null.\r\n     */\r\n    readonly parent: DocumentReference<DocumentData> | null;\r\n\r\n    /**\r\n     * A string representing the path of the referenced collection (relative\r\n     * to the root of the database).\r\n     */\r\n    readonly path: string;\r\n\r\n    /**\r\n     * Get a `DocumentReference` for the document within the collection at the\r\n     * specified path. If no path is specified, an automatically-generated\r\n     * unique ID will be used for the returned DocumentReference.\r\n     *\r\n     * @param documentPath A slash-separated path to a document.\r\n     * @return The `DocumentReference` instance.\r\n     */\r\n    doc(documentPath?: string): DocumentReference<T>;\r\n\r\n    /**\r\n     * Add a new document to this collection with the specified data, assigning\r\n     * it a document ID automatically.\r\n     *\r\n     * @param data An Object containing the data for the new document.\r\n     * @return A Promise resolved with a `DocumentReference` pointing to the\r\n     * newly created document after it has been written to the backend.\r\n     */\r\n    add(data: T): Promise<DocumentReference<T>>;\r\n\r\n    /**\r\n     * Returns true if this `CollectionReference` is equal to the provided one.\r\n     *\r\n     * @param other The `CollectionReference` to compare against.\r\n     * @return true if this `CollectionReference` is equal to the provided one.\r\n     */\r\n    isEqual(other: CollectionReference<T>): boolean;\r\n\r\n    /**\r\n     * Applies a custom data converter to this CollectionReference, allowing you\r\n     * to use your own custom model objects with Firestore. When you call add()\r\n     * on the returned CollectionReference instance, the provided converter will\r\n     * convert between Firestore data and your custom type U.\r\n     *\r\n     * Passing in `null` as the converter parameter removes the current\r\n     * converter.\r\n     *\r\n     * @param converter Converts objects to and from Firestore. Passing in\r\n     * `null` removes the current converter.\r\n     * @return A CollectionReference<U> that uses the provided converter.\r\n     */\r\n    withConverter(converter: null): CollectionReference<DocumentData>;\r\n    /**\r\n     * Applies a custom data converter to this CollectionReference, allowing you\r\n     * to use your own custom model objects with Firestore. When you call add()\r\n     * on the returned CollectionReference instance, the provided converter will\r\n     * convert between Firestore data and your custom type U.\r\n     *\r\n     * Passing in `null` as the converter parameter removes the current\r\n     * converter.\r\n     *\r\n     * @param converter Converts objects to and from Firestore. Passing in\r\n     * `null` removes the current converter.\r\n     * @return A CollectionReference<U> that uses the provided converter.\r\n     */\r\n    withConverter<U>(\r\n      converter: FirestoreDataConverter<U>,\r\n    ): CollectionReference<U>;\r\n  }\r\n\r\n  /**\r\n   * Sentinel values that can be used when writing document fields with `set()`\r\n   * or `update()`.\r\n   */\r\n  export class FieldValue {\r\n    private constructor();\r\n\r\n    /**\r\n     * Returns a sentinel used with `set()` or `update()` to include a\r\n     * server-generated timestamp in the written data.\r\n     */\r\n    static serverTimestamp(): FieldValue;\r\n\r\n    /**\r\n     * Returns a sentinel for use with `update()` to mark a field for deletion.\r\n     */\r\n    static delete(): FieldValue;\r\n\r\n    /**\r\n     * Returns a special value that can be used with `set()` or `update()` that tells\r\n     * the server to union the given elements with any array value that already\r\n     * exists on the server. Each specified element that doesn't already exist in\r\n     * the array will be added to the end. If the field being modified is not\r\n     * already an array it will be overwritten with an array containing exactly\r\n     * the specified elements.\r\n     *\r\n     * @param elements The elements to union into the array.\r\n     * @return The FieldValue sentinel for use in a call to `set()` or `update()`.\r\n     */\r\n    static arrayUnion(...elements: any[]): FieldValue;\r\n\r\n    /**\r\n     * Returns a special value that can be used with `set()` or `update()` that tells\r\n     * the server to remove the given elements from any array value that already\r\n     * exists on the server. All instances of each element specified will be\r\n     * removed from the array. If the field being modified is not already an\r\n     * array it will be overwritten with an empty array.\r\n     *\r\n     * @param elements The elements to remove from the array.\r\n     * @return The FieldValue sentinel for use in a call to `set()` or `update()`.\r\n     */\r\n    static arrayRemove(...elements: any[]): FieldValue;\r\n\r\n    /**\r\n     * Returns a special value that can be used with `set()` or `update()` that tells\r\n     * the server to increment the field's current value by the given value.\r\n     *\r\n     * If either the operand or the current field value uses floating point precision,\r\n     * all arithmetic follows IEEE 754 semantics. If both values are integers,\r\n     * values outside of JavaScript's safe number range (`Number.MIN_SAFE_INTEGER` to\r\n     * `Number.MAX_SAFE_INTEGER`) are also subject to precision loss. Furthermore,\r\n     * once processed by the Firestore backend, all integer operations are capped\r\n     * between -2^63 and 2^63-1.\r\n     *\r\n     * If the current field value is not of type `number`, or if the field does not\r\n     * yet exist, the transformation sets the field to the given value.\r\n     *\r\n     * @param n The value to increment by.\r\n     * @return The FieldValue sentinel for use in a call to `set()` or `update()`.\r\n     */\r\n    static increment(n: number): FieldValue;\r\n\r\n    /**\r\n     * Returns true if this `FieldValue` is equal to the provided one.\r\n     *\r\n     * @param other The `FieldValue` to compare against.\r\n     * @return true if this `FieldValue` is equal to the provided one.\r\n     */\r\n    isEqual(other: FieldValue): boolean;\r\n  }\r\n\r\n  /**\r\n   * A FieldPath refers to a field in a document. The path may consist of a\r\n   * single field name (referring to a top-level field in the document), or a\r\n   * list of field names (referring to a nested field in the document).\r\n   *\r\n   * Create a FieldPath by providing field names. If more than one field\r\n   * name is provided, the path will point to a nested field in a document.\r\n   *\r\n   */\r\n  export class FieldPath {\r\n    /**\r\n     * Creates a FieldPath from the provided field names. If more than one field\r\n     * name is provided, the path will point to a nested field in a document.\r\n     *\r\n     * @param fieldNames A list of field names.\r\n     */\r\n    constructor(...fieldNames: string[]);\r\n\r\n    /**\r\n     * Returns a special sentinel `FieldPath` to refer to the ID of a document.\r\n     * It can be used in queries to sort or filter by the document ID.\r\n     */\r\n    static documentId(): FieldPath;\r\n\r\n    /**\r\n     * Returns true if this `FieldPath` is equal to the provided one.\r\n     *\r\n     * @param other The `FieldPath` to compare against.\r\n     * @return true if this `FieldPath` is equal to the provided one.\r\n     */\r\n    isEqual(other: FieldPath): boolean;\r\n  }\r\n\r\n  /**\r\n   * The set of Firestore status codes. The codes are the same at the ones\r\n   * exposed by gRPC here:\r\n   * https://github.com/grpc/grpc/blob/master/doc/statuscodes.md\r\n   *\r\n   * Possible values:\r\n   * - 'cancelled': The operation was cancelled (typically by the caller).\r\n   * - 'unknown': Unknown error or an error from a different error domain.\r\n   * - 'invalid-argument': Client specified an invalid argument. Note that this\r\n   *   differs from 'failed-precondition'. 'invalid-argument' indicates\r\n   *   arguments that are problematic regardless of the state of the system\r\n   *   (e.g. an invalid field name).\r\n   * - 'deadline-exceeded': Deadline expired before operation could complete.\r\n   *   For operations that change the state of the system, this error may be\r\n   *   returned even if the operation has completed successfully. For example,\r\n   *   a successful response from a server could have been delayed long enough\r\n   *   for the deadline to expire.\r\n   * - 'not-found': Some requested document was not found.\r\n   * - 'already-exists': Some document that we attempted to create already\r\n   *   exists.\r\n   * - 'permission-denied': The caller does not have permission to execute the\r\n   *   specified operation.\r\n   * - 'resource-exhausted': Some resource has been exhausted, perhaps a\r\n   *   per-user quota, or perhaps the entire file system is out of space.\r\n   * - 'failed-precondition': Operation was rejected because the system is not\r\n   *   in a state required for the operation's execution.\r\n   * - 'aborted': The operation was aborted, typically due to a concurrency\r\n   *   issue like transaction aborts, etc.\r\n   * - 'out-of-range': Operation was attempted past the valid range.\r\n   * - 'unimplemented': Operation is not implemented or not supported/enabled.\r\n   * - 'internal': Internal errors. Means some invariants expected by\r\n   *   underlying system has been broken. If you see one of these errors,\r\n   *   something is very broken.\r\n   * - 'unavailable': The service is currently unavailable. This is most likely\r\n   *   a transient condition and may be corrected by retrying with a backoff.\r\n   * - 'data-loss': Unrecoverable data loss or corruption.\r\n   * - 'unauthenticated': The request does not have valid authentication\r\n   *   credentials for the operation.\r\n   */\r\n  export type FirestoreErrorCode =\r\n    | \"cancelled\"\r\n    | \"unknown\"\r\n    | \"invalid-argument\"\r\n    | \"deadline-exceeded\"\r\n    | \"not-found\"\r\n    | \"already-exists\"\r\n    | \"permission-denied\"\r\n    | \"resource-exhausted\"\r\n    | \"failed-precondition\"\r\n    | \"aborted\"\r\n    | \"out-of-range\"\r\n    | \"unimplemented\"\r\n    | \"internal\"\r\n    | \"unavailable\"\r\n    | \"data-loss\"\r\n    | \"unauthenticated\";\r\n\r\n  /** An error returned by a Firestore operation. */\r\n  // TODO(b/63008957): FirestoreError should extend firebase.FirebaseError\r\n  export interface FirestoreError {\r\n    code: FirestoreErrorCode;\r\n    message: string;\r\n    name: string;\r\n    stack?: string;\r\n  }\r\n\r\n  export type EmulatorMockTokenOptions = firebase.EmulatorMockTokenOptions;\r\n}\r\n\r\ndeclare var firebase: firebase;\r\n"
}